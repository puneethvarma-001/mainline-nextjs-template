(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.TravelWidget = factory());
})(this, (function () { 'use strict';

	function getDefaultExportFromCjs (x) {
		return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
	}

	var jsxRuntime = {exports: {}};

	var reactJsxRuntime_production = {};

	/**
	 * @license React
	 * react-jsx-runtime.production.js
	 *
	 * Copyright (c) Meta Platforms, Inc. and affiliates.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */

	var hasRequiredReactJsxRuntime_production;

	function requireReactJsxRuntime_production () {
		if (hasRequiredReactJsxRuntime_production) return reactJsxRuntime_production;
		hasRequiredReactJsxRuntime_production = 1;
		var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"),
		  REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
		function jsxProd(type, config, maybeKey) {
		  var key = null;
		  void 0 !== maybeKey && (key = "" + maybeKey);
		  void 0 !== config.key && (key = "" + config.key);
		  if ("key" in config) {
		    maybeKey = {};
		    for (var propName in config)
		      "key" !== propName && (maybeKey[propName] = config[propName]);
		  } else maybeKey = config;
		  config = maybeKey.ref;
		  return {
		    $$typeof: REACT_ELEMENT_TYPE,
		    type: type,
		    key: key,
		    ref: void 0 !== config ? config : null,
		    props: maybeKey
		  };
		}
		reactJsxRuntime_production.Fragment = REACT_FRAGMENT_TYPE;
		reactJsxRuntime_production.jsx = jsxProd;
		reactJsxRuntime_production.jsxs = jsxProd;
		return reactJsxRuntime_production;
	}

	var hasRequiredJsxRuntime;

	function requireJsxRuntime () {
		if (hasRequiredJsxRuntime) return jsxRuntime.exports;
		hasRequiredJsxRuntime = 1;

		{
		  jsxRuntime.exports = requireReactJsxRuntime_production();
		}
		return jsxRuntime.exports;
	}

	var jsxRuntimeExports = requireJsxRuntime();

	var react = {exports: {}};

	var react_production = {};

	/**
	 * @license React
	 * react.production.js
	 *
	 * Copyright (c) Meta Platforms, Inc. and affiliates.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */

	var hasRequiredReact_production;

	function requireReact_production () {
		if (hasRequiredReact_production) return react_production;
		hasRequiredReact_production = 1;
		var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"),
		  REACT_PORTAL_TYPE = Symbol.for("react.portal"),
		  REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"),
		  REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"),
		  REACT_PROFILER_TYPE = Symbol.for("react.profiler"),
		  REACT_CONSUMER_TYPE = Symbol.for("react.consumer"),
		  REACT_CONTEXT_TYPE = Symbol.for("react.context"),
		  REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"),
		  REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"),
		  REACT_MEMO_TYPE = Symbol.for("react.memo"),
		  REACT_LAZY_TYPE = Symbol.for("react.lazy"),
		  MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
		function getIteratorFn(maybeIterable) {
		  if (null === maybeIterable || "object" !== typeof maybeIterable) return null;
		  maybeIterable =
		    (MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL]) ||
		    maybeIterable["@@iterator"];
		  return "function" === typeof maybeIterable ? maybeIterable : null;
		}
		var ReactNoopUpdateQueue = {
		    isMounted: function () {
		      return false;
		    },
		    enqueueForceUpdate: function () {},
		    enqueueReplaceState: function () {},
		    enqueueSetState: function () {}
		  },
		  assign = Object.assign,
		  emptyObject = {};
		function Component(props, context, updater) {
		  this.props = props;
		  this.context = context;
		  this.refs = emptyObject;
		  this.updater = updater || ReactNoopUpdateQueue;
		}
		Component.prototype.isReactComponent = {};
		Component.prototype.setState = function (partialState, callback) {
		  if (
		    "object" !== typeof partialState &&
		    "function" !== typeof partialState &&
		    null != partialState
		  )
		    throw Error(
		      "takes an object of state variables to update or a function which returns an object of state variables."
		    );
		  this.updater.enqueueSetState(this, partialState, callback, "setState");
		};
		Component.prototype.forceUpdate = function (callback) {
		  this.updater.enqueueForceUpdate(this, callback, "forceUpdate");
		};
		function ComponentDummy() {}
		ComponentDummy.prototype = Component.prototype;
		function PureComponent(props, context, updater) {
		  this.props = props;
		  this.context = context;
		  this.refs = emptyObject;
		  this.updater = updater || ReactNoopUpdateQueue;
		}
		var pureComponentPrototype = (PureComponent.prototype = new ComponentDummy());
		pureComponentPrototype.constructor = PureComponent;
		assign(pureComponentPrototype, Component.prototype);
		pureComponentPrototype.isPureReactComponent = true;
		var isArrayImpl = Array.isArray,
		  ReactSharedInternals = { H: null, A: null, T: null, S: null, V: null },
		  hasOwnProperty = Object.prototype.hasOwnProperty;
		function ReactElement(type, key, self, source, owner, props) {
		  self = props.ref;
		  return {
		    $$typeof: REACT_ELEMENT_TYPE,
		    type: type,
		    key: key,
		    ref: void 0 !== self ? self : null,
		    props: props
		  };
		}
		function cloneAndReplaceKey(oldElement, newKey) {
		  return ReactElement(
		    oldElement.type,
		    newKey,
		    void 0,
		    void 0,
		    void 0,
		    oldElement.props
		  );
		}
		function isValidElement(object) {
		  return (
		    "object" === typeof object &&
		    null !== object &&
		    object.$$typeof === REACT_ELEMENT_TYPE
		  );
		}
		function escape(key) {
		  var escaperLookup = { "=": "=0", ":": "=2" };
		  return (
		    "$" +
		    key.replace(/[=:]/g, function (match) {
		      return escaperLookup[match];
		    })
		  );
		}
		var userProvidedKeyEscapeRegex = /\/+/g;
		function getElementKey(element, index) {
		  return "object" === typeof element && null !== element && null != element.key
		    ? escape("" + element.key)
		    : index.toString(36);
		}
		function noop$1() {}
		function resolveThenable(thenable) {
		  switch (thenable.status) {
		    case "fulfilled":
		      return thenable.value;
		    case "rejected":
		      throw thenable.reason;
		    default:
		      switch (
		        ("string" === typeof thenable.status
		          ? thenable.then(noop$1, noop$1)
		          : ((thenable.status = "pending"),
		            thenable.then(
		              function (fulfilledValue) {
		                "pending" === thenable.status &&
		                  ((thenable.status = "fulfilled"),
		                  (thenable.value = fulfilledValue));
		              },
		              function (error) {
		                "pending" === thenable.status &&
		                  ((thenable.status = "rejected"), (thenable.reason = error));
		              }
		            )),
		        thenable.status)
		      ) {
		        case "fulfilled":
		          return thenable.value;
		        case "rejected":
		          throw thenable.reason;
		      }
		  }
		  throw thenable;
		}
		function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {
		  var type = typeof children;
		  if ("undefined" === type || "boolean" === type) children = null;
		  var invokeCallback = false;
		  if (null === children) invokeCallback = true;
		  else
		    switch (type) {
		      case "bigint":
		      case "string":
		      case "number":
		        invokeCallback = true;
		        break;
		      case "object":
		        switch (children.$$typeof) {
		          case REACT_ELEMENT_TYPE:
		          case REACT_PORTAL_TYPE:
		            invokeCallback = true;
		            break;
		          case REACT_LAZY_TYPE:
		            return (
		              (invokeCallback = children._init),
		              mapIntoArray(
		                invokeCallback(children._payload),
		                array,
		                escapedPrefix,
		                nameSoFar,
		                callback
		              )
		            );
		        }
		    }
		  if (invokeCallback)
		    return (
		      (callback = callback(children)),
		      (invokeCallback =
		        "" === nameSoFar ? "." + getElementKey(children, 0) : nameSoFar),
		      isArrayImpl(callback)
		        ? ((escapedPrefix = ""),
		          null != invokeCallback &&
		            (escapedPrefix =
		              invokeCallback.replace(userProvidedKeyEscapeRegex, "$&/") + "/"),
		          mapIntoArray(callback, array, escapedPrefix, "", function (c) {
		            return c;
		          }))
		        : null != callback &&
		          (isValidElement(callback) &&
		            (callback = cloneAndReplaceKey(
		              callback,
		              escapedPrefix +
		                (null == callback.key ||
		                (children && children.key === callback.key)
		                  ? ""
		                  : ("" + callback.key).replace(
		                      userProvidedKeyEscapeRegex,
		                      "$&/"
		                    ) + "/") +
		                invokeCallback
		            )),
		          array.push(callback)),
		      1
		    );
		  invokeCallback = 0;
		  var nextNamePrefix = "" === nameSoFar ? "." : nameSoFar + ":";
		  if (isArrayImpl(children))
		    for (var i = 0; i < children.length; i++)
		      (nameSoFar = children[i]),
		        (type = nextNamePrefix + getElementKey(nameSoFar, i)),
		        (invokeCallback += mapIntoArray(
		          nameSoFar,
		          array,
		          escapedPrefix,
		          type,
		          callback
		        ));
		  else if (((i = getIteratorFn(children)), "function" === typeof i))
		    for (
		      children = i.call(children), i = 0;
		      !(nameSoFar = children.next()).done;

		    )
		      (nameSoFar = nameSoFar.value),
		        (type = nextNamePrefix + getElementKey(nameSoFar, i++)),
		        (invokeCallback += mapIntoArray(
		          nameSoFar,
		          array,
		          escapedPrefix,
		          type,
		          callback
		        ));
		  else if ("object" === type) {
		    if ("function" === typeof children.then)
		      return mapIntoArray(
		        resolveThenable(children),
		        array,
		        escapedPrefix,
		        nameSoFar,
		        callback
		      );
		    array = String(children);
		    throw Error(
		      "Objects are not valid as a React child (found: " +
		        ("[object Object]" === array
		          ? "object with keys {" + Object.keys(children).join(", ") + "}"
		          : array) +
		        "). If you meant to render a collection of children, use an array instead."
		    );
		  }
		  return invokeCallback;
		}
		function mapChildren(children, func, context) {
		  if (null == children) return children;
		  var result = [],
		    count = 0;
		  mapIntoArray(children, result, "", "", function (child) {
		    return func.call(context, child, count++);
		  });
		  return result;
		}
		function lazyInitializer(payload) {
		  if (-1 === payload._status) {
		    var ctor = payload._result;
		    ctor = ctor();
		    ctor.then(
		      function (moduleObject) {
		        if (0 === payload._status || -1 === payload._status)
		          (payload._status = 1), (payload._result = moduleObject);
		      },
		      function (error) {
		        if (0 === payload._status || -1 === payload._status)
		          (payload._status = 2), (payload._result = error);
		      }
		    );
		    -1 === payload._status && ((payload._status = 0), (payload._result = ctor));
		  }
		  if (1 === payload._status) return payload._result.default;
		  throw payload._result;
		}
		var reportGlobalError =
		  "function" === typeof reportError
		    ? reportError
		    : function (error) {
		        if (
		          "object" === typeof window &&
		          "function" === typeof window.ErrorEvent
		        ) {
		          var event = new window.ErrorEvent("error", {
		            bubbles: true,
		            cancelable: true,
		            message:
		              "object" === typeof error &&
		              null !== error &&
		              "string" === typeof error.message
		                ? String(error.message)
		                : String(error),
		            error: error
		          });
		          if (!window.dispatchEvent(event)) return;
		        } else if (
		          "object" === typeof process &&
		          "function" === typeof process.emit
		        ) {
		          process.emit("uncaughtException", error);
		          return;
		        }
		        console.error(error);
		      };
		function noop() {}
		react_production.Children = {
		  map: mapChildren,
		  forEach: function (children, forEachFunc, forEachContext) {
		    mapChildren(
		      children,
		      function () {
		        forEachFunc.apply(this, arguments);
		      },
		      forEachContext
		    );
		  },
		  count: function (children) {
		    var n = 0;
		    mapChildren(children, function () {
		      n++;
		    });
		    return n;
		  },
		  toArray: function (children) {
		    return (
		      mapChildren(children, function (child) {
		        return child;
		      }) || []
		    );
		  },
		  only: function (children) {
		    if (!isValidElement(children))
		      throw Error(
		        "React.Children.only expected to receive a single React element child."
		      );
		    return children;
		  }
		};
		react_production.Component = Component;
		react_production.Fragment = REACT_FRAGMENT_TYPE;
		react_production.Profiler = REACT_PROFILER_TYPE;
		react_production.PureComponent = PureComponent;
		react_production.StrictMode = REACT_STRICT_MODE_TYPE;
		react_production.Suspense = REACT_SUSPENSE_TYPE;
		react_production.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE =
		  ReactSharedInternals;
		react_production.__COMPILER_RUNTIME = {
		  __proto__: null,
		  c: function (size) {
		    return ReactSharedInternals.H.useMemoCache(size);
		  }
		};
		react_production.cache = function (fn) {
		  return function () {
		    return fn.apply(null, arguments);
		  };
		};
		react_production.cloneElement = function (element, config, children) {
		  if (null === element || void 0 === element)
		    throw Error(
		      "The argument must be a React element, but you passed " + element + "."
		    );
		  var props = assign({}, element.props),
		    key = element.key,
		    owner = void 0;
		  if (null != config)
		    for (propName in (void 0 !== config.ref && (owner = void 0),
		    void 0 !== config.key && (key = "" + config.key),
		    config))
		      !hasOwnProperty.call(config, propName) ||
		        "key" === propName ||
		        "__self" === propName ||
		        "__source" === propName ||
		        ("ref" === propName && void 0 === config.ref) ||
		        (props[propName] = config[propName]);
		  var propName = arguments.length - 2;
		  if (1 === propName) props.children = children;
		  else if (1 < propName) {
		    for (var childArray = Array(propName), i = 0; i < propName; i++)
		      childArray[i] = arguments[i + 2];
		    props.children = childArray;
		  }
		  return ReactElement(element.type, key, void 0, void 0, owner, props);
		};
		react_production.createContext = function (defaultValue) {
		  defaultValue = {
		    $$typeof: REACT_CONTEXT_TYPE,
		    _currentValue: defaultValue,
		    _currentValue2: defaultValue,
		    _threadCount: 0,
		    Provider: null,
		    Consumer: null
		  };
		  defaultValue.Provider = defaultValue;
		  defaultValue.Consumer = {
		    $$typeof: REACT_CONSUMER_TYPE,
		    _context: defaultValue
		  };
		  return defaultValue;
		};
		react_production.createElement = function (type, config, children) {
		  var propName,
		    props = {},
		    key = null;
		  if (null != config)
		    for (propName in (void 0 !== config.key && (key = "" + config.key), config))
		      hasOwnProperty.call(config, propName) &&
		        "key" !== propName &&
		        "__self" !== propName &&
		        "__source" !== propName &&
		        (props[propName] = config[propName]);
		  var childrenLength = arguments.length - 2;
		  if (1 === childrenLength) props.children = children;
		  else if (1 < childrenLength) {
		    for (var childArray = Array(childrenLength), i = 0; i < childrenLength; i++)
		      childArray[i] = arguments[i + 2];
		    props.children = childArray;
		  }
		  if (type && type.defaultProps)
		    for (propName in ((childrenLength = type.defaultProps), childrenLength))
		      void 0 === props[propName] &&
		        (props[propName] = childrenLength[propName]);
		  return ReactElement(type, key, void 0, void 0, null, props);
		};
		react_production.createRef = function () {
		  return { current: null };
		};
		react_production.forwardRef = function (render) {
		  return { $$typeof: REACT_FORWARD_REF_TYPE, render: render };
		};
		react_production.isValidElement = isValidElement;
		react_production.lazy = function (ctor) {
		  return {
		    $$typeof: REACT_LAZY_TYPE,
		    _payload: { _status: -1, _result: ctor },
		    _init: lazyInitializer
		  };
		};
		react_production.memo = function (type, compare) {
		  return {
		    $$typeof: REACT_MEMO_TYPE,
		    type: type,
		    compare: void 0 === compare ? null : compare
		  };
		};
		react_production.startTransition = function (scope) {
		  var prevTransition = ReactSharedInternals.T,
		    currentTransition = {};
		  ReactSharedInternals.T = currentTransition;
		  try {
		    var returnValue = scope(),
		      onStartTransitionFinish = ReactSharedInternals.S;
		    null !== onStartTransitionFinish &&
		      onStartTransitionFinish(currentTransition, returnValue);
		    "object" === typeof returnValue &&
		      null !== returnValue &&
		      "function" === typeof returnValue.then &&
		      returnValue.then(noop, reportGlobalError);
		  } catch (error) {
		    reportGlobalError(error);
		  } finally {
		    ReactSharedInternals.T = prevTransition;
		  }
		};
		react_production.unstable_useCacheRefresh = function () {
		  return ReactSharedInternals.H.useCacheRefresh();
		};
		react_production.use = function (usable) {
		  return ReactSharedInternals.H.use(usable);
		};
		react_production.useActionState = function (action, initialState, permalink) {
		  return ReactSharedInternals.H.useActionState(action, initialState, permalink);
		};
		react_production.useCallback = function (callback, deps) {
		  return ReactSharedInternals.H.useCallback(callback, deps);
		};
		react_production.useContext = function (Context) {
		  return ReactSharedInternals.H.useContext(Context);
		};
		react_production.useDebugValue = function () {};
		react_production.useDeferredValue = function (value, initialValue) {
		  return ReactSharedInternals.H.useDeferredValue(value, initialValue);
		};
		react_production.useEffect = function (create, createDeps, update) {
		  var dispatcher = ReactSharedInternals.H;
		  if ("function" === typeof update)
		    throw Error(
		      "useEffect CRUD overload is not enabled in this build of React."
		    );
		  return dispatcher.useEffect(create, createDeps);
		};
		react_production.useId = function () {
		  return ReactSharedInternals.H.useId();
		};
		react_production.useImperativeHandle = function (ref, create, deps) {
		  return ReactSharedInternals.H.useImperativeHandle(ref, create, deps);
		};
		react_production.useInsertionEffect = function (create, deps) {
		  return ReactSharedInternals.H.useInsertionEffect(create, deps);
		};
		react_production.useLayoutEffect = function (create, deps) {
		  return ReactSharedInternals.H.useLayoutEffect(create, deps);
		};
		react_production.useMemo = function (create, deps) {
		  return ReactSharedInternals.H.useMemo(create, deps);
		};
		react_production.useOptimistic = function (passthrough, reducer) {
		  return ReactSharedInternals.H.useOptimistic(passthrough, reducer);
		};
		react_production.useReducer = function (reducer, initialArg, init) {
		  return ReactSharedInternals.H.useReducer(reducer, initialArg, init);
		};
		react_production.useRef = function (initialValue) {
		  return ReactSharedInternals.H.useRef(initialValue);
		};
		react_production.useState = function (initialState) {
		  return ReactSharedInternals.H.useState(initialState);
		};
		react_production.useSyncExternalStore = function (
		  subscribe,
		  getSnapshot,
		  getServerSnapshot
		) {
		  return ReactSharedInternals.H.useSyncExternalStore(
		    subscribe,
		    getSnapshot,
		    getServerSnapshot
		  );
		};
		react_production.useTransition = function () {
		  return ReactSharedInternals.H.useTransition();
		};
		react_production.version = "19.1.0";
		return react_production;
	}

	var hasRequiredReact;

	function requireReact () {
		if (hasRequiredReact) return react.exports;
		hasRequiredReact = 1;

		{
		  react.exports = requireReact_production();
		}
		return react.exports;
	}

	var reactExports = requireReact();
	var React = /*@__PURE__*/getDefaultExportFromCjs(reactExports);

	var client = {exports: {}};

	var reactDomClient_production = {};

	var scheduler = {exports: {}};

	var scheduler_production = {};

	/**
	 * @license React
	 * scheduler.production.js
	 *
	 * Copyright (c) Meta Platforms, Inc. and affiliates.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */

	var hasRequiredScheduler_production;

	function requireScheduler_production () {
		if (hasRequiredScheduler_production) return scheduler_production;
		hasRequiredScheduler_production = 1;
		(function (exports$1) {
			function push(heap, node) {
			  var index = heap.length;
			  heap.push(node);
			  a: for (; 0 < index; ) {
			    var parentIndex = (index - 1) >>> 1,
			      parent = heap[parentIndex];
			    if (0 < compare(parent, node))
			      (heap[parentIndex] = node), (heap[index] = parent), (index = parentIndex);
			    else break a;
			  }
			}
			function peek(heap) {
			  return 0 === heap.length ? null : heap[0];
			}
			function pop(heap) {
			  if (0 === heap.length) return null;
			  var first = heap[0],
			    last = heap.pop();
			  if (last !== first) {
			    heap[0] = last;
			    a: for (
			      var index = 0, length = heap.length, halfLength = length >>> 1;
			      index < halfLength;

			    ) {
			      var leftIndex = 2 * (index + 1) - 1,
			        left = heap[leftIndex],
			        rightIndex = leftIndex + 1,
			        right = heap[rightIndex];
			      if (0 > compare(left, last))
			        rightIndex < length && 0 > compare(right, left)
			          ? ((heap[index] = right),
			            (heap[rightIndex] = last),
			            (index = rightIndex))
			          : ((heap[index] = left),
			            (heap[leftIndex] = last),
			            (index = leftIndex));
			      else if (rightIndex < length && 0 > compare(right, last))
			        (heap[index] = right), (heap[rightIndex] = last), (index = rightIndex);
			      else break a;
			    }
			  }
			  return first;
			}
			function compare(a, b) {
			  var diff = a.sortIndex - b.sortIndex;
			  return 0 !== diff ? diff : a.id - b.id;
			}
			exports$1.unstable_now = void 0;
			if ("object" === typeof performance && "function" === typeof performance.now) {
			  var localPerformance = performance;
			  exports$1.unstable_now = function () {
			    return localPerformance.now();
			  };
			} else {
			  var localDate = Date,
			    initialTime = localDate.now();
			  exports$1.unstable_now = function () {
			    return localDate.now() - initialTime;
			  };
			}
			var taskQueue = [],
			  timerQueue = [],
			  taskIdCounter = 1,
			  currentTask = null,
			  currentPriorityLevel = 3,
			  isPerformingWork = false,
			  isHostCallbackScheduled = false,
			  isHostTimeoutScheduled = false,
			  needsPaint = false,
			  localSetTimeout = "function" === typeof setTimeout ? setTimeout : null,
			  localClearTimeout = "function" === typeof clearTimeout ? clearTimeout : null,
			  localSetImmediate = "undefined" !== typeof setImmediate ? setImmediate : null;
			function advanceTimers(currentTime) {
			  for (var timer = peek(timerQueue); null !== timer; ) {
			    if (null === timer.callback) pop(timerQueue);
			    else if (timer.startTime <= currentTime)
			      pop(timerQueue),
			        (timer.sortIndex = timer.expirationTime),
			        push(taskQueue, timer);
			    else break;
			    timer = peek(timerQueue);
			  }
			}
			function handleTimeout(currentTime) {
			  isHostTimeoutScheduled = false;
			  advanceTimers(currentTime);
			  if (!isHostCallbackScheduled)
			    if (null !== peek(taskQueue))
			      (isHostCallbackScheduled = true),
			        isMessageLoopRunning ||
			          ((isMessageLoopRunning = true), schedulePerformWorkUntilDeadline());
			    else {
			      var firstTimer = peek(timerQueue);
			      null !== firstTimer &&
			        requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
			    }
			}
			var isMessageLoopRunning = false,
			  taskTimeoutID = -1,
			  frameInterval = 5,
			  startTime = -1;
			function shouldYieldToHost() {
			  return needsPaint
			    ? true
			    : exports$1.unstable_now() - startTime < frameInterval
			      ? false
			      : true;
			}
			function performWorkUntilDeadline() {
			  needsPaint = false;
			  if (isMessageLoopRunning) {
			    var currentTime = exports$1.unstable_now();
			    startTime = currentTime;
			    var hasMoreWork = true;
			    try {
			      a: {
			        isHostCallbackScheduled = !1;
			        isHostTimeoutScheduled &&
			          ((isHostTimeoutScheduled = !1),
			          localClearTimeout(taskTimeoutID),
			          (taskTimeoutID = -1));
			        isPerformingWork = !0;
			        var previousPriorityLevel = currentPriorityLevel;
			        try {
			          b: {
			            advanceTimers(currentTime);
			            for (
			              currentTask = peek(taskQueue);
			              null !== currentTask &&
			              !(
			                currentTask.expirationTime > currentTime && shouldYieldToHost()
			              );

			            ) {
			              var callback = currentTask.callback;
			              if ("function" === typeof callback) {
			                currentTask.callback = null;
			                currentPriorityLevel = currentTask.priorityLevel;
			                var continuationCallback = callback(
			                  currentTask.expirationTime <= currentTime
			                );
			                currentTime = exports$1.unstable_now();
			                if ("function" === typeof continuationCallback) {
			                  currentTask.callback = continuationCallback;
			                  advanceTimers(currentTime);
			                  hasMoreWork = !0;
			                  break b;
			                }
			                currentTask === peek(taskQueue) && pop(taskQueue);
			                advanceTimers(currentTime);
			              } else pop(taskQueue);
			              currentTask = peek(taskQueue);
			            }
			            if (null !== currentTask) hasMoreWork = !0;
			            else {
			              var firstTimer = peek(timerQueue);
			              null !== firstTimer &&
			                requestHostTimeout(
			                  handleTimeout,
			                  firstTimer.startTime - currentTime
			                );
			              hasMoreWork = !1;
			            }
			          }
			          break a;
			        } finally {
			          (currentTask = null),
			            (currentPriorityLevel = previousPriorityLevel),
			            (isPerformingWork = !1);
			        }
			        hasMoreWork = void 0;
			      }
			    } finally {
			      hasMoreWork
			        ? schedulePerformWorkUntilDeadline()
			        : (isMessageLoopRunning = false);
			    }
			  }
			}
			var schedulePerformWorkUntilDeadline;
			if ("function" === typeof localSetImmediate)
			  schedulePerformWorkUntilDeadline = function () {
			    localSetImmediate(performWorkUntilDeadline);
			  };
			else if ("undefined" !== typeof MessageChannel) {
			  var channel = new MessageChannel(),
			    port = channel.port2;
			  channel.port1.onmessage = performWorkUntilDeadline;
			  schedulePerformWorkUntilDeadline = function () {
			    port.postMessage(null);
			  };
			} else
			  schedulePerformWorkUntilDeadline = function () {
			    localSetTimeout(performWorkUntilDeadline, 0);
			  };
			function requestHostTimeout(callback, ms) {
			  taskTimeoutID = localSetTimeout(function () {
			    callback(exports$1.unstable_now());
			  }, ms);
			}
			exports$1.unstable_IdlePriority = 5;
			exports$1.unstable_ImmediatePriority = 1;
			exports$1.unstable_LowPriority = 4;
			exports$1.unstable_NormalPriority = 3;
			exports$1.unstable_Profiling = null;
			exports$1.unstable_UserBlockingPriority = 2;
			exports$1.unstable_cancelCallback = function (task) {
			  task.callback = null;
			};
			exports$1.unstable_forceFrameRate = function (fps) {
			  0 > fps || 125 < fps
			    ? console.error(
			        "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
			      )
			    : (frameInterval = 0 < fps ? Math.floor(1e3 / fps) : 5);
			};
			exports$1.unstable_getCurrentPriorityLevel = function () {
			  return currentPriorityLevel;
			};
			exports$1.unstable_next = function (eventHandler) {
			  switch (currentPriorityLevel) {
			    case 1:
			    case 2:
			    case 3:
			      var priorityLevel = 3;
			      break;
			    default:
			      priorityLevel = currentPriorityLevel;
			  }
			  var previousPriorityLevel = currentPriorityLevel;
			  currentPriorityLevel = priorityLevel;
			  try {
			    return eventHandler();
			  } finally {
			    currentPriorityLevel = previousPriorityLevel;
			  }
			};
			exports$1.unstable_requestPaint = function () {
			  needsPaint = true;
			};
			exports$1.unstable_runWithPriority = function (priorityLevel, eventHandler) {
			  switch (priorityLevel) {
			    case 1:
			    case 2:
			    case 3:
			    case 4:
			    case 5:
			      break;
			    default:
			      priorityLevel = 3;
			  }
			  var previousPriorityLevel = currentPriorityLevel;
			  currentPriorityLevel = priorityLevel;
			  try {
			    return eventHandler();
			  } finally {
			    currentPriorityLevel = previousPriorityLevel;
			  }
			};
			exports$1.unstable_scheduleCallback = function (
			  priorityLevel,
			  callback,
			  options
			) {
			  var currentTime = exports$1.unstable_now();
			  "object" === typeof options && null !== options
			    ? ((options = options.delay),
			      (options =
			        "number" === typeof options && 0 < options
			          ? currentTime + options
			          : currentTime))
			    : (options = currentTime);
			  switch (priorityLevel) {
			    case 1:
			      var timeout = -1;
			      break;
			    case 2:
			      timeout = 250;
			      break;
			    case 5:
			      timeout = 1073741823;
			      break;
			    case 4:
			      timeout = 1e4;
			      break;
			    default:
			      timeout = 5e3;
			  }
			  timeout = options + timeout;
			  priorityLevel = {
			    id: taskIdCounter++,
			    callback: callback,
			    priorityLevel: priorityLevel,
			    startTime: options,
			    expirationTime: timeout,
			    sortIndex: -1
			  };
			  options > currentTime
			    ? ((priorityLevel.sortIndex = options),
			      push(timerQueue, priorityLevel),
			      null === peek(taskQueue) &&
			        priorityLevel === peek(timerQueue) &&
			        (isHostTimeoutScheduled
			          ? (localClearTimeout(taskTimeoutID), (taskTimeoutID = -1))
			          : (isHostTimeoutScheduled = true),
			        requestHostTimeout(handleTimeout, options - currentTime)))
			    : ((priorityLevel.sortIndex = timeout),
			      push(taskQueue, priorityLevel),
			      isHostCallbackScheduled ||
			        isPerformingWork ||
			        ((isHostCallbackScheduled = true),
			        isMessageLoopRunning ||
			          ((isMessageLoopRunning = true), schedulePerformWorkUntilDeadline())));
			  return priorityLevel;
			};
			exports$1.unstable_shouldYield = shouldYieldToHost;
			exports$1.unstable_wrapCallback = function (callback) {
			  var parentPriorityLevel = currentPriorityLevel;
			  return function () {
			    var previousPriorityLevel = currentPriorityLevel;
			    currentPriorityLevel = parentPriorityLevel;
			    try {
			      return callback.apply(this, arguments);
			    } finally {
			      currentPriorityLevel = previousPriorityLevel;
			    }
			  };
			}; 
		} (scheduler_production));
		return scheduler_production;
	}

	var hasRequiredScheduler;

	function requireScheduler () {
		if (hasRequiredScheduler) return scheduler.exports;
		hasRequiredScheduler = 1;

		{
		  scheduler.exports = requireScheduler_production();
		}
		return scheduler.exports;
	}

	var reactDom = {exports: {}};

	var reactDom_production = {};

	/**
	 * @license React
	 * react-dom.production.js
	 *
	 * Copyright (c) Meta Platforms, Inc. and affiliates.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */

	var hasRequiredReactDom_production;

	function requireReactDom_production () {
		if (hasRequiredReactDom_production) return reactDom_production;
		hasRequiredReactDom_production = 1;
		var React = requireReact();
		function formatProdErrorMessage(code) {
		  var url = "https://react.dev/errors/" + code;
		  if (1 < arguments.length) {
		    url += "?args[]=" + encodeURIComponent(arguments[1]);
		    for (var i = 2; i < arguments.length; i++)
		      url += "&args[]=" + encodeURIComponent(arguments[i]);
		  }
		  return (
		    "Minified React error #" +
		    code +
		    "; visit " +
		    url +
		    " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
		  );
		}
		function noop() {}
		var Internals = {
		    d: {
		      f: noop,
		      r: function () {
		        throw Error(formatProdErrorMessage(522));
		      },
		      D: noop,
		      C: noop,
		      L: noop,
		      m: noop,
		      X: noop,
		      S: noop,
		      M: noop
		    },
		    p: 0,
		    findDOMNode: null
		  },
		  REACT_PORTAL_TYPE = Symbol.for("react.portal");
		function createPortal$1(children, containerInfo, implementation) {
		  var key =
		    3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
		  return {
		    $$typeof: REACT_PORTAL_TYPE,
		    key: null == key ? null : "" + key,
		    children: children,
		    containerInfo: containerInfo,
		    implementation: implementation
		  };
		}
		var ReactSharedInternals =
		  React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
		function getCrossOriginStringAs(as, input) {
		  if ("font" === as) return "";
		  if ("string" === typeof input)
		    return "use-credentials" === input ? input : "";
		}
		reactDom_production.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE =
		  Internals;
		reactDom_production.createPortal = function (children, container) {
		  var key =
		    2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
		  if (
		    !container ||
		    (1 !== container.nodeType &&
		      9 !== container.nodeType &&
		      11 !== container.nodeType)
		  )
		    throw Error(formatProdErrorMessage(299));
		  return createPortal$1(children, container, null, key);
		};
		reactDom_production.flushSync = function (fn) {
		  var previousTransition = ReactSharedInternals.T,
		    previousUpdatePriority = Internals.p;
		  try {
		    if (((ReactSharedInternals.T = null), (Internals.p = 2), fn)) return fn();
		  } finally {
		    (ReactSharedInternals.T = previousTransition),
		      (Internals.p = previousUpdatePriority),
		      Internals.d.f();
		  }
		};
		reactDom_production.preconnect = function (href, options) {
		  "string" === typeof href &&
		    (options
		      ? ((options = options.crossOrigin),
		        (options =
		          "string" === typeof options
		            ? "use-credentials" === options
		              ? options
		              : ""
		            : void 0))
		      : (options = null),
		    Internals.d.C(href, options));
		};
		reactDom_production.prefetchDNS = function (href) {
		  "string" === typeof href && Internals.d.D(href);
		};
		reactDom_production.preinit = function (href, options) {
		  if ("string" === typeof href && options && "string" === typeof options.as) {
		    var as = options.as,
		      crossOrigin = getCrossOriginStringAs(as, options.crossOrigin),
		      integrity =
		        "string" === typeof options.integrity ? options.integrity : void 0,
		      fetchPriority =
		        "string" === typeof options.fetchPriority
		          ? options.fetchPriority
		          : void 0;
		    "style" === as
		      ? Internals.d.S(
		          href,
		          "string" === typeof options.precedence ? options.precedence : void 0,
		          {
		            crossOrigin: crossOrigin,
		            integrity: integrity,
		            fetchPriority: fetchPriority
		          }
		        )
		      : "script" === as &&
		        Internals.d.X(href, {
		          crossOrigin: crossOrigin,
		          integrity: integrity,
		          fetchPriority: fetchPriority,
		          nonce: "string" === typeof options.nonce ? options.nonce : void 0
		        });
		  }
		};
		reactDom_production.preinitModule = function (href, options) {
		  if ("string" === typeof href)
		    if ("object" === typeof options && null !== options) {
		      if (null == options.as || "script" === options.as) {
		        var crossOrigin = getCrossOriginStringAs(
		          options.as,
		          options.crossOrigin
		        );
		        Internals.d.M(href, {
		          crossOrigin: crossOrigin,
		          integrity:
		            "string" === typeof options.integrity ? options.integrity : void 0,
		          nonce: "string" === typeof options.nonce ? options.nonce : void 0
		        });
		      }
		    } else null == options && Internals.d.M(href);
		};
		reactDom_production.preload = function (href, options) {
		  if (
		    "string" === typeof href &&
		    "object" === typeof options &&
		    null !== options &&
		    "string" === typeof options.as
		  ) {
		    var as = options.as,
		      crossOrigin = getCrossOriginStringAs(as, options.crossOrigin);
		    Internals.d.L(href, as, {
		      crossOrigin: crossOrigin,
		      integrity:
		        "string" === typeof options.integrity ? options.integrity : void 0,
		      nonce: "string" === typeof options.nonce ? options.nonce : void 0,
		      type: "string" === typeof options.type ? options.type : void 0,
		      fetchPriority:
		        "string" === typeof options.fetchPriority
		          ? options.fetchPriority
		          : void 0,
		      referrerPolicy:
		        "string" === typeof options.referrerPolicy
		          ? options.referrerPolicy
		          : void 0,
		      imageSrcSet:
		        "string" === typeof options.imageSrcSet ? options.imageSrcSet : void 0,
		      imageSizes:
		        "string" === typeof options.imageSizes ? options.imageSizes : void 0,
		      media: "string" === typeof options.media ? options.media : void 0
		    });
		  }
		};
		reactDom_production.preloadModule = function (href, options) {
		  if ("string" === typeof href)
		    if (options) {
		      var crossOrigin = getCrossOriginStringAs(options.as, options.crossOrigin);
		      Internals.d.m(href, {
		        as:
		          "string" === typeof options.as && "script" !== options.as
		            ? options.as
		            : void 0,
		        crossOrigin: crossOrigin,
		        integrity:
		          "string" === typeof options.integrity ? options.integrity : void 0
		      });
		    } else Internals.d.m(href);
		};
		reactDom_production.requestFormReset = function (form) {
		  Internals.d.r(form);
		};
		reactDom_production.unstable_batchedUpdates = function (fn, a) {
		  return fn(a);
		};
		reactDom_production.useFormState = function (action, initialState, permalink) {
		  return ReactSharedInternals.H.useFormState(action, initialState, permalink);
		};
		reactDom_production.useFormStatus = function () {
		  return ReactSharedInternals.H.useHostTransitionStatus();
		};
		reactDom_production.version = "19.1.0";
		return reactDom_production;
	}

	var hasRequiredReactDom;

	function requireReactDom () {
		if (hasRequiredReactDom) return reactDom.exports;
		hasRequiredReactDom = 1;

		function checkDCE() {
		  /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */
		  if (
		    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined' ||
		    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== 'function'
		  ) {
		    return;
		  }
		  try {
		    // Verify that the code above has been dead code eliminated (DCE'd).
		    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
		  } catch (err) {
		    // DevTools shouldn't crash React, no matter what.
		    // We should still report in case we break this code.
		    console.error(err);
		  }
		}

		{
		  // DCE check should happen before ReactDOM bundle executes so that
		  // DevTools can report bad minification during injection.
		  checkDCE();
		  reactDom.exports = requireReactDom_production();
		}
		return reactDom.exports;
	}

	/**
	 * @license React
	 * react-dom-client.production.js
	 *
	 * Copyright (c) Meta Platforms, Inc. and affiliates.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */

	var hasRequiredReactDomClient_production;

	function requireReactDomClient_production () {
		if (hasRequiredReactDomClient_production) return reactDomClient_production;
		hasRequiredReactDomClient_production = 1;
		var Scheduler = requireScheduler(),
		  React = requireReact(),
		  ReactDOM = requireReactDom();
		function formatProdErrorMessage(code) {
		  var url = "https://react.dev/errors/" + code;
		  if (1 < arguments.length) {
		    url += "?args[]=" + encodeURIComponent(arguments[1]);
		    for (var i = 2; i < arguments.length; i++)
		      url += "&args[]=" + encodeURIComponent(arguments[i]);
		  }
		  return (
		    "Minified React error #" +
		    code +
		    "; visit " +
		    url +
		    " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
		  );
		}
		function isValidContainer(node) {
		  return !(
		    !node ||
		    (1 !== node.nodeType && 9 !== node.nodeType && 11 !== node.nodeType)
		  );
		}
		function getNearestMountedFiber(fiber) {
		  var node = fiber,
		    nearestMounted = fiber;
		  if (fiber.alternate) for (; node.return; ) node = node.return;
		  else {
		    fiber = node;
		    do
		      (node = fiber),
		        0 !== (node.flags & 4098) && (nearestMounted = node.return),
		        (fiber = node.return);
		    while (fiber);
		  }
		  return 3 === node.tag ? nearestMounted : null;
		}
		function getSuspenseInstanceFromFiber(fiber) {
		  if (13 === fiber.tag) {
		    var suspenseState = fiber.memoizedState;
		    null === suspenseState &&
		      ((fiber = fiber.alternate),
		      null !== fiber && (suspenseState = fiber.memoizedState));
		    if (null !== suspenseState) return suspenseState.dehydrated;
		  }
		  return null;
		}
		function assertIsMounted(fiber) {
		  if (getNearestMountedFiber(fiber) !== fiber)
		    throw Error(formatProdErrorMessage(188));
		}
		function findCurrentFiberUsingSlowPath(fiber) {
		  var alternate = fiber.alternate;
		  if (!alternate) {
		    alternate = getNearestMountedFiber(fiber);
		    if (null === alternate) throw Error(formatProdErrorMessage(188));
		    return alternate !== fiber ? null : fiber;
		  }
		  for (var a = fiber, b = alternate; ; ) {
		    var parentA = a.return;
		    if (null === parentA) break;
		    var parentB = parentA.alternate;
		    if (null === parentB) {
		      b = parentA.return;
		      if (null !== b) {
		        a = b;
		        continue;
		      }
		      break;
		    }
		    if (parentA.child === parentB.child) {
		      for (parentB = parentA.child; parentB; ) {
		        if (parentB === a) return assertIsMounted(parentA), fiber;
		        if (parentB === b) return assertIsMounted(parentA), alternate;
		        parentB = parentB.sibling;
		      }
		      throw Error(formatProdErrorMessage(188));
		    }
		    if (a.return !== b.return) (a = parentA), (b = parentB);
		    else {
		      for (var didFindChild = false, child$0 = parentA.child; child$0; ) {
		        if (child$0 === a) {
		          didFindChild = true;
		          a = parentA;
		          b = parentB;
		          break;
		        }
		        if (child$0 === b) {
		          didFindChild = true;
		          b = parentA;
		          a = parentB;
		          break;
		        }
		        child$0 = child$0.sibling;
		      }
		      if (!didFindChild) {
		        for (child$0 = parentB.child; child$0; ) {
		          if (child$0 === a) {
		            didFindChild = true;
		            a = parentB;
		            b = parentA;
		            break;
		          }
		          if (child$0 === b) {
		            didFindChild = true;
		            b = parentB;
		            a = parentA;
		            break;
		          }
		          child$0 = child$0.sibling;
		        }
		        if (!didFindChild) throw Error(formatProdErrorMessage(189));
		      }
		    }
		    if (a.alternate !== b) throw Error(formatProdErrorMessage(190));
		  }
		  if (3 !== a.tag) throw Error(formatProdErrorMessage(188));
		  return a.stateNode.current === a ? fiber : alternate;
		}
		function findCurrentHostFiberImpl(node) {
		  var tag = node.tag;
		  if (5 === tag || 26 === tag || 27 === tag || 6 === tag) return node;
		  for (node = node.child; null !== node; ) {
		    tag = findCurrentHostFiberImpl(node);
		    if (null !== tag) return tag;
		    node = node.sibling;
		  }
		  return null;
		}
		var assign = Object.assign,
		  REACT_LEGACY_ELEMENT_TYPE = Symbol.for("react.element"),
		  REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"),
		  REACT_PORTAL_TYPE = Symbol.for("react.portal"),
		  REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"),
		  REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"),
		  REACT_PROFILER_TYPE = Symbol.for("react.profiler"),
		  REACT_PROVIDER_TYPE = Symbol.for("react.provider"),
		  REACT_CONSUMER_TYPE = Symbol.for("react.consumer"),
		  REACT_CONTEXT_TYPE = Symbol.for("react.context"),
		  REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"),
		  REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"),
		  REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"),
		  REACT_MEMO_TYPE = Symbol.for("react.memo"),
		  REACT_LAZY_TYPE = Symbol.for("react.lazy");
		var REACT_ACTIVITY_TYPE = Symbol.for("react.activity");
		var REACT_MEMO_CACHE_SENTINEL = Symbol.for("react.memo_cache_sentinel");
		var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
		function getIteratorFn(maybeIterable) {
		  if (null === maybeIterable || "object" !== typeof maybeIterable) return null;
		  maybeIterable =
		    (MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL]) ||
		    maybeIterable["@@iterator"];
		  return "function" === typeof maybeIterable ? maybeIterable : null;
		}
		var REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference");
		function getComponentNameFromType(type) {
		  if (null == type) return null;
		  if ("function" === typeof type)
		    return type.$$typeof === REACT_CLIENT_REFERENCE
		      ? null
		      : type.displayName || type.name || null;
		  if ("string" === typeof type) return type;
		  switch (type) {
		    case REACT_FRAGMENT_TYPE:
		      return "Fragment";
		    case REACT_PROFILER_TYPE:
		      return "Profiler";
		    case REACT_STRICT_MODE_TYPE:
		      return "StrictMode";
		    case REACT_SUSPENSE_TYPE:
		      return "Suspense";
		    case REACT_SUSPENSE_LIST_TYPE:
		      return "SuspenseList";
		    case REACT_ACTIVITY_TYPE:
		      return "Activity";
		  }
		  if ("object" === typeof type)
		    switch (type.$$typeof) {
		      case REACT_PORTAL_TYPE:
		        return "Portal";
		      case REACT_CONTEXT_TYPE:
		        return (type.displayName || "Context") + ".Provider";
		      case REACT_CONSUMER_TYPE:
		        return (type._context.displayName || "Context") + ".Consumer";
		      case REACT_FORWARD_REF_TYPE:
		        var innerType = type.render;
		        type = type.displayName;
		        type ||
		          ((type = innerType.displayName || innerType.name || ""),
		          (type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef"));
		        return type;
		      case REACT_MEMO_TYPE:
		        return (
		          (innerType = type.displayName || null),
		          null !== innerType
		            ? innerType
		            : getComponentNameFromType(type.type) || "Memo"
		        );
		      case REACT_LAZY_TYPE:
		        innerType = type._payload;
		        type = type._init;
		        try {
		          return getComponentNameFromType(type(innerType));
		        } catch (x) {}
		    }
		  return null;
		}
		var isArrayImpl = Array.isArray,
		  ReactSharedInternals =
		    React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,
		  ReactDOMSharedInternals =
		    ReactDOM.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,
		  sharedNotPendingObject = {
		    pending: false,
		    data: null,
		    method: null,
		    action: null
		  },
		  valueStack = [],
		  index = -1;
		function createCursor(defaultValue) {
		  return { current: defaultValue };
		}
		function pop(cursor) {
		  0 > index ||
		    ((cursor.current = valueStack[index]), (valueStack[index] = null), index--);
		}
		function push(cursor, value) {
		  index++;
		  valueStack[index] = cursor.current;
		  cursor.current = value;
		}
		var contextStackCursor = createCursor(null),
		  contextFiberStackCursor = createCursor(null),
		  rootInstanceStackCursor = createCursor(null),
		  hostTransitionProviderCursor = createCursor(null);
		function pushHostContainer(fiber, nextRootInstance) {
		  push(rootInstanceStackCursor, nextRootInstance);
		  push(contextFiberStackCursor, fiber);
		  push(contextStackCursor, null);
		  switch (nextRootInstance.nodeType) {
		    case 9:
		    case 11:
		      fiber = (fiber = nextRootInstance.documentElement)
		        ? (fiber = fiber.namespaceURI)
		          ? getOwnHostContext(fiber)
		          : 0
		        : 0;
		      break;
		    default:
		      if (
		        ((fiber = nextRootInstance.tagName),
		        (nextRootInstance = nextRootInstance.namespaceURI))
		      )
		        (nextRootInstance = getOwnHostContext(nextRootInstance)),
		          (fiber = getChildHostContextProd(nextRootInstance, fiber));
		      else
		        switch (fiber) {
		          case "svg":
		            fiber = 1;
		            break;
		          case "math":
		            fiber = 2;
		            break;
		          default:
		            fiber = 0;
		        }
		  }
		  pop(contextStackCursor);
		  push(contextStackCursor, fiber);
		}
		function popHostContainer() {
		  pop(contextStackCursor);
		  pop(contextFiberStackCursor);
		  pop(rootInstanceStackCursor);
		}
		function pushHostContext(fiber) {
		  null !== fiber.memoizedState && push(hostTransitionProviderCursor, fiber);
		  var context = contextStackCursor.current;
		  var JSCompiler_inline_result = getChildHostContextProd(context, fiber.type);
		  context !== JSCompiler_inline_result &&
		    (push(contextFiberStackCursor, fiber),
		    push(contextStackCursor, JSCompiler_inline_result));
		}
		function popHostContext(fiber) {
		  contextFiberStackCursor.current === fiber &&
		    (pop(contextStackCursor), pop(contextFiberStackCursor));
		  hostTransitionProviderCursor.current === fiber &&
		    (pop(hostTransitionProviderCursor),
		    (HostTransitionContext._currentValue = sharedNotPendingObject));
		}
		var hasOwnProperty = Object.prototype.hasOwnProperty,
		  scheduleCallback$3 = Scheduler.unstable_scheduleCallback,
		  cancelCallback$1 = Scheduler.unstable_cancelCallback,
		  shouldYield = Scheduler.unstable_shouldYield,
		  requestPaint = Scheduler.unstable_requestPaint,
		  now = Scheduler.unstable_now,
		  getCurrentPriorityLevel = Scheduler.unstable_getCurrentPriorityLevel,
		  ImmediatePriority = Scheduler.unstable_ImmediatePriority,
		  UserBlockingPriority = Scheduler.unstable_UserBlockingPriority,
		  NormalPriority$1 = Scheduler.unstable_NormalPriority,
		  LowPriority = Scheduler.unstable_LowPriority,
		  IdlePriority = Scheduler.unstable_IdlePriority,
		  log$1 = Scheduler.log,
		  unstable_setDisableYieldValue = Scheduler.unstable_setDisableYieldValue,
		  rendererID = null,
		  injectedHook = null;
		function setIsStrictModeForDevtools(newIsStrictMode) {
		  "function" === typeof log$1 && unstable_setDisableYieldValue(newIsStrictMode);
		  if (injectedHook && "function" === typeof injectedHook.setStrictMode)
		    try {
		      injectedHook.setStrictMode(rendererID, newIsStrictMode);
		    } catch (err) {}
		}
		var clz32 = Math.clz32 ? Math.clz32 : clz32Fallback,
		  log = Math.log,
		  LN2 = Math.LN2;
		function clz32Fallback(x) {
		  x >>>= 0;
		  return 0 === x ? 32 : (31 - ((log(x) / LN2) | 0)) | 0;
		}
		var nextTransitionLane = 256,
		  nextRetryLane = 4194304;
		function getHighestPriorityLanes(lanes) {
		  var pendingSyncLanes = lanes & 42;
		  if (0 !== pendingSyncLanes) return pendingSyncLanes;
		  switch (lanes & -lanes) {
		    case 1:
		      return 1;
		    case 2:
		      return 2;
		    case 4:
		      return 4;
		    case 8:
		      return 8;
		    case 16:
		      return 16;
		    case 32:
		      return 32;
		    case 64:
		      return 64;
		    case 128:
		      return 128;
		    case 256:
		    case 512:
		    case 1024:
		    case 2048:
		    case 4096:
		    case 8192:
		    case 16384:
		    case 32768:
		    case 65536:
		    case 131072:
		    case 262144:
		    case 524288:
		    case 1048576:
		    case 2097152:
		      return lanes & 4194048;
		    case 4194304:
		    case 8388608:
		    case 16777216:
		    case 33554432:
		      return lanes & 62914560;
		    case 67108864:
		      return 67108864;
		    case 134217728:
		      return 134217728;
		    case 268435456:
		      return 268435456;
		    case 536870912:
		      return 536870912;
		    case 1073741824:
		      return 0;
		    default:
		      return lanes;
		  }
		}
		function getNextLanes(root, wipLanes, rootHasPendingCommit) {
		  var pendingLanes = root.pendingLanes;
		  if (0 === pendingLanes) return 0;
		  var nextLanes = 0,
		    suspendedLanes = root.suspendedLanes,
		    pingedLanes = root.pingedLanes;
		  root = root.warmLanes;
		  var nonIdlePendingLanes = pendingLanes & 134217727;
		  0 !== nonIdlePendingLanes
		    ? ((pendingLanes = nonIdlePendingLanes & ~suspendedLanes),
		      0 !== pendingLanes
		        ? (nextLanes = getHighestPriorityLanes(pendingLanes))
		        : ((pingedLanes &= nonIdlePendingLanes),
		          0 !== pingedLanes
		            ? (nextLanes = getHighestPriorityLanes(pingedLanes))
		            : rootHasPendingCommit ||
		              ((rootHasPendingCommit = nonIdlePendingLanes & ~root),
		              0 !== rootHasPendingCommit &&
		                (nextLanes = getHighestPriorityLanes(rootHasPendingCommit)))))
		    : ((nonIdlePendingLanes = pendingLanes & ~suspendedLanes),
		      0 !== nonIdlePendingLanes
		        ? (nextLanes = getHighestPriorityLanes(nonIdlePendingLanes))
		        : 0 !== pingedLanes
		          ? (nextLanes = getHighestPriorityLanes(pingedLanes))
		          : rootHasPendingCommit ||
		            ((rootHasPendingCommit = pendingLanes & ~root),
		            0 !== rootHasPendingCommit &&
		              (nextLanes = getHighestPriorityLanes(rootHasPendingCommit))));
		  return 0 === nextLanes
		    ? 0
		    : 0 !== wipLanes &&
		        wipLanes !== nextLanes &&
		        0 === (wipLanes & suspendedLanes) &&
		        ((suspendedLanes = nextLanes & -nextLanes),
		        (rootHasPendingCommit = wipLanes & -wipLanes),
		        suspendedLanes >= rootHasPendingCommit ||
		          (32 === suspendedLanes && 0 !== (rootHasPendingCommit & 4194048)))
		      ? wipLanes
		      : nextLanes;
		}
		function checkIfRootIsPrerendering(root, renderLanes) {
		  return (
		    0 ===
		    (root.pendingLanes &
		      ~(root.suspendedLanes & ~root.pingedLanes) &
		      renderLanes)
		  );
		}
		function computeExpirationTime(lane, currentTime) {
		  switch (lane) {
		    case 1:
		    case 2:
		    case 4:
		    case 8:
		    case 64:
		      return currentTime + 250;
		    case 16:
		    case 32:
		    case 128:
		    case 256:
		    case 512:
		    case 1024:
		    case 2048:
		    case 4096:
		    case 8192:
		    case 16384:
		    case 32768:
		    case 65536:
		    case 131072:
		    case 262144:
		    case 524288:
		    case 1048576:
		    case 2097152:
		      return currentTime + 5e3;
		    case 4194304:
		    case 8388608:
		    case 16777216:
		    case 33554432:
		      return -1;
		    case 67108864:
		    case 134217728:
		    case 268435456:
		    case 536870912:
		    case 1073741824:
		      return -1;
		    default:
		      return -1;
		  }
		}
		function claimNextTransitionLane() {
		  var lane = nextTransitionLane;
		  nextTransitionLane <<= 1;
		  0 === (nextTransitionLane & 4194048) && (nextTransitionLane = 256);
		  return lane;
		}
		function claimNextRetryLane() {
		  var lane = nextRetryLane;
		  nextRetryLane <<= 1;
		  0 === (nextRetryLane & 62914560) && (nextRetryLane = 4194304);
		  return lane;
		}
		function createLaneMap(initial) {
		  for (var laneMap = [], i = 0; 31 > i; i++) laneMap.push(initial);
		  return laneMap;
		}
		function markRootUpdated$1(root, updateLane) {
		  root.pendingLanes |= updateLane;
		  268435456 !== updateLane &&
		    ((root.suspendedLanes = 0), (root.pingedLanes = 0), (root.warmLanes = 0));
		}
		function markRootFinished(
		  root,
		  finishedLanes,
		  remainingLanes,
		  spawnedLane,
		  updatedLanes,
		  suspendedRetryLanes
		) {
		  var previouslyPendingLanes = root.pendingLanes;
		  root.pendingLanes = remainingLanes;
		  root.suspendedLanes = 0;
		  root.pingedLanes = 0;
		  root.warmLanes = 0;
		  root.expiredLanes &= remainingLanes;
		  root.entangledLanes &= remainingLanes;
		  root.errorRecoveryDisabledLanes &= remainingLanes;
		  root.shellSuspendCounter = 0;
		  var entanglements = root.entanglements,
		    expirationTimes = root.expirationTimes,
		    hiddenUpdates = root.hiddenUpdates;
		  for (
		    remainingLanes = previouslyPendingLanes & ~remainingLanes;
		    0 < remainingLanes;

		  ) {
		    var index$5 = 31 - clz32(remainingLanes),
		      lane = 1 << index$5;
		    entanglements[index$5] = 0;
		    expirationTimes[index$5] = -1;
		    var hiddenUpdatesForLane = hiddenUpdates[index$5];
		    if (null !== hiddenUpdatesForLane)
		      for (
		        hiddenUpdates[index$5] = null, index$5 = 0;
		        index$5 < hiddenUpdatesForLane.length;
		        index$5++
		      ) {
		        var update = hiddenUpdatesForLane[index$5];
		        null !== update && (update.lane &= -536870913);
		      }
		    remainingLanes &= ~lane;
		  }
		  0 !== spawnedLane && markSpawnedDeferredLane(root, spawnedLane, 0);
		  0 !== suspendedRetryLanes &&
		    0 === updatedLanes &&
		    0 !== root.tag &&
		    (root.suspendedLanes |=
		      suspendedRetryLanes & ~(previouslyPendingLanes & ~finishedLanes));
		}
		function markSpawnedDeferredLane(root, spawnedLane, entangledLanes) {
		  root.pendingLanes |= spawnedLane;
		  root.suspendedLanes &= ~spawnedLane;
		  var spawnedLaneIndex = 31 - clz32(spawnedLane);
		  root.entangledLanes |= spawnedLane;
		  root.entanglements[spawnedLaneIndex] =
		    root.entanglements[spawnedLaneIndex] |
		    1073741824 |
		    (entangledLanes & 4194090);
		}
		function markRootEntangled(root, entangledLanes) {
		  var rootEntangledLanes = (root.entangledLanes |= entangledLanes);
		  for (root = root.entanglements; rootEntangledLanes; ) {
		    var index$6 = 31 - clz32(rootEntangledLanes),
		      lane = 1 << index$6;
		    (lane & entangledLanes) | (root[index$6] & entangledLanes) &&
		      (root[index$6] |= entangledLanes);
		    rootEntangledLanes &= ~lane;
		  }
		}
		function getBumpedLaneForHydrationByLane(lane) {
		  switch (lane) {
		    case 2:
		      lane = 1;
		      break;
		    case 8:
		      lane = 4;
		      break;
		    case 32:
		      lane = 16;
		      break;
		    case 256:
		    case 512:
		    case 1024:
		    case 2048:
		    case 4096:
		    case 8192:
		    case 16384:
		    case 32768:
		    case 65536:
		    case 131072:
		    case 262144:
		    case 524288:
		    case 1048576:
		    case 2097152:
		    case 4194304:
		    case 8388608:
		    case 16777216:
		    case 33554432:
		      lane = 128;
		      break;
		    case 268435456:
		      lane = 134217728;
		      break;
		    default:
		      lane = 0;
		  }
		  return lane;
		}
		function lanesToEventPriority(lanes) {
		  lanes &= -lanes;
		  return 2 < lanes
		    ? 8 < lanes
		      ? 0 !== (lanes & 134217727)
		        ? 32
		        : 268435456
		      : 8
		    : 2;
		}
		function resolveUpdatePriority() {
		  var updatePriority = ReactDOMSharedInternals.p;
		  if (0 !== updatePriority) return updatePriority;
		  updatePriority = window.event;
		  return void 0 === updatePriority ? 32 : getEventPriority(updatePriority.type);
		}
		function runWithPriority(priority, fn) {
		  var previousPriority = ReactDOMSharedInternals.p;
		  try {
		    return (ReactDOMSharedInternals.p = priority), fn();
		  } finally {
		    ReactDOMSharedInternals.p = previousPriority;
		  }
		}
		var randomKey = Math.random().toString(36).slice(2),
		  internalInstanceKey = "__reactFiber$" + randomKey,
		  internalPropsKey = "__reactProps$" + randomKey,
		  internalContainerInstanceKey = "__reactContainer$" + randomKey,
		  internalEventHandlersKey = "__reactEvents$" + randomKey,
		  internalEventHandlerListenersKey = "__reactListeners$" + randomKey,
		  internalEventHandlesSetKey = "__reactHandles$" + randomKey,
		  internalRootNodeResourcesKey = "__reactResources$" + randomKey,
		  internalHoistableMarker = "__reactMarker$" + randomKey;
		function detachDeletedInstance(node) {
		  delete node[internalInstanceKey];
		  delete node[internalPropsKey];
		  delete node[internalEventHandlersKey];
		  delete node[internalEventHandlerListenersKey];
		  delete node[internalEventHandlesSetKey];
		}
		function getClosestInstanceFromNode(targetNode) {
		  var targetInst = targetNode[internalInstanceKey];
		  if (targetInst) return targetInst;
		  for (var parentNode = targetNode.parentNode; parentNode; ) {
		    if (
		      (targetInst =
		        parentNode[internalContainerInstanceKey] ||
		        parentNode[internalInstanceKey])
		    ) {
		      parentNode = targetInst.alternate;
		      if (
		        null !== targetInst.child ||
		        (null !== parentNode && null !== parentNode.child)
		      )
		        for (
		          targetNode = getParentSuspenseInstance(targetNode);
		          null !== targetNode;

		        ) {
		          if ((parentNode = targetNode[internalInstanceKey])) return parentNode;
		          targetNode = getParentSuspenseInstance(targetNode);
		        }
		      return targetInst;
		    }
		    targetNode = parentNode;
		    parentNode = targetNode.parentNode;
		  }
		  return null;
		}
		function getInstanceFromNode(node) {
		  if (
		    (node = node[internalInstanceKey] || node[internalContainerInstanceKey])
		  ) {
		    var tag = node.tag;
		    if (
		      5 === tag ||
		      6 === tag ||
		      13 === tag ||
		      26 === tag ||
		      27 === tag ||
		      3 === tag
		    )
		      return node;
		  }
		  return null;
		}
		function getNodeFromInstance(inst) {
		  var tag = inst.tag;
		  if (5 === tag || 26 === tag || 27 === tag || 6 === tag) return inst.stateNode;
		  throw Error(formatProdErrorMessage(33));
		}
		function getResourcesFromRoot(root) {
		  var resources = root[internalRootNodeResourcesKey];
		  resources ||
		    (resources = root[internalRootNodeResourcesKey] =
		      { hoistableStyles: new Map(), hoistableScripts: new Map() });
		  return resources;
		}
		function markNodeAsHoistable(node) {
		  node[internalHoistableMarker] = true;
		}
		var allNativeEvents = new Set(),
		  registrationNameDependencies = {};
		function registerTwoPhaseEvent(registrationName, dependencies) {
		  registerDirectEvent(registrationName, dependencies);
		  registerDirectEvent(registrationName + "Capture", dependencies);
		}
		function registerDirectEvent(registrationName, dependencies) {
		  registrationNameDependencies[registrationName] = dependencies;
		  for (
		    registrationName = 0;
		    registrationName < dependencies.length;
		    registrationName++
		  )
		    allNativeEvents.add(dependencies[registrationName]);
		}
		var VALID_ATTRIBUTE_NAME_REGEX = RegExp(
		    "^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
		  ),
		  illegalAttributeNameCache = {},
		  validatedAttributeNameCache = {};
		function isAttributeNameSafe(attributeName) {
		  if (hasOwnProperty.call(validatedAttributeNameCache, attributeName))
		    return true;
		  if (hasOwnProperty.call(illegalAttributeNameCache, attributeName)) return false;
		  if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName))
		    return (validatedAttributeNameCache[attributeName] = true);
		  illegalAttributeNameCache[attributeName] = true;
		  return false;
		}
		function setValueForAttribute(node, name, value) {
		  if (isAttributeNameSafe(name))
		    if (null === value) node.removeAttribute(name);
		    else {
		      switch (typeof value) {
		        case "undefined":
		        case "function":
		        case "symbol":
		          node.removeAttribute(name);
		          return;
		        case "boolean":
		          var prefix$8 = name.toLowerCase().slice(0, 5);
		          if ("data-" !== prefix$8 && "aria-" !== prefix$8) {
		            node.removeAttribute(name);
		            return;
		          }
		      }
		      node.setAttribute(name, "" + value);
		    }
		}
		function setValueForKnownAttribute(node, name, value) {
		  if (null === value) node.removeAttribute(name);
		  else {
		    switch (typeof value) {
		      case "undefined":
		      case "function":
		      case "symbol":
		      case "boolean":
		        node.removeAttribute(name);
		        return;
		    }
		    node.setAttribute(name, "" + value);
		  }
		}
		function setValueForNamespacedAttribute(node, namespace, name, value) {
		  if (null === value) node.removeAttribute(name);
		  else {
		    switch (typeof value) {
		      case "undefined":
		      case "function":
		      case "symbol":
		      case "boolean":
		        node.removeAttribute(name);
		        return;
		    }
		    node.setAttributeNS(namespace, name, "" + value);
		  }
		}
		var prefix, suffix;
		function describeBuiltInComponentFrame(name) {
		  if (void 0 === prefix)
		    try {
		      throw Error();
		    } catch (x) {
		      var match = x.stack.trim().match(/\n( *(at )?)/);
		      prefix = (match && match[1]) || "";
		      suffix =
		        -1 < x.stack.indexOf("\n    at")
		          ? " (<anonymous>)"
		          : -1 < x.stack.indexOf("@")
		            ? "@unknown:0:0"
		            : "";
		    }
		  return "\n" + prefix + name + suffix;
		}
		var reentry = false;
		function describeNativeComponentFrame(fn, construct) {
		  if (!fn || reentry) return "";
		  reentry = true;
		  var previousPrepareStackTrace = Error.prepareStackTrace;
		  Error.prepareStackTrace = void 0;
		  try {
		    var RunInRootFrame = {
		      DetermineComponentFrameRoot: function () {
		        try {
		          if (construct) {
		            var Fake = function () {
		              throw Error();
		            };
		            Object.defineProperty(Fake.prototype, "props", {
		              set: function () {
		                throw Error();
		              }
		            });
		            if ("object" === typeof Reflect && Reflect.construct) {
		              try {
		                Reflect.construct(Fake, []);
		              } catch (x) {
		                var control = x;
		              }
		              Reflect.construct(fn, [], Fake);
		            } else {
		              try {
		                Fake.call();
		              } catch (x$9) {
		                control = x$9;
		              }
		              fn.call(Fake.prototype);
		            }
		          } else {
		            try {
		              throw Error();
		            } catch (x$10) {
		              control = x$10;
		            }
		            (Fake = fn()) &&
		              "function" === typeof Fake.catch &&
		              Fake.catch(function () {});
		          }
		        } catch (sample) {
		          if (sample && control && "string" === typeof sample.stack)
		            return [sample.stack, control.stack];
		        }
		        return [null, null];
		      }
		    };
		    RunInRootFrame.DetermineComponentFrameRoot.displayName =
		      "DetermineComponentFrameRoot";
		    var namePropDescriptor = Object.getOwnPropertyDescriptor(
		      RunInRootFrame.DetermineComponentFrameRoot,
		      "name"
		    );
		    namePropDescriptor &&
		      namePropDescriptor.configurable &&
		      Object.defineProperty(
		        RunInRootFrame.DetermineComponentFrameRoot,
		        "name",
		        { value: "DetermineComponentFrameRoot" }
		      );
		    var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(),
		      sampleStack = _RunInRootFrame$Deter[0],
		      controlStack = _RunInRootFrame$Deter[1];
		    if (sampleStack && controlStack) {
		      var sampleLines = sampleStack.split("\n"),
		        controlLines = controlStack.split("\n");
		      for (
		        namePropDescriptor = RunInRootFrame = 0;
		        RunInRootFrame < sampleLines.length &&
		        !sampleLines[RunInRootFrame].includes("DetermineComponentFrameRoot");

		      )
		        RunInRootFrame++;
		      for (
		        ;
		        namePropDescriptor < controlLines.length &&
		        !controlLines[namePropDescriptor].includes(
		          "DetermineComponentFrameRoot"
		        );

		      )
		        namePropDescriptor++;
		      if (
		        RunInRootFrame === sampleLines.length ||
		        namePropDescriptor === controlLines.length
		      )
		        for (
		          RunInRootFrame = sampleLines.length - 1,
		            namePropDescriptor = controlLines.length - 1;
		          1 <= RunInRootFrame &&
		          0 <= namePropDescriptor &&
		          sampleLines[RunInRootFrame] !== controlLines[namePropDescriptor];

		        )
		          namePropDescriptor--;
		      for (
		        ;
		        1 <= RunInRootFrame && 0 <= namePropDescriptor;
		        RunInRootFrame--, namePropDescriptor--
		      )
		        if (sampleLines[RunInRootFrame] !== controlLines[namePropDescriptor]) {
		          if (1 !== RunInRootFrame || 1 !== namePropDescriptor) {
		            do
		              if (
		                (RunInRootFrame--,
		                namePropDescriptor--,
		                0 > namePropDescriptor ||
		                  sampleLines[RunInRootFrame] !==
		                    controlLines[namePropDescriptor])
		              ) {
		                var frame =
		                  "\n" +
		                  sampleLines[RunInRootFrame].replace(" at new ", " at ");
		                fn.displayName &&
		                  frame.includes("<anonymous>") &&
		                  (frame = frame.replace("<anonymous>", fn.displayName));
		                return frame;
		              }
		            while (1 <= RunInRootFrame && 0 <= namePropDescriptor);
		          }
		          break;
		        }
		    }
		  } finally {
		    (reentry = false), (Error.prepareStackTrace = previousPrepareStackTrace);
		  }
		  return (previousPrepareStackTrace = fn ? fn.displayName || fn.name : "")
		    ? describeBuiltInComponentFrame(previousPrepareStackTrace)
		    : "";
		}
		function describeFiber(fiber) {
		  switch (fiber.tag) {
		    case 26:
		    case 27:
		    case 5:
		      return describeBuiltInComponentFrame(fiber.type);
		    case 16:
		      return describeBuiltInComponentFrame("Lazy");
		    case 13:
		      return describeBuiltInComponentFrame("Suspense");
		    case 19:
		      return describeBuiltInComponentFrame("SuspenseList");
		    case 0:
		    case 15:
		      return describeNativeComponentFrame(fiber.type, false);
		    case 11:
		      return describeNativeComponentFrame(fiber.type.render, false);
		    case 1:
		      return describeNativeComponentFrame(fiber.type, true);
		    case 31:
		      return describeBuiltInComponentFrame("Activity");
		    default:
		      return "";
		  }
		}
		function getStackByFiberInDevAndProd(workInProgress) {
		  try {
		    var info = "";
		    do
		      (info += describeFiber(workInProgress)),
		        (workInProgress = workInProgress.return);
		    while (workInProgress);
		    return info;
		  } catch (x) {
		    return "\nError generating stack: " + x.message + "\n" + x.stack;
		  }
		}
		function getToStringValue(value) {
		  switch (typeof value) {
		    case "bigint":
		    case "boolean":
		    case "number":
		    case "string":
		    case "undefined":
		      return value;
		    case "object":
		      return value;
		    default:
		      return "";
		  }
		}
		function isCheckable(elem) {
		  var type = elem.type;
		  return (
		    (elem = elem.nodeName) &&
		    "input" === elem.toLowerCase() &&
		    ("checkbox" === type || "radio" === type)
		  );
		}
		function trackValueOnNode(node) {
		  var valueField = isCheckable(node) ? "checked" : "value",
		    descriptor = Object.getOwnPropertyDescriptor(
		      node.constructor.prototype,
		      valueField
		    ),
		    currentValue = "" + node[valueField];
		  if (
		    !node.hasOwnProperty(valueField) &&
		    "undefined" !== typeof descriptor &&
		    "function" === typeof descriptor.get &&
		    "function" === typeof descriptor.set
		  ) {
		    var get = descriptor.get,
		      set = descriptor.set;
		    Object.defineProperty(node, valueField, {
		      configurable: true,
		      get: function () {
		        return get.call(this);
		      },
		      set: function (value) {
		        currentValue = "" + value;
		        set.call(this, value);
		      }
		    });
		    Object.defineProperty(node, valueField, {
		      enumerable: descriptor.enumerable
		    });
		    return {
		      getValue: function () {
		        return currentValue;
		      },
		      setValue: function (value) {
		        currentValue = "" + value;
		      },
		      stopTracking: function () {
		        node._valueTracker = null;
		        delete node[valueField];
		      }
		    };
		  }
		}
		function track(node) {
		  node._valueTracker || (node._valueTracker = trackValueOnNode(node));
		}
		function updateValueIfChanged(node) {
		  if (!node) return false;
		  var tracker = node._valueTracker;
		  if (!tracker) return true;
		  var lastValue = tracker.getValue();
		  var value = "";
		  node &&
		    (value = isCheckable(node)
		      ? node.checked
		        ? "true"
		        : "false"
		      : node.value);
		  node = value;
		  return node !== lastValue ? (tracker.setValue(node), true) : false;
		}
		function getActiveElement(doc) {
		  doc = doc || ("undefined" !== typeof document ? document : void 0);
		  if ("undefined" === typeof doc) return null;
		  try {
		    return doc.activeElement || doc.body;
		  } catch (e) {
		    return doc.body;
		  }
		}
		var escapeSelectorAttributeValueInsideDoubleQuotesRegex = /[\n"\\]/g;
		function escapeSelectorAttributeValueInsideDoubleQuotes(value) {
		  return value.replace(
		    escapeSelectorAttributeValueInsideDoubleQuotesRegex,
		    function (ch) {
		      return "\\" + ch.charCodeAt(0).toString(16) + " ";
		    }
		  );
		}
		function updateInput(
		  element,
		  value,
		  defaultValue,
		  lastDefaultValue,
		  checked,
		  defaultChecked,
		  type,
		  name
		) {
		  element.name = "";
		  null != type &&
		  "function" !== typeof type &&
		  "symbol" !== typeof type &&
		  "boolean" !== typeof type
		    ? (element.type = type)
		    : element.removeAttribute("type");
		  if (null != value)
		    if ("number" === type) {
		      if ((0 === value && "" === element.value) || element.value != value)
		        element.value = "" + getToStringValue(value);
		    } else
		      element.value !== "" + getToStringValue(value) &&
		        (element.value = "" + getToStringValue(value));
		  else
		    ("submit" !== type && "reset" !== type) || element.removeAttribute("value");
		  null != value
		    ? setDefaultValue(element, type, getToStringValue(value))
		    : null != defaultValue
		      ? setDefaultValue(element, type, getToStringValue(defaultValue))
		      : null != lastDefaultValue && element.removeAttribute("value");
		  null == checked &&
		    null != defaultChecked &&
		    (element.defaultChecked = !!defaultChecked);
		  null != checked &&
		    (element.checked =
		      checked && "function" !== typeof checked && "symbol" !== typeof checked);
		  null != name &&
		  "function" !== typeof name &&
		  "symbol" !== typeof name &&
		  "boolean" !== typeof name
		    ? (element.name = "" + getToStringValue(name))
		    : element.removeAttribute("name");
		}
		function initInput(
		  element,
		  value,
		  defaultValue,
		  checked,
		  defaultChecked,
		  type,
		  name,
		  isHydrating
		) {
		  null != type &&
		    "function" !== typeof type &&
		    "symbol" !== typeof type &&
		    "boolean" !== typeof type &&
		    (element.type = type);
		  if (null != value || null != defaultValue) {
		    if (
		      !(
		        ("submit" !== type && "reset" !== type) ||
		        (void 0 !== value && null !== value)
		      )
		    )
		      return;
		    defaultValue =
		      null != defaultValue ? "" + getToStringValue(defaultValue) : "";
		    value = null != value ? "" + getToStringValue(value) : defaultValue;
		    isHydrating || value === element.value || (element.value = value);
		    element.defaultValue = value;
		  }
		  checked = null != checked ? checked : defaultChecked;
		  checked =
		    "function" !== typeof checked && "symbol" !== typeof checked && !!checked;
		  element.checked = isHydrating ? element.checked : !!checked;
		  element.defaultChecked = !!checked;
		  null != name &&
		    "function" !== typeof name &&
		    "symbol" !== typeof name &&
		    "boolean" !== typeof name &&
		    (element.name = name);
		}
		function setDefaultValue(node, type, value) {
		  ("number" === type && getActiveElement(node.ownerDocument) === node) ||
		    node.defaultValue === "" + value ||
		    (node.defaultValue = "" + value);
		}
		function updateOptions(node, multiple, propValue, setDefaultSelected) {
		  node = node.options;
		  if (multiple) {
		    multiple = {};
		    for (var i = 0; i < propValue.length; i++)
		      multiple["$" + propValue[i]] = true;
		    for (propValue = 0; propValue < node.length; propValue++)
		      (i = multiple.hasOwnProperty("$" + node[propValue].value)),
		        node[propValue].selected !== i && (node[propValue].selected = i),
		        i && setDefaultSelected && (node[propValue].defaultSelected = true);
		  } else {
		    propValue = "" + getToStringValue(propValue);
		    multiple = null;
		    for (i = 0; i < node.length; i++) {
		      if (node[i].value === propValue) {
		        node[i].selected = true;
		        setDefaultSelected && (node[i].defaultSelected = true);
		        return;
		      }
		      null !== multiple || node[i].disabled || (multiple = node[i]);
		    }
		    null !== multiple && (multiple.selected = true);
		  }
		}
		function updateTextarea(element, value, defaultValue) {
		  if (
		    null != value &&
		    ((value = "" + getToStringValue(value)),
		    value !== element.value && (element.value = value),
		    null == defaultValue)
		  ) {
		    element.defaultValue !== value && (element.defaultValue = value);
		    return;
		  }
		  element.defaultValue =
		    null != defaultValue ? "" + getToStringValue(defaultValue) : "";
		}
		function initTextarea(element, value, defaultValue, children) {
		  if (null == value) {
		    if (null != children) {
		      if (null != defaultValue) throw Error(formatProdErrorMessage(92));
		      if (isArrayImpl(children)) {
		        if (1 < children.length) throw Error(formatProdErrorMessage(93));
		        children = children[0];
		      }
		      defaultValue = children;
		    }
		    null == defaultValue && (defaultValue = "");
		    value = defaultValue;
		  }
		  defaultValue = getToStringValue(value);
		  element.defaultValue = defaultValue;
		  children = element.textContent;
		  children === defaultValue &&
		    "" !== children &&
		    null !== children &&
		    (element.value = children);
		}
		function setTextContent(node, text) {
		  if (text) {
		    var firstChild = node.firstChild;
		    if (
		      firstChild &&
		      firstChild === node.lastChild &&
		      3 === firstChild.nodeType
		    ) {
		      firstChild.nodeValue = text;
		      return;
		    }
		  }
		  node.textContent = text;
		}
		var unitlessNumbers = new Set(
		  "animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(
		    " "
		  )
		);
		function setValueForStyle(style, styleName, value) {
		  var isCustomProperty = 0 === styleName.indexOf("--");
		  null == value || "boolean" === typeof value || "" === value
		    ? isCustomProperty
		      ? style.setProperty(styleName, "")
		      : "float" === styleName
		        ? (style.cssFloat = "")
		        : (style[styleName] = "")
		    : isCustomProperty
		      ? style.setProperty(styleName, value)
		      : "number" !== typeof value ||
		          0 === value ||
		          unitlessNumbers.has(styleName)
		        ? "float" === styleName
		          ? (style.cssFloat = value)
		          : (style[styleName] = ("" + value).trim())
		        : (style[styleName] = value + "px");
		}
		function setValueForStyles(node, styles, prevStyles) {
		  if (null != styles && "object" !== typeof styles)
		    throw Error(formatProdErrorMessage(62));
		  node = node.style;
		  if (null != prevStyles) {
		    for (var styleName in prevStyles)
		      !prevStyles.hasOwnProperty(styleName) ||
		        (null != styles && styles.hasOwnProperty(styleName)) ||
		        (0 === styleName.indexOf("--")
		          ? node.setProperty(styleName, "")
		          : "float" === styleName
		            ? (node.cssFloat = "")
		            : (node[styleName] = ""));
		    for (var styleName$16 in styles)
		      (styleName = styles[styleName$16]),
		        styles.hasOwnProperty(styleName$16) &&
		          prevStyles[styleName$16] !== styleName &&
		          setValueForStyle(node, styleName$16, styleName);
		  } else
		    for (var styleName$17 in styles)
		      styles.hasOwnProperty(styleName$17) &&
		        setValueForStyle(node, styleName$17, styles[styleName$17]);
		}
		function isCustomElement(tagName) {
		  if (-1 === tagName.indexOf("-")) return false;
		  switch (tagName) {
		    case "annotation-xml":
		    case "color-profile":
		    case "font-face":
		    case "font-face-src":
		    case "font-face-uri":
		    case "font-face-format":
		    case "font-face-name":
		    case "missing-glyph":
		      return false;
		    default:
		      return true;
		  }
		}
		var aliases = new Map([
		    ["acceptCharset", "accept-charset"],
		    ["htmlFor", "for"],
		    ["httpEquiv", "http-equiv"],
		    ["crossOrigin", "crossorigin"],
		    ["accentHeight", "accent-height"],
		    ["alignmentBaseline", "alignment-baseline"],
		    ["arabicForm", "arabic-form"],
		    ["baselineShift", "baseline-shift"],
		    ["capHeight", "cap-height"],
		    ["clipPath", "clip-path"],
		    ["clipRule", "clip-rule"],
		    ["colorInterpolation", "color-interpolation"],
		    ["colorInterpolationFilters", "color-interpolation-filters"],
		    ["colorProfile", "color-profile"],
		    ["colorRendering", "color-rendering"],
		    ["dominantBaseline", "dominant-baseline"],
		    ["enableBackground", "enable-background"],
		    ["fillOpacity", "fill-opacity"],
		    ["fillRule", "fill-rule"],
		    ["floodColor", "flood-color"],
		    ["floodOpacity", "flood-opacity"],
		    ["fontFamily", "font-family"],
		    ["fontSize", "font-size"],
		    ["fontSizeAdjust", "font-size-adjust"],
		    ["fontStretch", "font-stretch"],
		    ["fontStyle", "font-style"],
		    ["fontVariant", "font-variant"],
		    ["fontWeight", "font-weight"],
		    ["glyphName", "glyph-name"],
		    ["glyphOrientationHorizontal", "glyph-orientation-horizontal"],
		    ["glyphOrientationVertical", "glyph-orientation-vertical"],
		    ["horizAdvX", "horiz-adv-x"],
		    ["horizOriginX", "horiz-origin-x"],
		    ["imageRendering", "image-rendering"],
		    ["letterSpacing", "letter-spacing"],
		    ["lightingColor", "lighting-color"],
		    ["markerEnd", "marker-end"],
		    ["markerMid", "marker-mid"],
		    ["markerStart", "marker-start"],
		    ["overlinePosition", "overline-position"],
		    ["overlineThickness", "overline-thickness"],
		    ["paintOrder", "paint-order"],
		    ["panose-1", "panose-1"],
		    ["pointerEvents", "pointer-events"],
		    ["renderingIntent", "rendering-intent"],
		    ["shapeRendering", "shape-rendering"],
		    ["stopColor", "stop-color"],
		    ["stopOpacity", "stop-opacity"],
		    ["strikethroughPosition", "strikethrough-position"],
		    ["strikethroughThickness", "strikethrough-thickness"],
		    ["strokeDasharray", "stroke-dasharray"],
		    ["strokeDashoffset", "stroke-dashoffset"],
		    ["strokeLinecap", "stroke-linecap"],
		    ["strokeLinejoin", "stroke-linejoin"],
		    ["strokeMiterlimit", "stroke-miterlimit"],
		    ["strokeOpacity", "stroke-opacity"],
		    ["strokeWidth", "stroke-width"],
		    ["textAnchor", "text-anchor"],
		    ["textDecoration", "text-decoration"],
		    ["textRendering", "text-rendering"],
		    ["transformOrigin", "transform-origin"],
		    ["underlinePosition", "underline-position"],
		    ["underlineThickness", "underline-thickness"],
		    ["unicodeBidi", "unicode-bidi"],
		    ["unicodeRange", "unicode-range"],
		    ["unitsPerEm", "units-per-em"],
		    ["vAlphabetic", "v-alphabetic"],
		    ["vHanging", "v-hanging"],
		    ["vIdeographic", "v-ideographic"],
		    ["vMathematical", "v-mathematical"],
		    ["vectorEffect", "vector-effect"],
		    ["vertAdvY", "vert-adv-y"],
		    ["vertOriginX", "vert-origin-x"],
		    ["vertOriginY", "vert-origin-y"],
		    ["wordSpacing", "word-spacing"],
		    ["writingMode", "writing-mode"],
		    ["xmlnsXlink", "xmlns:xlink"],
		    ["xHeight", "x-height"]
		  ]),
		  isJavaScriptProtocol =
		    /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i;
		function sanitizeURL(url) {
		  return isJavaScriptProtocol.test("" + url)
		    ? "javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')"
		    : url;
		}
		var currentReplayingEvent = null;
		function getEventTarget(nativeEvent) {
		  nativeEvent = nativeEvent.target || nativeEvent.srcElement || window;
		  nativeEvent.correspondingUseElement &&
		    (nativeEvent = nativeEvent.correspondingUseElement);
		  return 3 === nativeEvent.nodeType ? nativeEvent.parentNode : nativeEvent;
		}
		var restoreTarget = null,
		  restoreQueue = null;
		function restoreStateOfTarget(target) {
		  var internalInstance = getInstanceFromNode(target);
		  if (internalInstance && (target = internalInstance.stateNode)) {
		    var props = target[internalPropsKey] || null;
		    a: switch (((target = internalInstance.stateNode), internalInstance.type)) {
		      case "input":
		        updateInput(
		          target,
		          props.value,
		          props.defaultValue,
		          props.defaultValue,
		          props.checked,
		          props.defaultChecked,
		          props.type,
		          props.name
		        );
		        internalInstance = props.name;
		        if ("radio" === props.type && null != internalInstance) {
		          for (props = target; props.parentNode; ) props = props.parentNode;
		          props = props.querySelectorAll(
		            'input[name="' +
		              escapeSelectorAttributeValueInsideDoubleQuotes(
		                "" + internalInstance
		              ) +
		              '"][type="radio"]'
		          );
		          for (
		            internalInstance = 0;
		            internalInstance < props.length;
		            internalInstance++
		          ) {
		            var otherNode = props[internalInstance];
		            if (otherNode !== target && otherNode.form === target.form) {
		              var otherProps = otherNode[internalPropsKey] || null;
		              if (!otherProps) throw Error(formatProdErrorMessage(90));
		              updateInput(
		                otherNode,
		                otherProps.value,
		                otherProps.defaultValue,
		                otherProps.defaultValue,
		                otherProps.checked,
		                otherProps.defaultChecked,
		                otherProps.type,
		                otherProps.name
		              );
		            }
		          }
		          for (
		            internalInstance = 0;
		            internalInstance < props.length;
		            internalInstance++
		          )
		            (otherNode = props[internalInstance]),
		              otherNode.form === target.form && updateValueIfChanged(otherNode);
		        }
		        break a;
		      case "textarea":
		        updateTextarea(target, props.value, props.defaultValue);
		        break a;
		      case "select":
		        (internalInstance = props.value),
		          null != internalInstance &&
		            updateOptions(target, !!props.multiple, internalInstance, false);
		    }
		  }
		}
		var isInsideEventHandler = false;
		function batchedUpdates$1(fn, a, b) {
		  if (isInsideEventHandler) return fn(a, b);
		  isInsideEventHandler = true;
		  try {
		    var JSCompiler_inline_result = fn(a);
		    return JSCompiler_inline_result;
		  } finally {
		    if (
		      ((isInsideEventHandler = false),
		      null !== restoreTarget || null !== restoreQueue)
		    )
		      if (
		        (flushSyncWork$1(),
		        restoreTarget &&
		          ((a = restoreTarget),
		          (fn = restoreQueue),
		          (restoreQueue = restoreTarget = null),
		          restoreStateOfTarget(a),
		          fn))
		      )
		        for (a = 0; a < fn.length; a++) restoreStateOfTarget(fn[a]);
		  }
		}
		function getListener(inst, registrationName) {
		  var stateNode = inst.stateNode;
		  if (null === stateNode) return null;
		  var props = stateNode[internalPropsKey] || null;
		  if (null === props) return null;
		  stateNode = props[registrationName];
		  a: switch (registrationName) {
		    case "onClick":
		    case "onClickCapture":
		    case "onDoubleClick":
		    case "onDoubleClickCapture":
		    case "onMouseDown":
		    case "onMouseDownCapture":
		    case "onMouseMove":
		    case "onMouseMoveCapture":
		    case "onMouseUp":
		    case "onMouseUpCapture":
		    case "onMouseEnter":
		      (props = !props.disabled) ||
		        ((inst = inst.type),
		        (props = !(
		          "button" === inst ||
		          "input" === inst ||
		          "select" === inst ||
		          "textarea" === inst
		        )));
		      inst = !props;
		      break a;
		    default:
		      inst = false;
		  }
		  if (inst) return null;
		  if (stateNode && "function" !== typeof stateNode)
		    throw Error(
		      formatProdErrorMessage(231, registrationName, typeof stateNode)
		    );
		  return stateNode;
		}
		var canUseDOM = !(
		    "undefined" === typeof window ||
		    "undefined" === typeof window.document ||
		    "undefined" === typeof window.document.createElement
		  ),
		  passiveBrowserEventsSupported = false;
		if (canUseDOM)
		  try {
		    var options = {};
		    Object.defineProperty(options, "passive", {
		      get: function () {
		        passiveBrowserEventsSupported = !0;
		      }
		    });
		    window.addEventListener("test", options, options);
		    window.removeEventListener("test", options, options);
		  } catch (e) {
		    passiveBrowserEventsSupported = false;
		  }
		var root = null,
		  startText = null,
		  fallbackText = null;
		function getData() {
		  if (fallbackText) return fallbackText;
		  var start,
		    startValue = startText,
		    startLength = startValue.length,
		    end,
		    endValue = "value" in root ? root.value : root.textContent,
		    endLength = endValue.length;
		  for (
		    start = 0;
		    start < startLength && startValue[start] === endValue[start];
		    start++
		  );
		  var minEnd = startLength - start;
		  for (
		    end = 1;
		    end <= minEnd &&
		    startValue[startLength - end] === endValue[endLength - end];
		    end++
		  );
		  return (fallbackText = endValue.slice(start, 1 < end ? 1 - end : void 0));
		}
		function getEventCharCode(nativeEvent) {
		  var keyCode = nativeEvent.keyCode;
		  "charCode" in nativeEvent
		    ? ((nativeEvent = nativeEvent.charCode),
		      0 === nativeEvent && 13 === keyCode && (nativeEvent = 13))
		    : (nativeEvent = keyCode);
		  10 === nativeEvent && (nativeEvent = 13);
		  return 32 <= nativeEvent || 13 === nativeEvent ? nativeEvent : 0;
		}
		function functionThatReturnsTrue() {
		  return true;
		}
		function functionThatReturnsFalse() {
		  return false;
		}
		function createSyntheticEvent(Interface) {
		  function SyntheticBaseEvent(
		    reactName,
		    reactEventType,
		    targetInst,
		    nativeEvent,
		    nativeEventTarget
		  ) {
		    this._reactName = reactName;
		    this._targetInst = targetInst;
		    this.type = reactEventType;
		    this.nativeEvent = nativeEvent;
		    this.target = nativeEventTarget;
		    this.currentTarget = null;
		    for (var propName in Interface)
		      Interface.hasOwnProperty(propName) &&
		        ((reactName = Interface[propName]),
		        (this[propName] = reactName
		          ? reactName(nativeEvent)
		          : nativeEvent[propName]));
		    this.isDefaultPrevented = (
		      null != nativeEvent.defaultPrevented
		        ? nativeEvent.defaultPrevented
		        : false === nativeEvent.returnValue
		    )
		      ? functionThatReturnsTrue
		      : functionThatReturnsFalse;
		    this.isPropagationStopped = functionThatReturnsFalse;
		    return this;
		  }
		  assign(SyntheticBaseEvent.prototype, {
		    preventDefault: function () {
		      this.defaultPrevented = true;
		      var event = this.nativeEvent;
		      event &&
		        (event.preventDefault
		          ? event.preventDefault()
		          : "unknown" !== typeof event.returnValue && (event.returnValue = false),
		        (this.isDefaultPrevented = functionThatReturnsTrue));
		    },
		    stopPropagation: function () {
		      var event = this.nativeEvent;
		      event &&
		        (event.stopPropagation
		          ? event.stopPropagation()
		          : "unknown" !== typeof event.cancelBubble &&
		            (event.cancelBubble = true),
		        (this.isPropagationStopped = functionThatReturnsTrue));
		    },
		    persist: function () {},
		    isPersistent: functionThatReturnsTrue
		  });
		  return SyntheticBaseEvent;
		}
		var EventInterface = {
		    eventPhase: 0,
		    bubbles: 0,
		    cancelable: 0,
		    timeStamp: function (event) {
		      return event.timeStamp || Date.now();
		    },
		    defaultPrevented: 0,
		    isTrusted: 0
		  },
		  SyntheticEvent = createSyntheticEvent(EventInterface),
		  UIEventInterface = assign({}, EventInterface, { view: 0, detail: 0 }),
		  SyntheticUIEvent = createSyntheticEvent(UIEventInterface),
		  lastMovementX,
		  lastMovementY,
		  lastMouseEvent,
		  MouseEventInterface = assign({}, UIEventInterface, {
		    screenX: 0,
		    screenY: 0,
		    clientX: 0,
		    clientY: 0,
		    pageX: 0,
		    pageY: 0,
		    ctrlKey: 0,
		    shiftKey: 0,
		    altKey: 0,
		    metaKey: 0,
		    getModifierState: getEventModifierState,
		    button: 0,
		    buttons: 0,
		    relatedTarget: function (event) {
		      return void 0 === event.relatedTarget
		        ? event.fromElement === event.srcElement
		          ? event.toElement
		          : event.fromElement
		        : event.relatedTarget;
		    },
		    movementX: function (event) {
		      if ("movementX" in event) return event.movementX;
		      event !== lastMouseEvent &&
		        (lastMouseEvent && "mousemove" === event.type
		          ? ((lastMovementX = event.screenX - lastMouseEvent.screenX),
		            (lastMovementY = event.screenY - lastMouseEvent.screenY))
		          : (lastMovementY = lastMovementX = 0),
		        (lastMouseEvent = event));
		      return lastMovementX;
		    },
		    movementY: function (event) {
		      return "movementY" in event ? event.movementY : lastMovementY;
		    }
		  }),
		  SyntheticMouseEvent = createSyntheticEvent(MouseEventInterface),
		  DragEventInterface = assign({}, MouseEventInterface, { dataTransfer: 0 }),
		  SyntheticDragEvent = createSyntheticEvent(DragEventInterface),
		  FocusEventInterface = assign({}, UIEventInterface, { relatedTarget: 0 }),
		  SyntheticFocusEvent = createSyntheticEvent(FocusEventInterface),
		  AnimationEventInterface = assign({}, EventInterface, {
		    animationName: 0,
		    elapsedTime: 0,
		    pseudoElement: 0
		  }),
		  SyntheticAnimationEvent = createSyntheticEvent(AnimationEventInterface),
		  ClipboardEventInterface = assign({}, EventInterface, {
		    clipboardData: function (event) {
		      return "clipboardData" in event
		        ? event.clipboardData
		        : window.clipboardData;
		    }
		  }),
		  SyntheticClipboardEvent = createSyntheticEvent(ClipboardEventInterface),
		  CompositionEventInterface = assign({}, EventInterface, { data: 0 }),
		  SyntheticCompositionEvent = createSyntheticEvent(CompositionEventInterface),
		  normalizeKey = {
		    Esc: "Escape",
		    Spacebar: " ",
		    Left: "ArrowLeft",
		    Up: "ArrowUp",
		    Right: "ArrowRight",
		    Down: "ArrowDown",
		    Del: "Delete",
		    Win: "OS",
		    Menu: "ContextMenu",
		    Apps: "ContextMenu",
		    Scroll: "ScrollLock",
		    MozPrintableKey: "Unidentified"
		  },
		  translateToKey = {
		    8: "Backspace",
		    9: "Tab",
		    12: "Clear",
		    13: "Enter",
		    16: "Shift",
		    17: "Control",
		    18: "Alt",
		    19: "Pause",
		    20: "CapsLock",
		    27: "Escape",
		    32: " ",
		    33: "PageUp",
		    34: "PageDown",
		    35: "End",
		    36: "Home",
		    37: "ArrowLeft",
		    38: "ArrowUp",
		    39: "ArrowRight",
		    40: "ArrowDown",
		    45: "Insert",
		    46: "Delete",
		    112: "F1",
		    113: "F2",
		    114: "F3",
		    115: "F4",
		    116: "F5",
		    117: "F6",
		    118: "F7",
		    119: "F8",
		    120: "F9",
		    121: "F10",
		    122: "F11",
		    123: "F12",
		    144: "NumLock",
		    145: "ScrollLock",
		    224: "Meta"
		  },
		  modifierKeyToProp = {
		    Alt: "altKey",
		    Control: "ctrlKey",
		    Meta: "metaKey",
		    Shift: "shiftKey"
		  };
		function modifierStateGetter(keyArg) {
		  var nativeEvent = this.nativeEvent;
		  return nativeEvent.getModifierState
		    ? nativeEvent.getModifierState(keyArg)
		    : (keyArg = modifierKeyToProp[keyArg])
		      ? !!nativeEvent[keyArg]
		      : false;
		}
		function getEventModifierState() {
		  return modifierStateGetter;
		}
		var KeyboardEventInterface = assign({}, UIEventInterface, {
		    key: function (nativeEvent) {
		      if (nativeEvent.key) {
		        var key = normalizeKey[nativeEvent.key] || nativeEvent.key;
		        if ("Unidentified" !== key) return key;
		      }
		      return "keypress" === nativeEvent.type
		        ? ((nativeEvent = getEventCharCode(nativeEvent)),
		          13 === nativeEvent ? "Enter" : String.fromCharCode(nativeEvent))
		        : "keydown" === nativeEvent.type || "keyup" === nativeEvent.type
		          ? translateToKey[nativeEvent.keyCode] || "Unidentified"
		          : "";
		    },
		    code: 0,
		    location: 0,
		    ctrlKey: 0,
		    shiftKey: 0,
		    altKey: 0,
		    metaKey: 0,
		    repeat: 0,
		    locale: 0,
		    getModifierState: getEventModifierState,
		    charCode: function (event) {
		      return "keypress" === event.type ? getEventCharCode(event) : 0;
		    },
		    keyCode: function (event) {
		      return "keydown" === event.type || "keyup" === event.type
		        ? event.keyCode
		        : 0;
		    },
		    which: function (event) {
		      return "keypress" === event.type
		        ? getEventCharCode(event)
		        : "keydown" === event.type || "keyup" === event.type
		          ? event.keyCode
		          : 0;
		    }
		  }),
		  SyntheticKeyboardEvent = createSyntheticEvent(KeyboardEventInterface),
		  PointerEventInterface = assign({}, MouseEventInterface, {
		    pointerId: 0,
		    width: 0,
		    height: 0,
		    pressure: 0,
		    tangentialPressure: 0,
		    tiltX: 0,
		    tiltY: 0,
		    twist: 0,
		    pointerType: 0,
		    isPrimary: 0
		  }),
		  SyntheticPointerEvent = createSyntheticEvent(PointerEventInterface),
		  TouchEventInterface = assign({}, UIEventInterface, {
		    touches: 0,
		    targetTouches: 0,
		    changedTouches: 0,
		    altKey: 0,
		    metaKey: 0,
		    ctrlKey: 0,
		    shiftKey: 0,
		    getModifierState: getEventModifierState
		  }),
		  SyntheticTouchEvent = createSyntheticEvent(TouchEventInterface),
		  TransitionEventInterface = assign({}, EventInterface, {
		    propertyName: 0,
		    elapsedTime: 0,
		    pseudoElement: 0
		  }),
		  SyntheticTransitionEvent = createSyntheticEvent(TransitionEventInterface),
		  WheelEventInterface = assign({}, MouseEventInterface, {
		    deltaX: function (event) {
		      return "deltaX" in event
		        ? event.deltaX
		        : "wheelDeltaX" in event
		          ? -event.wheelDeltaX
		          : 0;
		    },
		    deltaY: function (event) {
		      return "deltaY" in event
		        ? event.deltaY
		        : "wheelDeltaY" in event
		          ? -event.wheelDeltaY
		          : "wheelDelta" in event
		            ? -event.wheelDelta
		            : 0;
		    },
		    deltaZ: 0,
		    deltaMode: 0
		  }),
		  SyntheticWheelEvent = createSyntheticEvent(WheelEventInterface),
		  ToggleEventInterface = assign({}, EventInterface, {
		    newState: 0,
		    oldState: 0
		  }),
		  SyntheticToggleEvent = createSyntheticEvent(ToggleEventInterface),
		  END_KEYCODES = [9, 13, 27, 32],
		  canUseCompositionEvent = canUseDOM && "CompositionEvent" in window,
		  documentMode = null;
		canUseDOM &&
		  "documentMode" in document &&
		  (documentMode = document.documentMode);
		var canUseTextInputEvent = canUseDOM && "TextEvent" in window && !documentMode,
		  useFallbackCompositionData =
		    canUseDOM &&
		    (!canUseCompositionEvent ||
		      (documentMode && 8 < documentMode && 11 >= documentMode)),
		  SPACEBAR_CHAR = String.fromCharCode(32),
		  hasSpaceKeypress = false;
		function isFallbackCompositionEnd(domEventName, nativeEvent) {
		  switch (domEventName) {
		    case "keyup":
		      return -1 !== END_KEYCODES.indexOf(nativeEvent.keyCode);
		    case "keydown":
		      return 229 !== nativeEvent.keyCode;
		    case "keypress":
		    case "mousedown":
		    case "focusout":
		      return true;
		    default:
		      return false;
		  }
		}
		function getDataFromCustomEvent(nativeEvent) {
		  nativeEvent = nativeEvent.detail;
		  return "object" === typeof nativeEvent && "data" in nativeEvent
		    ? nativeEvent.data
		    : null;
		}
		var isComposing = false;
		function getNativeBeforeInputChars(domEventName, nativeEvent) {
		  switch (domEventName) {
		    case "compositionend":
		      return getDataFromCustomEvent(nativeEvent);
		    case "keypress":
		      if (32 !== nativeEvent.which) return null;
		      hasSpaceKeypress = true;
		      return SPACEBAR_CHAR;
		    case "textInput":
		      return (
		        (domEventName = nativeEvent.data),
		        domEventName === SPACEBAR_CHAR && hasSpaceKeypress ? null : domEventName
		      );
		    default:
		      return null;
		  }
		}
		function getFallbackBeforeInputChars(domEventName, nativeEvent) {
		  if (isComposing)
		    return "compositionend" === domEventName ||
		      (!canUseCompositionEvent &&
		        isFallbackCompositionEnd(domEventName, nativeEvent))
		      ? ((domEventName = getData()),
		        (fallbackText = startText = root = null),
		        (isComposing = false),
		        domEventName)
		      : null;
		  switch (domEventName) {
		    case "paste":
		      return null;
		    case "keypress":
		      if (
		        !(nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) ||
		        (nativeEvent.ctrlKey && nativeEvent.altKey)
		      ) {
		        if (nativeEvent.char && 1 < nativeEvent.char.length)
		          return nativeEvent.char;
		        if (nativeEvent.which) return String.fromCharCode(nativeEvent.which);
		      }
		      return null;
		    case "compositionend":
		      return useFallbackCompositionData && "ko" !== nativeEvent.locale
		        ? null
		        : nativeEvent.data;
		    default:
		      return null;
		  }
		}
		var supportedInputTypes = {
		  color: true,
		  date: true,
		  datetime: true,
		  "datetime-local": true,
		  email: true,
		  month: true,
		  number: true,
		  password: true,
		  range: true,
		  search: true,
		  tel: true,
		  text: true,
		  time: true,
		  url: true,
		  week: true
		};
		function isTextInputElement(elem) {
		  var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
		  return "input" === nodeName
		    ? !!supportedInputTypes[elem.type]
		    : "textarea" === nodeName
		      ? true
		      : false;
		}
		function createAndAccumulateChangeEvent(
		  dispatchQueue,
		  inst,
		  nativeEvent,
		  target
		) {
		  restoreTarget
		    ? restoreQueue
		      ? restoreQueue.push(target)
		      : (restoreQueue = [target])
		    : (restoreTarget = target);
		  inst = accumulateTwoPhaseListeners(inst, "onChange");
		  0 < inst.length &&
		    ((nativeEvent = new SyntheticEvent(
		      "onChange",
		      "change",
		      null,
		      nativeEvent,
		      target
		    )),
		    dispatchQueue.push({ event: nativeEvent, listeners: inst }));
		}
		var activeElement$1 = null,
		  activeElementInst$1 = null;
		function runEventInBatch(dispatchQueue) {
		  processDispatchQueue(dispatchQueue, 0);
		}
		function getInstIfValueChanged(targetInst) {
		  var targetNode = getNodeFromInstance(targetInst);
		  if (updateValueIfChanged(targetNode)) return targetInst;
		}
		function getTargetInstForChangeEvent(domEventName, targetInst) {
		  if ("change" === domEventName) return targetInst;
		}
		var isInputEventSupported = false;
		if (canUseDOM) {
		  var JSCompiler_inline_result$jscomp$282;
		  if (canUseDOM) {
		    var isSupported$jscomp$inline_417 = "oninput" in document;
		    if (!isSupported$jscomp$inline_417) {
		      var element$jscomp$inline_418 = document.createElement("div");
		      element$jscomp$inline_418.setAttribute("oninput", "return;");
		      isSupported$jscomp$inline_417 =
		        "function" === typeof element$jscomp$inline_418.oninput;
		    }
		    JSCompiler_inline_result$jscomp$282 = isSupported$jscomp$inline_417;
		  } else JSCompiler_inline_result$jscomp$282 = false;
		  isInputEventSupported =
		    JSCompiler_inline_result$jscomp$282 &&
		    (!document.documentMode || 9 < document.documentMode);
		}
		function stopWatchingForValueChange() {
		  activeElement$1 &&
		    (activeElement$1.detachEvent("onpropertychange", handlePropertyChange),
		    (activeElementInst$1 = activeElement$1 = null));
		}
		function handlePropertyChange(nativeEvent) {
		  if (
		    "value" === nativeEvent.propertyName &&
		    getInstIfValueChanged(activeElementInst$1)
		  ) {
		    var dispatchQueue = [];
		    createAndAccumulateChangeEvent(
		      dispatchQueue,
		      activeElementInst$1,
		      nativeEvent,
		      getEventTarget(nativeEvent)
		    );
		    batchedUpdates$1(runEventInBatch, dispatchQueue);
		  }
		}
		function handleEventsForInputEventPolyfill(domEventName, target, targetInst) {
		  "focusin" === domEventName
		    ? (stopWatchingForValueChange(),
		      (activeElement$1 = target),
		      (activeElementInst$1 = targetInst),
		      activeElement$1.attachEvent("onpropertychange", handlePropertyChange))
		    : "focusout" === domEventName && stopWatchingForValueChange();
		}
		function getTargetInstForInputEventPolyfill(domEventName) {
		  if (
		    "selectionchange" === domEventName ||
		    "keyup" === domEventName ||
		    "keydown" === domEventName
		  )
		    return getInstIfValueChanged(activeElementInst$1);
		}
		function getTargetInstForClickEvent(domEventName, targetInst) {
		  if ("click" === domEventName) return getInstIfValueChanged(targetInst);
		}
		function getTargetInstForInputOrChangeEvent(domEventName, targetInst) {
		  if ("input" === domEventName || "change" === domEventName)
		    return getInstIfValueChanged(targetInst);
		}
		function is(x, y) {
		  return (x === y && (0 !== x || 1 / x === 1 / y)) || (x !== x && y !== y);
		}
		var objectIs = "function" === typeof Object.is ? Object.is : is;
		function shallowEqual(objA, objB) {
		  if (objectIs(objA, objB)) return true;
		  if (
		    "object" !== typeof objA ||
		    null === objA ||
		    "object" !== typeof objB ||
		    null === objB
		  )
		    return false;
		  var keysA = Object.keys(objA),
		    keysB = Object.keys(objB);
		  if (keysA.length !== keysB.length) return false;
		  for (keysB = 0; keysB < keysA.length; keysB++) {
		    var currentKey = keysA[keysB];
		    if (
		      !hasOwnProperty.call(objB, currentKey) ||
		      !objectIs(objA[currentKey], objB[currentKey])
		    )
		      return false;
		  }
		  return true;
		}
		function getLeafNode(node) {
		  for (; node && node.firstChild; ) node = node.firstChild;
		  return node;
		}
		function getNodeForCharacterOffset(root, offset) {
		  var node = getLeafNode(root);
		  root = 0;
		  for (var nodeEnd; node; ) {
		    if (3 === node.nodeType) {
		      nodeEnd = root + node.textContent.length;
		      if (root <= offset && nodeEnd >= offset)
		        return { node: node, offset: offset - root };
		      root = nodeEnd;
		    }
		    a: {
		      for (; node; ) {
		        if (node.nextSibling) {
		          node = node.nextSibling;
		          break a;
		        }
		        node = node.parentNode;
		      }
		      node = void 0;
		    }
		    node = getLeafNode(node);
		  }
		}
		function containsNode(outerNode, innerNode) {
		  return outerNode && innerNode
		    ? outerNode === innerNode
		      ? true
		      : outerNode && 3 === outerNode.nodeType
		        ? false
		        : innerNode && 3 === innerNode.nodeType
		          ? containsNode(outerNode, innerNode.parentNode)
		          : "contains" in outerNode
		            ? outerNode.contains(innerNode)
		            : outerNode.compareDocumentPosition
		              ? !!(outerNode.compareDocumentPosition(innerNode) & 16)
		              : false
		    : false;
		}
		function getActiveElementDeep(containerInfo) {
		  containerInfo =
		    null != containerInfo &&
		    null != containerInfo.ownerDocument &&
		    null != containerInfo.ownerDocument.defaultView
		      ? containerInfo.ownerDocument.defaultView
		      : window;
		  for (
		    var element = getActiveElement(containerInfo.document);
		    element instanceof containerInfo.HTMLIFrameElement;

		  ) {
		    try {
		      var JSCompiler_inline_result =
		        "string" === typeof element.contentWindow.location.href;
		    } catch (err) {
		      JSCompiler_inline_result = false;
		    }
		    if (JSCompiler_inline_result) containerInfo = element.contentWindow;
		    else break;
		    element = getActiveElement(containerInfo.document);
		  }
		  return element;
		}
		function hasSelectionCapabilities(elem) {
		  var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
		  return (
		    nodeName &&
		    (("input" === nodeName &&
		      ("text" === elem.type ||
		        "search" === elem.type ||
		        "tel" === elem.type ||
		        "url" === elem.type ||
		        "password" === elem.type)) ||
		      "textarea" === nodeName ||
		      "true" === elem.contentEditable)
		  );
		}
		var skipSelectionChangeEvent =
		    canUseDOM && "documentMode" in document && 11 >= document.documentMode,
		  activeElement = null,
		  activeElementInst = null,
		  lastSelection = null,
		  mouseDown = false;
		function constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget) {
		  var doc =
		    nativeEventTarget.window === nativeEventTarget
		      ? nativeEventTarget.document
		      : 9 === nativeEventTarget.nodeType
		        ? nativeEventTarget
		        : nativeEventTarget.ownerDocument;
		  mouseDown ||
		    null == activeElement ||
		    activeElement !== getActiveElement(doc) ||
		    ((doc = activeElement),
		    "selectionStart" in doc && hasSelectionCapabilities(doc)
		      ? (doc = { start: doc.selectionStart, end: doc.selectionEnd })
		      : ((doc = (
		          (doc.ownerDocument && doc.ownerDocument.defaultView) ||
		          window
		        ).getSelection()),
		        (doc = {
		          anchorNode: doc.anchorNode,
		          anchorOffset: doc.anchorOffset,
		          focusNode: doc.focusNode,
		          focusOffset: doc.focusOffset
		        })),
		    (lastSelection && shallowEqual(lastSelection, doc)) ||
		      ((lastSelection = doc),
		      (doc = accumulateTwoPhaseListeners(activeElementInst, "onSelect")),
		      0 < doc.length &&
		        ((nativeEvent = new SyntheticEvent(
		          "onSelect",
		          "select",
		          null,
		          nativeEvent,
		          nativeEventTarget
		        )),
		        dispatchQueue.push({ event: nativeEvent, listeners: doc }),
		        (nativeEvent.target = activeElement))));
		}
		function makePrefixMap(styleProp, eventName) {
		  var prefixes = {};
		  prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();
		  prefixes["Webkit" + styleProp] = "webkit" + eventName;
		  prefixes["Moz" + styleProp] = "moz" + eventName;
		  return prefixes;
		}
		var vendorPrefixes = {
		    animationend: makePrefixMap("Animation", "AnimationEnd"),
		    animationiteration: makePrefixMap("Animation", "AnimationIteration"),
		    animationstart: makePrefixMap("Animation", "AnimationStart"),
		    transitionrun: makePrefixMap("Transition", "TransitionRun"),
		    transitionstart: makePrefixMap("Transition", "TransitionStart"),
		    transitioncancel: makePrefixMap("Transition", "TransitionCancel"),
		    transitionend: makePrefixMap("Transition", "TransitionEnd")
		  },
		  prefixedEventNames = {},
		  style = {};
		canUseDOM &&
		  ((style = document.createElement("div").style),
		  "AnimationEvent" in window ||
		    (delete vendorPrefixes.animationend.animation,
		    delete vendorPrefixes.animationiteration.animation,
		    delete vendorPrefixes.animationstart.animation),
		  "TransitionEvent" in window ||
		    delete vendorPrefixes.transitionend.transition);
		function getVendorPrefixedEventName(eventName) {
		  if (prefixedEventNames[eventName]) return prefixedEventNames[eventName];
		  if (!vendorPrefixes[eventName]) return eventName;
		  var prefixMap = vendorPrefixes[eventName],
		    styleProp;
		  for (styleProp in prefixMap)
		    if (prefixMap.hasOwnProperty(styleProp) && styleProp in style)
		      return (prefixedEventNames[eventName] = prefixMap[styleProp]);
		  return eventName;
		}
		var ANIMATION_END = getVendorPrefixedEventName("animationend"),
		  ANIMATION_ITERATION = getVendorPrefixedEventName("animationiteration"),
		  ANIMATION_START = getVendorPrefixedEventName("animationstart"),
		  TRANSITION_RUN = getVendorPrefixedEventName("transitionrun"),
		  TRANSITION_START = getVendorPrefixedEventName("transitionstart"),
		  TRANSITION_CANCEL = getVendorPrefixedEventName("transitioncancel"),
		  TRANSITION_END = getVendorPrefixedEventName("transitionend"),
		  topLevelEventsToReactNames = new Map(),
		  simpleEventPluginEvents =
		    "abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(
		      " "
		    );
		simpleEventPluginEvents.push("scrollEnd");
		function registerSimpleEvent(domEventName, reactName) {
		  topLevelEventsToReactNames.set(domEventName, reactName);
		  registerTwoPhaseEvent(reactName, [domEventName]);
		}
		var CapturedStacks = new WeakMap();
		function createCapturedValueAtFiber(value, source) {
		  if ("object" === typeof value && null !== value) {
		    var existing = CapturedStacks.get(value);
		    if (void 0 !== existing) return existing;
		    source = {
		      value: value,
		      source: source,
		      stack: getStackByFiberInDevAndProd(source)
		    };
		    CapturedStacks.set(value, source);
		    return source;
		  }
		  return {
		    value: value,
		    source: source,
		    stack: getStackByFiberInDevAndProd(source)
		  };
		}
		var concurrentQueues = [],
		  concurrentQueuesIndex = 0,
		  concurrentlyUpdatedLanes = 0;
		function finishQueueingConcurrentUpdates() {
		  for (
		    var endIndex = concurrentQueuesIndex,
		      i = (concurrentlyUpdatedLanes = concurrentQueuesIndex = 0);
		    i < endIndex;

		  ) {
		    var fiber = concurrentQueues[i];
		    concurrentQueues[i++] = null;
		    var queue = concurrentQueues[i];
		    concurrentQueues[i++] = null;
		    var update = concurrentQueues[i];
		    concurrentQueues[i++] = null;
		    var lane = concurrentQueues[i];
		    concurrentQueues[i++] = null;
		    if (null !== queue && null !== update) {
		      var pending = queue.pending;
		      null === pending
		        ? (update.next = update)
		        : ((update.next = pending.next), (pending.next = update));
		      queue.pending = update;
		    }
		    0 !== lane && markUpdateLaneFromFiberToRoot(fiber, update, lane);
		  }
		}
		function enqueueUpdate$1(fiber, queue, update, lane) {
		  concurrentQueues[concurrentQueuesIndex++] = fiber;
		  concurrentQueues[concurrentQueuesIndex++] = queue;
		  concurrentQueues[concurrentQueuesIndex++] = update;
		  concurrentQueues[concurrentQueuesIndex++] = lane;
		  concurrentlyUpdatedLanes |= lane;
		  fiber.lanes |= lane;
		  fiber = fiber.alternate;
		  null !== fiber && (fiber.lanes |= lane);
		}
		function enqueueConcurrentHookUpdate(fiber, queue, update, lane) {
		  enqueueUpdate$1(fiber, queue, update, lane);
		  return getRootForUpdatedFiber(fiber);
		}
		function enqueueConcurrentRenderForLane(fiber, lane) {
		  enqueueUpdate$1(fiber, null, null, lane);
		  return getRootForUpdatedFiber(fiber);
		}
		function markUpdateLaneFromFiberToRoot(sourceFiber, update, lane) {
		  sourceFiber.lanes |= lane;
		  var alternate = sourceFiber.alternate;
		  null !== alternate && (alternate.lanes |= lane);
		  for (var isHidden = false, parent = sourceFiber.return; null !== parent; )
		    (parent.childLanes |= lane),
		      (alternate = parent.alternate),
		      null !== alternate && (alternate.childLanes |= lane),
		      22 === parent.tag &&
		        ((sourceFiber = parent.stateNode),
		        null === sourceFiber || sourceFiber._visibility & 1 || (isHidden = true)),
		      (sourceFiber = parent),
		      (parent = parent.return);
		  return 3 === sourceFiber.tag
		    ? ((parent = sourceFiber.stateNode),
		      isHidden &&
		        null !== update &&
		        ((isHidden = 31 - clz32(lane)),
		        (sourceFiber = parent.hiddenUpdates),
		        (alternate = sourceFiber[isHidden]),
		        null === alternate
		          ? (sourceFiber[isHidden] = [update])
		          : alternate.push(update),
		        (update.lane = lane | 536870912)),
		      parent)
		    : null;
		}
		function getRootForUpdatedFiber(sourceFiber) {
		  if (50 < nestedUpdateCount)
		    throw (
		      ((nestedUpdateCount = 0),
		      (rootWithNestedUpdates = null),
		      Error(formatProdErrorMessage(185)))
		    );
		  for (var parent = sourceFiber.return; null !== parent; )
		    (sourceFiber = parent), (parent = sourceFiber.return);
		  return 3 === sourceFiber.tag ? sourceFiber.stateNode : null;
		}
		var emptyContextObject = {};
		function FiberNode(tag, pendingProps, key, mode) {
		  this.tag = tag;
		  this.key = key;
		  this.sibling =
		    this.child =
		    this.return =
		    this.stateNode =
		    this.type =
		    this.elementType =
		      null;
		  this.index = 0;
		  this.refCleanup = this.ref = null;
		  this.pendingProps = pendingProps;
		  this.dependencies =
		    this.memoizedState =
		    this.updateQueue =
		    this.memoizedProps =
		      null;
		  this.mode = mode;
		  this.subtreeFlags = this.flags = 0;
		  this.deletions = null;
		  this.childLanes = this.lanes = 0;
		  this.alternate = null;
		}
		function createFiberImplClass(tag, pendingProps, key, mode) {
		  return new FiberNode(tag, pendingProps, key, mode);
		}
		function shouldConstruct(Component) {
		  Component = Component.prototype;
		  return !(!Component || !Component.isReactComponent);
		}
		function createWorkInProgress(current, pendingProps) {
		  var workInProgress = current.alternate;
		  null === workInProgress
		    ? ((workInProgress = createFiberImplClass(
		        current.tag,
		        pendingProps,
		        current.key,
		        current.mode
		      )),
		      (workInProgress.elementType = current.elementType),
		      (workInProgress.type = current.type),
		      (workInProgress.stateNode = current.stateNode),
		      (workInProgress.alternate = current),
		      (current.alternate = workInProgress))
		    : ((workInProgress.pendingProps = pendingProps),
		      (workInProgress.type = current.type),
		      (workInProgress.flags = 0),
		      (workInProgress.subtreeFlags = 0),
		      (workInProgress.deletions = null));
		  workInProgress.flags = current.flags & 65011712;
		  workInProgress.childLanes = current.childLanes;
		  workInProgress.lanes = current.lanes;
		  workInProgress.child = current.child;
		  workInProgress.memoizedProps = current.memoizedProps;
		  workInProgress.memoizedState = current.memoizedState;
		  workInProgress.updateQueue = current.updateQueue;
		  pendingProps = current.dependencies;
		  workInProgress.dependencies =
		    null === pendingProps
		      ? null
		      : { lanes: pendingProps.lanes, firstContext: pendingProps.firstContext };
		  workInProgress.sibling = current.sibling;
		  workInProgress.index = current.index;
		  workInProgress.ref = current.ref;
		  workInProgress.refCleanup = current.refCleanup;
		  return workInProgress;
		}
		function resetWorkInProgress(workInProgress, renderLanes) {
		  workInProgress.flags &= 65011714;
		  var current = workInProgress.alternate;
		  null === current
		    ? ((workInProgress.childLanes = 0),
		      (workInProgress.lanes = renderLanes),
		      (workInProgress.child = null),
		      (workInProgress.subtreeFlags = 0),
		      (workInProgress.memoizedProps = null),
		      (workInProgress.memoizedState = null),
		      (workInProgress.updateQueue = null),
		      (workInProgress.dependencies = null),
		      (workInProgress.stateNode = null))
		    : ((workInProgress.childLanes = current.childLanes),
		      (workInProgress.lanes = current.lanes),
		      (workInProgress.child = current.child),
		      (workInProgress.subtreeFlags = 0),
		      (workInProgress.deletions = null),
		      (workInProgress.memoizedProps = current.memoizedProps),
		      (workInProgress.memoizedState = current.memoizedState),
		      (workInProgress.updateQueue = current.updateQueue),
		      (workInProgress.type = current.type),
		      (renderLanes = current.dependencies),
		      (workInProgress.dependencies =
		        null === renderLanes
		          ? null
		          : {
		              lanes: renderLanes.lanes,
		              firstContext: renderLanes.firstContext
		            }));
		  return workInProgress;
		}
		function createFiberFromTypeAndProps(
		  type,
		  key,
		  pendingProps,
		  owner,
		  mode,
		  lanes
		) {
		  var fiberTag = 0;
		  owner = type;
		  if ("function" === typeof type) shouldConstruct(type) && (fiberTag = 1);
		  else if ("string" === typeof type)
		    fiberTag = isHostHoistableType(
		      type,
		      pendingProps,
		      contextStackCursor.current
		    )
		      ? 26
		      : "html" === type || "head" === type || "body" === type
		        ? 27
		        : 5;
		  else
		    a: switch (type) {
		      case REACT_ACTIVITY_TYPE:
		        return (
		          (type = createFiberImplClass(31, pendingProps, key, mode)),
		          (type.elementType = REACT_ACTIVITY_TYPE),
		          (type.lanes = lanes),
		          type
		        );
		      case REACT_FRAGMENT_TYPE:
		        return createFiberFromFragment(pendingProps.children, mode, lanes, key);
		      case REACT_STRICT_MODE_TYPE:
		        fiberTag = 8;
		        mode |= 24;
		        break;
		      case REACT_PROFILER_TYPE:
		        return (
		          (type = createFiberImplClass(12, pendingProps, key, mode | 2)),
		          (type.elementType = REACT_PROFILER_TYPE),
		          (type.lanes = lanes),
		          type
		        );
		      case REACT_SUSPENSE_TYPE:
		        return (
		          (type = createFiberImplClass(13, pendingProps, key, mode)),
		          (type.elementType = REACT_SUSPENSE_TYPE),
		          (type.lanes = lanes),
		          type
		        );
		      case REACT_SUSPENSE_LIST_TYPE:
		        return (
		          (type = createFiberImplClass(19, pendingProps, key, mode)),
		          (type.elementType = REACT_SUSPENSE_LIST_TYPE),
		          (type.lanes = lanes),
		          type
		        );
		      default:
		        if ("object" === typeof type && null !== type)
		          switch (type.$$typeof) {
		            case REACT_PROVIDER_TYPE:
		            case REACT_CONTEXT_TYPE:
		              fiberTag = 10;
		              break a;
		            case REACT_CONSUMER_TYPE:
		              fiberTag = 9;
		              break a;
		            case REACT_FORWARD_REF_TYPE:
		              fiberTag = 11;
		              break a;
		            case REACT_MEMO_TYPE:
		              fiberTag = 14;
		              break a;
		            case REACT_LAZY_TYPE:
		              fiberTag = 16;
		              owner = null;
		              break a;
		          }
		        fiberTag = 29;
		        pendingProps = Error(
		          formatProdErrorMessage(130, null === type ? "null" : typeof type, "")
		        );
		        owner = null;
		    }
		  key = createFiberImplClass(fiberTag, pendingProps, key, mode);
		  key.elementType = type;
		  key.type = owner;
		  key.lanes = lanes;
		  return key;
		}
		function createFiberFromFragment(elements, mode, lanes, key) {
		  elements = createFiberImplClass(7, elements, key, mode);
		  elements.lanes = lanes;
		  return elements;
		}
		function createFiberFromText(content, mode, lanes) {
		  content = createFiberImplClass(6, content, null, mode);
		  content.lanes = lanes;
		  return content;
		}
		function createFiberFromPortal(portal, mode, lanes) {
		  mode = createFiberImplClass(
		    4,
		    null !== portal.children ? portal.children : [],
		    portal.key,
		    mode
		  );
		  mode.lanes = lanes;
		  mode.stateNode = {
		    containerInfo: portal.containerInfo,
		    pendingChildren: null,
		    implementation: portal.implementation
		  };
		  return mode;
		}
		var forkStack = [],
		  forkStackIndex = 0,
		  treeForkProvider = null,
		  treeForkCount = 0,
		  idStack = [],
		  idStackIndex = 0,
		  treeContextProvider = null,
		  treeContextId = 1,
		  treeContextOverflow = "";
		function pushTreeFork(workInProgress, totalChildren) {
		  forkStack[forkStackIndex++] = treeForkCount;
		  forkStack[forkStackIndex++] = treeForkProvider;
		  treeForkProvider = workInProgress;
		  treeForkCount = totalChildren;
		}
		function pushTreeId(workInProgress, totalChildren, index) {
		  idStack[idStackIndex++] = treeContextId;
		  idStack[idStackIndex++] = treeContextOverflow;
		  idStack[idStackIndex++] = treeContextProvider;
		  treeContextProvider = workInProgress;
		  var baseIdWithLeadingBit = treeContextId;
		  workInProgress = treeContextOverflow;
		  var baseLength = 32 - clz32(baseIdWithLeadingBit) - 1;
		  baseIdWithLeadingBit &= ~(1 << baseLength);
		  index += 1;
		  var length = 32 - clz32(totalChildren) + baseLength;
		  if (30 < length) {
		    var numberOfOverflowBits = baseLength - (baseLength % 5);
		    length = (
		      baseIdWithLeadingBit &
		      ((1 << numberOfOverflowBits) - 1)
		    ).toString(32);
		    baseIdWithLeadingBit >>= numberOfOverflowBits;
		    baseLength -= numberOfOverflowBits;
		    treeContextId =
		      (1 << (32 - clz32(totalChildren) + baseLength)) |
		      (index << baseLength) |
		      baseIdWithLeadingBit;
		    treeContextOverflow = length + workInProgress;
		  } else
		    (treeContextId =
		      (1 << length) | (index << baseLength) | baseIdWithLeadingBit),
		      (treeContextOverflow = workInProgress);
		}
		function pushMaterializedTreeId(workInProgress) {
		  null !== workInProgress.return &&
		    (pushTreeFork(workInProgress, 1), pushTreeId(workInProgress, 1, 0));
		}
		function popTreeContext(workInProgress) {
		  for (; workInProgress === treeForkProvider; )
		    (treeForkProvider = forkStack[--forkStackIndex]),
		      (forkStack[forkStackIndex] = null),
		      (treeForkCount = forkStack[--forkStackIndex]),
		      (forkStack[forkStackIndex] = null);
		  for (; workInProgress === treeContextProvider; )
		    (treeContextProvider = idStack[--idStackIndex]),
		      (idStack[idStackIndex] = null),
		      (treeContextOverflow = idStack[--idStackIndex]),
		      (idStack[idStackIndex] = null),
		      (treeContextId = idStack[--idStackIndex]),
		      (idStack[idStackIndex] = null);
		}
		var hydrationParentFiber = null,
		  nextHydratableInstance = null,
		  isHydrating = false,
		  hydrationErrors = null,
		  rootOrSingletonContext = false,
		  HydrationMismatchException = Error(formatProdErrorMessage(519));
		function throwOnHydrationMismatch(fiber) {
		  var error = Error(formatProdErrorMessage(418, ""));
		  queueHydrationError(createCapturedValueAtFiber(error, fiber));
		  throw HydrationMismatchException;
		}
		function prepareToHydrateHostInstance(fiber) {
		  var instance = fiber.stateNode,
		    type = fiber.type,
		    props = fiber.memoizedProps;
		  instance[internalInstanceKey] = fiber;
		  instance[internalPropsKey] = props;
		  switch (type) {
		    case "dialog":
		      listenToNonDelegatedEvent("cancel", instance);
		      listenToNonDelegatedEvent("close", instance);
		      break;
		    case "iframe":
		    case "object":
		    case "embed":
		      listenToNonDelegatedEvent("load", instance);
		      break;
		    case "video":
		    case "audio":
		      for (type = 0; type < mediaEventTypes.length; type++)
		        listenToNonDelegatedEvent(mediaEventTypes[type], instance);
		      break;
		    case "source":
		      listenToNonDelegatedEvent("error", instance);
		      break;
		    case "img":
		    case "image":
		    case "link":
		      listenToNonDelegatedEvent("error", instance);
		      listenToNonDelegatedEvent("load", instance);
		      break;
		    case "details":
		      listenToNonDelegatedEvent("toggle", instance);
		      break;
		    case "input":
		      listenToNonDelegatedEvent("invalid", instance);
		      initInput(
		        instance,
		        props.value,
		        props.defaultValue,
		        props.checked,
		        props.defaultChecked,
		        props.type,
		        props.name,
		        true
		      );
		      track(instance);
		      break;
		    case "select":
		      listenToNonDelegatedEvent("invalid", instance);
		      break;
		    case "textarea":
		      listenToNonDelegatedEvent("invalid", instance),
		        initTextarea(instance, props.value, props.defaultValue, props.children),
		        track(instance);
		  }
		  type = props.children;
		  ("string" !== typeof type &&
		    "number" !== typeof type &&
		    "bigint" !== typeof type) ||
		  instance.textContent === "" + type ||
		  true === props.suppressHydrationWarning ||
		  checkForUnmatchedText(instance.textContent, type)
		    ? (null != props.popover &&
		        (listenToNonDelegatedEvent("beforetoggle", instance),
		        listenToNonDelegatedEvent("toggle", instance)),
		      null != props.onScroll && listenToNonDelegatedEvent("scroll", instance),
		      null != props.onScrollEnd &&
		        listenToNonDelegatedEvent("scrollend", instance),
		      null != props.onClick && (instance.onclick = noop$1),
		      (instance = true))
		    : (instance = false);
		  instance || throwOnHydrationMismatch(fiber);
		}
		function popToNextHostParent(fiber) {
		  for (hydrationParentFiber = fiber.return; hydrationParentFiber; )
		    switch (hydrationParentFiber.tag) {
		      case 5:
		      case 13:
		        rootOrSingletonContext = false;
		        return;
		      case 27:
		      case 3:
		        rootOrSingletonContext = true;
		        return;
		      default:
		        hydrationParentFiber = hydrationParentFiber.return;
		    }
		}
		function popHydrationState(fiber) {
		  if (fiber !== hydrationParentFiber) return false;
		  if (!isHydrating) return popToNextHostParent(fiber), (isHydrating = true), false;
		  var tag = fiber.tag,
		    JSCompiler_temp;
		  if ((JSCompiler_temp = 3 !== tag && 27 !== tag)) {
		    if ((JSCompiler_temp = 5 === tag))
		      (JSCompiler_temp = fiber.type),
		        (JSCompiler_temp =
		          !("form" !== JSCompiler_temp && "button" !== JSCompiler_temp) ||
		          shouldSetTextContent(fiber.type, fiber.memoizedProps));
		    JSCompiler_temp = !JSCompiler_temp;
		  }
		  JSCompiler_temp && nextHydratableInstance && throwOnHydrationMismatch(fiber);
		  popToNextHostParent(fiber);
		  if (13 === tag) {
		    fiber = fiber.memoizedState;
		    fiber = null !== fiber ? fiber.dehydrated : null;
		    if (!fiber) throw Error(formatProdErrorMessage(317));
		    a: {
		      fiber = fiber.nextSibling;
		      for (tag = 0; fiber; ) {
		        if (8 === fiber.nodeType)
		          if (((JSCompiler_temp = fiber.data), "/$" === JSCompiler_temp)) {
		            if (0 === tag) {
		              nextHydratableInstance = getNextHydratable(fiber.nextSibling);
		              break a;
		            }
		            tag--;
		          } else
		            ("$" !== JSCompiler_temp &&
		              "$!" !== JSCompiler_temp &&
		              "$?" !== JSCompiler_temp) ||
		              tag++;
		        fiber = fiber.nextSibling;
		      }
		      nextHydratableInstance = null;
		    }
		  } else
		    27 === tag
		      ? ((tag = nextHydratableInstance),
		        isSingletonScope(fiber.type)
		          ? ((fiber = previousHydratableOnEnteringScopedSingleton),
		            (previousHydratableOnEnteringScopedSingleton = null),
		            (nextHydratableInstance = fiber))
		          : (nextHydratableInstance = tag))
		      : (nextHydratableInstance = hydrationParentFiber
		          ? getNextHydratable(fiber.stateNode.nextSibling)
		          : null);
		  return true;
		}
		function resetHydrationState() {
		  nextHydratableInstance = hydrationParentFiber = null;
		  isHydrating = false;
		}
		function upgradeHydrationErrorsToRecoverable() {
		  var queuedErrors = hydrationErrors;
		  null !== queuedErrors &&
		    (null === workInProgressRootRecoverableErrors
		      ? (workInProgressRootRecoverableErrors = queuedErrors)
		      : workInProgressRootRecoverableErrors.push.apply(
		          workInProgressRootRecoverableErrors,
		          queuedErrors
		        ),
		    (hydrationErrors = null));
		  return queuedErrors;
		}
		function queueHydrationError(error) {
		  null === hydrationErrors
		    ? (hydrationErrors = [error])
		    : hydrationErrors.push(error);
		}
		var valueCursor = createCursor(null),
		  currentlyRenderingFiber$1 = null,
		  lastContextDependency = null;
		function pushProvider(providerFiber, context, nextValue) {
		  push(valueCursor, context._currentValue);
		  context._currentValue = nextValue;
		}
		function popProvider(context) {
		  context._currentValue = valueCursor.current;
		  pop(valueCursor);
		}
		function scheduleContextWorkOnParentPath(parent, renderLanes, propagationRoot) {
		  for (; null !== parent; ) {
		    var alternate = parent.alternate;
		    (parent.childLanes & renderLanes) !== renderLanes
		      ? ((parent.childLanes |= renderLanes),
		        null !== alternate && (alternate.childLanes |= renderLanes))
		      : null !== alternate &&
		        (alternate.childLanes & renderLanes) !== renderLanes &&
		        (alternate.childLanes |= renderLanes);
		    if (parent === propagationRoot) break;
		    parent = parent.return;
		  }
		}
		function propagateContextChanges(
		  workInProgress,
		  contexts,
		  renderLanes,
		  forcePropagateEntireTree
		) {
		  var fiber = workInProgress.child;
		  null !== fiber && (fiber.return = workInProgress);
		  for (; null !== fiber; ) {
		    var list = fiber.dependencies;
		    if (null !== list) {
		      var nextFiber = fiber.child;
		      list = list.firstContext;
		      a: for (; null !== list; ) {
		        var dependency = list;
		        list = fiber;
		        for (var i = 0; i < contexts.length; i++)
		          if (dependency.context === contexts[i]) {
		            list.lanes |= renderLanes;
		            dependency = list.alternate;
		            null !== dependency && (dependency.lanes |= renderLanes);
		            scheduleContextWorkOnParentPath(
		              list.return,
		              renderLanes,
		              workInProgress
		            );
		            forcePropagateEntireTree || (nextFiber = null);
		            break a;
		          }
		        list = dependency.next;
		      }
		    } else if (18 === fiber.tag) {
		      nextFiber = fiber.return;
		      if (null === nextFiber) throw Error(formatProdErrorMessage(341));
		      nextFiber.lanes |= renderLanes;
		      list = nextFiber.alternate;
		      null !== list && (list.lanes |= renderLanes);
		      scheduleContextWorkOnParentPath(nextFiber, renderLanes, workInProgress);
		      nextFiber = null;
		    } else nextFiber = fiber.child;
		    if (null !== nextFiber) nextFiber.return = fiber;
		    else
		      for (nextFiber = fiber; null !== nextFiber; ) {
		        if (nextFiber === workInProgress) {
		          nextFiber = null;
		          break;
		        }
		        fiber = nextFiber.sibling;
		        if (null !== fiber) {
		          fiber.return = nextFiber.return;
		          nextFiber = fiber;
		          break;
		        }
		        nextFiber = nextFiber.return;
		      }
		    fiber = nextFiber;
		  }
		}
		function propagateParentContextChanges(
		  current,
		  workInProgress,
		  renderLanes,
		  forcePropagateEntireTree
		) {
		  current = null;
		  for (
		    var parent = workInProgress, isInsidePropagationBailout = false;
		    null !== parent;

		  ) {
		    if (!isInsidePropagationBailout)
		      if (0 !== (parent.flags & 524288)) isInsidePropagationBailout = true;
		      else if (0 !== (parent.flags & 262144)) break;
		    if (10 === parent.tag) {
		      var currentParent = parent.alternate;
		      if (null === currentParent) throw Error(formatProdErrorMessage(387));
		      currentParent = currentParent.memoizedProps;
		      if (null !== currentParent) {
		        var context = parent.type;
		        objectIs(parent.pendingProps.value, currentParent.value) ||
		          (null !== current ? current.push(context) : (current = [context]));
		      }
		    } else if (parent === hostTransitionProviderCursor.current) {
		      currentParent = parent.alternate;
		      if (null === currentParent) throw Error(formatProdErrorMessage(387));
		      currentParent.memoizedState.memoizedState !==
		        parent.memoizedState.memoizedState &&
		        (null !== current
		          ? current.push(HostTransitionContext)
		          : (current = [HostTransitionContext]));
		    }
		    parent = parent.return;
		  }
		  null !== current &&
		    propagateContextChanges(
		      workInProgress,
		      current,
		      renderLanes,
		      forcePropagateEntireTree
		    );
		  workInProgress.flags |= 262144;
		}
		function checkIfContextChanged(currentDependencies) {
		  for (
		    currentDependencies = currentDependencies.firstContext;
		    null !== currentDependencies;

		  ) {
		    if (
		      !objectIs(
		        currentDependencies.context._currentValue,
		        currentDependencies.memoizedValue
		      )
		    )
		      return true;
		    currentDependencies = currentDependencies.next;
		  }
		  return false;
		}
		function prepareToReadContext(workInProgress) {
		  currentlyRenderingFiber$1 = workInProgress;
		  lastContextDependency = null;
		  workInProgress = workInProgress.dependencies;
		  null !== workInProgress && (workInProgress.firstContext = null);
		}
		function readContext(context) {
		  return readContextForConsumer(currentlyRenderingFiber$1, context);
		}
		function readContextDuringReconciliation(consumer, context) {
		  null === currentlyRenderingFiber$1 && prepareToReadContext(consumer);
		  return readContextForConsumer(consumer, context);
		}
		function readContextForConsumer(consumer, context) {
		  var value = context._currentValue;
		  context = { context: context, memoizedValue: value, next: null };
		  if (null === lastContextDependency) {
		    if (null === consumer) throw Error(formatProdErrorMessage(308));
		    lastContextDependency = context;
		    consumer.dependencies = { lanes: 0, firstContext: context };
		    consumer.flags |= 524288;
		  } else lastContextDependency = lastContextDependency.next = context;
		  return value;
		}
		var AbortControllerLocal =
		    "undefined" !== typeof AbortController
		      ? AbortController
		      : function () {
		          var listeners = [],
		            signal = (this.signal = {
		              aborted: false,
		              addEventListener: function (type, listener) {
		                listeners.push(listener);
		              }
		            });
		          this.abort = function () {
		            signal.aborted = true;
		            listeners.forEach(function (listener) {
		              return listener();
		            });
		          };
		        },
		  scheduleCallback$2 = Scheduler.unstable_scheduleCallback,
		  NormalPriority = Scheduler.unstable_NormalPriority,
		  CacheContext = {
		    $$typeof: REACT_CONTEXT_TYPE,
		    Consumer: null,
		    Provider: null,
		    _currentValue: null,
		    _currentValue2: null,
		    _threadCount: 0
		  };
		function createCache() {
		  return {
		    controller: new AbortControllerLocal(),
		    data: new Map(),
		    refCount: 0
		  };
		}
		function releaseCache(cache) {
		  cache.refCount--;
		  0 === cache.refCount &&
		    scheduleCallback$2(NormalPriority, function () {
		      cache.controller.abort();
		    });
		}
		var currentEntangledListeners = null,
		  currentEntangledPendingCount = 0,
		  currentEntangledLane = 0,
		  currentEntangledActionThenable = null;
		function entangleAsyncAction(transition, thenable) {
		  if (null === currentEntangledListeners) {
		    var entangledListeners = (currentEntangledListeners = []);
		    currentEntangledPendingCount = 0;
		    currentEntangledLane = requestTransitionLane();
		    currentEntangledActionThenable = {
		      status: "pending",
		      value: void 0,
		      then: function (resolve) {
		        entangledListeners.push(resolve);
		      }
		    };
		  }
		  currentEntangledPendingCount++;
		  thenable.then(pingEngtangledActionScope, pingEngtangledActionScope);
		  return thenable;
		}
		function pingEngtangledActionScope() {
		  if (
		    0 === --currentEntangledPendingCount &&
		    null !== currentEntangledListeners
		  ) {
		    null !== currentEntangledActionThenable &&
		      (currentEntangledActionThenable.status = "fulfilled");
		    var listeners = currentEntangledListeners;
		    currentEntangledListeners = null;
		    currentEntangledLane = 0;
		    currentEntangledActionThenable = null;
		    for (var i = 0; i < listeners.length; i++) (0, listeners[i])();
		  }
		}
		function chainThenableValue(thenable, result) {
		  var listeners = [],
		    thenableWithOverride = {
		      status: "pending",
		      value: null,
		      reason: null,
		      then: function (resolve) {
		        listeners.push(resolve);
		      }
		    };
		  thenable.then(
		    function () {
		      thenableWithOverride.status = "fulfilled";
		      thenableWithOverride.value = result;
		      for (var i = 0; i < listeners.length; i++) (0, listeners[i])(result);
		    },
		    function (error) {
		      thenableWithOverride.status = "rejected";
		      thenableWithOverride.reason = error;
		      for (error = 0; error < listeners.length; error++)
		        (0, listeners[error])(void 0);
		    }
		  );
		  return thenableWithOverride;
		}
		var prevOnStartTransitionFinish = ReactSharedInternals.S;
		ReactSharedInternals.S = function (transition, returnValue) {
		  "object" === typeof returnValue &&
		    null !== returnValue &&
		    "function" === typeof returnValue.then &&
		    entangleAsyncAction(transition, returnValue);
		  null !== prevOnStartTransitionFinish &&
		    prevOnStartTransitionFinish(transition, returnValue);
		};
		var resumedCache = createCursor(null);
		function peekCacheFromPool() {
		  var cacheResumedFromPreviousRender = resumedCache.current;
		  return null !== cacheResumedFromPreviousRender
		    ? cacheResumedFromPreviousRender
		    : workInProgressRoot.pooledCache;
		}
		function pushTransition(offscreenWorkInProgress, prevCachePool) {
		  null === prevCachePool
		    ? push(resumedCache, resumedCache.current)
		    : push(resumedCache, prevCachePool.pool);
		}
		function getSuspendedCache() {
		  var cacheFromPool = peekCacheFromPool();
		  return null === cacheFromPool
		    ? null
		    : { parent: CacheContext._currentValue, pool: cacheFromPool };
		}
		var SuspenseException = Error(formatProdErrorMessage(460)),
		  SuspenseyCommitException = Error(formatProdErrorMessage(474)),
		  SuspenseActionException = Error(formatProdErrorMessage(542)),
		  noopSuspenseyCommitThenable = { then: function () {} };
		function isThenableResolved(thenable) {
		  thenable = thenable.status;
		  return "fulfilled" === thenable || "rejected" === thenable;
		}
		function noop$3() {}
		function trackUsedThenable(thenableState, thenable, index) {
		  index = thenableState[index];
		  void 0 === index
		    ? thenableState.push(thenable)
		    : index !== thenable && (thenable.then(noop$3, noop$3), (thenable = index));
		  switch (thenable.status) {
		    case "fulfilled":
		      return thenable.value;
		    case "rejected":
		      throw (
		        ((thenableState = thenable.reason),
		        checkIfUseWrappedInAsyncCatch(thenableState),
		        thenableState)
		      );
		    default:
		      if ("string" === typeof thenable.status) thenable.then(noop$3, noop$3);
		      else {
		        thenableState = workInProgressRoot;
		        if (null !== thenableState && 100 < thenableState.shellSuspendCounter)
		          throw Error(formatProdErrorMessage(482));
		        thenableState = thenable;
		        thenableState.status = "pending";
		        thenableState.then(
		          function (fulfilledValue) {
		            if ("pending" === thenable.status) {
		              var fulfilledThenable = thenable;
		              fulfilledThenable.status = "fulfilled";
		              fulfilledThenable.value = fulfilledValue;
		            }
		          },
		          function (error) {
		            if ("pending" === thenable.status) {
		              var rejectedThenable = thenable;
		              rejectedThenable.status = "rejected";
		              rejectedThenable.reason = error;
		            }
		          }
		        );
		      }
		      switch (thenable.status) {
		        case "fulfilled":
		          return thenable.value;
		        case "rejected":
		          throw (
		            ((thenableState = thenable.reason),
		            checkIfUseWrappedInAsyncCatch(thenableState),
		            thenableState)
		          );
		      }
		      suspendedThenable = thenable;
		      throw SuspenseException;
		  }
		}
		var suspendedThenable = null;
		function getSuspendedThenable() {
		  if (null === suspendedThenable) throw Error(formatProdErrorMessage(459));
		  var thenable = suspendedThenable;
		  suspendedThenable = null;
		  return thenable;
		}
		function checkIfUseWrappedInAsyncCatch(rejectedReason) {
		  if (
		    rejectedReason === SuspenseException ||
		    rejectedReason === SuspenseActionException
		  )
		    throw Error(formatProdErrorMessage(483));
		}
		var hasForceUpdate = false;
		function initializeUpdateQueue(fiber) {
		  fiber.updateQueue = {
		    baseState: fiber.memoizedState,
		    firstBaseUpdate: null,
		    lastBaseUpdate: null,
		    shared: { pending: null, lanes: 0, hiddenCallbacks: null },
		    callbacks: null
		  };
		}
		function cloneUpdateQueue(current, workInProgress) {
		  current = current.updateQueue;
		  workInProgress.updateQueue === current &&
		    (workInProgress.updateQueue = {
		      baseState: current.baseState,
		      firstBaseUpdate: current.firstBaseUpdate,
		      lastBaseUpdate: current.lastBaseUpdate,
		      shared: current.shared,
		      callbacks: null
		    });
		}
		function createUpdate(lane) {
		  return { lane: lane, tag: 0, payload: null, callback: null, next: null };
		}
		function enqueueUpdate(fiber, update, lane) {
		  var updateQueue = fiber.updateQueue;
		  if (null === updateQueue) return null;
		  updateQueue = updateQueue.shared;
		  if (0 !== (executionContext & 2)) {
		    var pending = updateQueue.pending;
		    null === pending
		      ? (update.next = update)
		      : ((update.next = pending.next), (pending.next = update));
		    updateQueue.pending = update;
		    update = getRootForUpdatedFiber(fiber);
		    markUpdateLaneFromFiberToRoot(fiber, null, lane);
		    return update;
		  }
		  enqueueUpdate$1(fiber, updateQueue, update, lane);
		  return getRootForUpdatedFiber(fiber);
		}
		function entangleTransitions(root, fiber, lane) {
		  fiber = fiber.updateQueue;
		  if (null !== fiber && ((fiber = fiber.shared), 0 !== (lane & 4194048))) {
		    var queueLanes = fiber.lanes;
		    queueLanes &= root.pendingLanes;
		    lane |= queueLanes;
		    fiber.lanes = lane;
		    markRootEntangled(root, lane);
		  }
		}
		function enqueueCapturedUpdate(workInProgress, capturedUpdate) {
		  var queue = workInProgress.updateQueue,
		    current = workInProgress.alternate;
		  if (
		    null !== current &&
		    ((current = current.updateQueue), queue === current)
		  ) {
		    var newFirst = null,
		      newLast = null;
		    queue = queue.firstBaseUpdate;
		    if (null !== queue) {
		      do {
		        var clone = {
		          lane: queue.lane,
		          tag: queue.tag,
		          payload: queue.payload,
		          callback: null,
		          next: null
		        };
		        null === newLast
		          ? (newFirst = newLast = clone)
		          : (newLast = newLast.next = clone);
		        queue = queue.next;
		      } while (null !== queue);
		      null === newLast
		        ? (newFirst = newLast = capturedUpdate)
		        : (newLast = newLast.next = capturedUpdate);
		    } else newFirst = newLast = capturedUpdate;
		    queue = {
		      baseState: current.baseState,
		      firstBaseUpdate: newFirst,
		      lastBaseUpdate: newLast,
		      shared: current.shared,
		      callbacks: current.callbacks
		    };
		    workInProgress.updateQueue = queue;
		    return;
		  }
		  workInProgress = queue.lastBaseUpdate;
		  null === workInProgress
		    ? (queue.firstBaseUpdate = capturedUpdate)
		    : (workInProgress.next = capturedUpdate);
		  queue.lastBaseUpdate = capturedUpdate;
		}
		var didReadFromEntangledAsyncAction = false;
		function suspendIfUpdateReadFromEntangledAsyncAction() {
		  if (didReadFromEntangledAsyncAction) {
		    var entangledActionThenable = currentEntangledActionThenable;
		    if (null !== entangledActionThenable) throw entangledActionThenable;
		  }
		}
		function processUpdateQueue(
		  workInProgress$jscomp$0,
		  props,
		  instance$jscomp$0,
		  renderLanes
		) {
		  didReadFromEntangledAsyncAction = false;
		  var queue = workInProgress$jscomp$0.updateQueue;
		  hasForceUpdate = false;
		  var firstBaseUpdate = queue.firstBaseUpdate,
		    lastBaseUpdate = queue.lastBaseUpdate,
		    pendingQueue = queue.shared.pending;
		  if (null !== pendingQueue) {
		    queue.shared.pending = null;
		    var lastPendingUpdate = pendingQueue,
		      firstPendingUpdate = lastPendingUpdate.next;
		    lastPendingUpdate.next = null;
		    null === lastBaseUpdate
		      ? (firstBaseUpdate = firstPendingUpdate)
		      : (lastBaseUpdate.next = firstPendingUpdate);
		    lastBaseUpdate = lastPendingUpdate;
		    var current = workInProgress$jscomp$0.alternate;
		    null !== current &&
		      ((current = current.updateQueue),
		      (pendingQueue = current.lastBaseUpdate),
		      pendingQueue !== lastBaseUpdate &&
		        (null === pendingQueue
		          ? (current.firstBaseUpdate = firstPendingUpdate)
		          : (pendingQueue.next = firstPendingUpdate),
		        (current.lastBaseUpdate = lastPendingUpdate)));
		  }
		  if (null !== firstBaseUpdate) {
		    var newState = queue.baseState;
		    lastBaseUpdate = 0;
		    current = firstPendingUpdate = lastPendingUpdate = null;
		    pendingQueue = firstBaseUpdate;
		    do {
		      var updateLane = pendingQueue.lane & -536870913,
		        isHiddenUpdate = updateLane !== pendingQueue.lane;
		      if (
		        isHiddenUpdate
		          ? (workInProgressRootRenderLanes & updateLane) === updateLane
		          : (renderLanes & updateLane) === updateLane
		      ) {
		        0 !== updateLane &&
		          updateLane === currentEntangledLane &&
		          (didReadFromEntangledAsyncAction = true);
		        null !== current &&
		          (current = current.next =
		            {
		              lane: 0,
		              tag: pendingQueue.tag,
		              payload: pendingQueue.payload,
		              callback: null,
		              next: null
		            });
		        a: {
		          var workInProgress = workInProgress$jscomp$0,
		            update = pendingQueue;
		          updateLane = props;
		          var instance = instance$jscomp$0;
		          switch (update.tag) {
		            case 1:
		              workInProgress = update.payload;
		              if ("function" === typeof workInProgress) {
		                newState = workInProgress.call(instance, newState, updateLane);
		                break a;
		              }
		              newState = workInProgress;
		              break a;
		            case 3:
		              workInProgress.flags = (workInProgress.flags & -65537) | 128;
		            case 0:
		              workInProgress = update.payload;
		              updateLane =
		                "function" === typeof workInProgress
		                  ? workInProgress.call(instance, newState, updateLane)
		                  : workInProgress;
		              if (null === updateLane || void 0 === updateLane) break a;
		              newState = assign({}, newState, updateLane);
		              break a;
		            case 2:
		              hasForceUpdate = true;
		          }
		        }
		        updateLane = pendingQueue.callback;
		        null !== updateLane &&
		          ((workInProgress$jscomp$0.flags |= 64),
		          isHiddenUpdate && (workInProgress$jscomp$0.flags |= 8192),
		          (isHiddenUpdate = queue.callbacks),
		          null === isHiddenUpdate
		            ? (queue.callbacks = [updateLane])
		            : isHiddenUpdate.push(updateLane));
		      } else
		        (isHiddenUpdate = {
		          lane: updateLane,
		          tag: pendingQueue.tag,
		          payload: pendingQueue.payload,
		          callback: pendingQueue.callback,
		          next: null
		        }),
		          null === current
		            ? ((firstPendingUpdate = current = isHiddenUpdate),
		              (lastPendingUpdate = newState))
		            : (current = current.next = isHiddenUpdate),
		          (lastBaseUpdate |= updateLane);
		      pendingQueue = pendingQueue.next;
		      if (null === pendingQueue)
		        if (((pendingQueue = queue.shared.pending), null === pendingQueue))
		          break;
		        else
		          (isHiddenUpdate = pendingQueue),
		            (pendingQueue = isHiddenUpdate.next),
		            (isHiddenUpdate.next = null),
		            (queue.lastBaseUpdate = isHiddenUpdate),
		            (queue.shared.pending = null);
		    } while (1);
		    null === current && (lastPendingUpdate = newState);
		    queue.baseState = lastPendingUpdate;
		    queue.firstBaseUpdate = firstPendingUpdate;
		    queue.lastBaseUpdate = current;
		    null === firstBaseUpdate && (queue.shared.lanes = 0);
		    workInProgressRootSkippedLanes |= lastBaseUpdate;
		    workInProgress$jscomp$0.lanes = lastBaseUpdate;
		    workInProgress$jscomp$0.memoizedState = newState;
		  }
		}
		function callCallback(callback, context) {
		  if ("function" !== typeof callback)
		    throw Error(formatProdErrorMessage(191, callback));
		  callback.call(context);
		}
		function commitCallbacks(updateQueue, context) {
		  var callbacks = updateQueue.callbacks;
		  if (null !== callbacks)
		    for (
		      updateQueue.callbacks = null, updateQueue = 0;
		      updateQueue < callbacks.length;
		      updateQueue++
		    )
		      callCallback(callbacks[updateQueue], context);
		}
		var currentTreeHiddenStackCursor = createCursor(null),
		  prevEntangledRenderLanesCursor = createCursor(0);
		function pushHiddenContext(fiber, context) {
		  fiber = entangledRenderLanes;
		  push(prevEntangledRenderLanesCursor, fiber);
		  push(currentTreeHiddenStackCursor, context);
		  entangledRenderLanes = fiber | context.baseLanes;
		}
		function reuseHiddenContextOnStack() {
		  push(prevEntangledRenderLanesCursor, entangledRenderLanes);
		  push(currentTreeHiddenStackCursor, currentTreeHiddenStackCursor.current);
		}
		function popHiddenContext() {
		  entangledRenderLanes = prevEntangledRenderLanesCursor.current;
		  pop(currentTreeHiddenStackCursor);
		  pop(prevEntangledRenderLanesCursor);
		}
		var renderLanes = 0,
		  currentlyRenderingFiber = null,
		  currentHook = null,
		  workInProgressHook = null,
		  didScheduleRenderPhaseUpdate = false,
		  didScheduleRenderPhaseUpdateDuringThisPass = false,
		  shouldDoubleInvokeUserFnsInHooksDEV = false,
		  localIdCounter = 0,
		  thenableIndexCounter$1 = 0,
		  thenableState$1 = null,
		  globalClientIdCounter = 0;
		function throwInvalidHookError() {
		  throw Error(formatProdErrorMessage(321));
		}
		function areHookInputsEqual(nextDeps, prevDeps) {
		  if (null === prevDeps) return false;
		  for (var i = 0; i < prevDeps.length && i < nextDeps.length; i++)
		    if (!objectIs(nextDeps[i], prevDeps[i])) return false;
		  return true;
		}
		function renderWithHooks(
		  current,
		  workInProgress,
		  Component,
		  props,
		  secondArg,
		  nextRenderLanes
		) {
		  renderLanes = nextRenderLanes;
		  currentlyRenderingFiber = workInProgress;
		  workInProgress.memoizedState = null;
		  workInProgress.updateQueue = null;
		  workInProgress.lanes = 0;
		  ReactSharedInternals.H =
		    null === current || null === current.memoizedState
		      ? HooksDispatcherOnMount
		      : HooksDispatcherOnUpdate;
		  shouldDoubleInvokeUserFnsInHooksDEV = false;
		  nextRenderLanes = Component(props, secondArg);
		  shouldDoubleInvokeUserFnsInHooksDEV = false;
		  didScheduleRenderPhaseUpdateDuringThisPass &&
		    (nextRenderLanes = renderWithHooksAgain(
		      workInProgress,
		      Component,
		      props,
		      secondArg
		    ));
		  finishRenderingHooks(current);
		  return nextRenderLanes;
		}
		function finishRenderingHooks(current) {
		  ReactSharedInternals.H = ContextOnlyDispatcher;
		  var didRenderTooFewHooks = null !== currentHook && null !== currentHook.next;
		  renderLanes = 0;
		  workInProgressHook = currentHook = currentlyRenderingFiber = null;
		  didScheduleRenderPhaseUpdate = false;
		  thenableIndexCounter$1 = 0;
		  thenableState$1 = null;
		  if (didRenderTooFewHooks) throw Error(formatProdErrorMessage(300));
		  null === current ||
		    didReceiveUpdate ||
		    ((current = current.dependencies),
		    null !== current &&
		      checkIfContextChanged(current) &&
		      (didReceiveUpdate = true));
		}
		function renderWithHooksAgain(workInProgress, Component, props, secondArg) {
		  currentlyRenderingFiber = workInProgress;
		  var numberOfReRenders = 0;
		  do {
		    didScheduleRenderPhaseUpdateDuringThisPass && (thenableState$1 = null);
		    thenableIndexCounter$1 = 0;
		    didScheduleRenderPhaseUpdateDuringThisPass = false;
		    if (25 <= numberOfReRenders) throw Error(formatProdErrorMessage(301));
		    numberOfReRenders += 1;
		    workInProgressHook = currentHook = null;
		    if (null != workInProgress.updateQueue) {
		      var children = workInProgress.updateQueue;
		      children.lastEffect = null;
		      children.events = null;
		      children.stores = null;
		      null != children.memoCache && (children.memoCache.index = 0);
		    }
		    ReactSharedInternals.H = HooksDispatcherOnRerender;
		    children = Component(props, secondArg);
		  } while (didScheduleRenderPhaseUpdateDuringThisPass);
		  return children;
		}
		function TransitionAwareHostComponent() {
		  var dispatcher = ReactSharedInternals.H,
		    maybeThenable = dispatcher.useState()[0];
		  maybeThenable =
		    "function" === typeof maybeThenable.then
		      ? useThenable(maybeThenable)
		      : maybeThenable;
		  dispatcher = dispatcher.useState()[0];
		  (null !== currentHook ? currentHook.memoizedState : null) !== dispatcher &&
		    (currentlyRenderingFiber.flags |= 1024);
		  return maybeThenable;
		}
		function checkDidRenderIdHook() {
		  var didRenderIdHook = 0 !== localIdCounter;
		  localIdCounter = 0;
		  return didRenderIdHook;
		}
		function bailoutHooks(current, workInProgress, lanes) {
		  workInProgress.updateQueue = current.updateQueue;
		  workInProgress.flags &= -2053;
		  current.lanes &= ~lanes;
		}
		function resetHooksOnUnwind(workInProgress) {
		  if (didScheduleRenderPhaseUpdate) {
		    for (
		      workInProgress = workInProgress.memoizedState;
		      null !== workInProgress;

		    ) {
		      var queue = workInProgress.queue;
		      null !== queue && (queue.pending = null);
		      workInProgress = workInProgress.next;
		    }
		    didScheduleRenderPhaseUpdate = false;
		  }
		  renderLanes = 0;
		  workInProgressHook = currentHook = currentlyRenderingFiber = null;
		  didScheduleRenderPhaseUpdateDuringThisPass = false;
		  thenableIndexCounter$1 = localIdCounter = 0;
		  thenableState$1 = null;
		}
		function mountWorkInProgressHook() {
		  var hook = {
		    memoizedState: null,
		    baseState: null,
		    baseQueue: null,
		    queue: null,
		    next: null
		  };
		  null === workInProgressHook
		    ? (currentlyRenderingFiber.memoizedState = workInProgressHook = hook)
		    : (workInProgressHook = workInProgressHook.next = hook);
		  return workInProgressHook;
		}
		function updateWorkInProgressHook() {
		  if (null === currentHook) {
		    var nextCurrentHook = currentlyRenderingFiber.alternate;
		    nextCurrentHook =
		      null !== nextCurrentHook ? nextCurrentHook.memoizedState : null;
		  } else nextCurrentHook = currentHook.next;
		  var nextWorkInProgressHook =
		    null === workInProgressHook
		      ? currentlyRenderingFiber.memoizedState
		      : workInProgressHook.next;
		  if (null !== nextWorkInProgressHook)
		    (workInProgressHook = nextWorkInProgressHook),
		      (currentHook = nextCurrentHook);
		  else {
		    if (null === nextCurrentHook) {
		      if (null === currentlyRenderingFiber.alternate)
		        throw Error(formatProdErrorMessage(467));
		      throw Error(formatProdErrorMessage(310));
		    }
		    currentHook = nextCurrentHook;
		    nextCurrentHook = {
		      memoizedState: currentHook.memoizedState,
		      baseState: currentHook.baseState,
		      baseQueue: currentHook.baseQueue,
		      queue: currentHook.queue,
		      next: null
		    };
		    null === workInProgressHook
		      ? (currentlyRenderingFiber.memoizedState = workInProgressHook =
		          nextCurrentHook)
		      : (workInProgressHook = workInProgressHook.next = nextCurrentHook);
		  }
		  return workInProgressHook;
		}
		function createFunctionComponentUpdateQueue() {
		  return { lastEffect: null, events: null, stores: null, memoCache: null };
		}
		function useThenable(thenable) {
		  var index = thenableIndexCounter$1;
		  thenableIndexCounter$1 += 1;
		  null === thenableState$1 && (thenableState$1 = []);
		  thenable = trackUsedThenable(thenableState$1, thenable, index);
		  index = currentlyRenderingFiber;
		  null ===
		    (null === workInProgressHook
		      ? index.memoizedState
		      : workInProgressHook.next) &&
		    ((index = index.alternate),
		    (ReactSharedInternals.H =
		      null === index || null === index.memoizedState
		        ? HooksDispatcherOnMount
		        : HooksDispatcherOnUpdate));
		  return thenable;
		}
		function use(usable) {
		  if (null !== usable && "object" === typeof usable) {
		    if ("function" === typeof usable.then) return useThenable(usable);
		    if (usable.$$typeof === REACT_CONTEXT_TYPE) return readContext(usable);
		  }
		  throw Error(formatProdErrorMessage(438, String(usable)));
		}
		function useMemoCache(size) {
		  var memoCache = null,
		    updateQueue = currentlyRenderingFiber.updateQueue;
		  null !== updateQueue && (memoCache = updateQueue.memoCache);
		  if (null == memoCache) {
		    var current = currentlyRenderingFiber.alternate;
		    null !== current &&
		      ((current = current.updateQueue),
		      null !== current &&
		        ((current = current.memoCache),
		        null != current &&
		          (memoCache = {
		            data: current.data.map(function (array) {
		              return array.slice();
		            }),
		            index: 0
		          })));
		  }
		  null == memoCache && (memoCache = { data: [], index: 0 });
		  null === updateQueue &&
		    ((updateQueue = createFunctionComponentUpdateQueue()),
		    (currentlyRenderingFiber.updateQueue = updateQueue));
		  updateQueue.memoCache = memoCache;
		  updateQueue = memoCache.data[memoCache.index];
		  if (void 0 === updateQueue)
		    for (
		      updateQueue = memoCache.data[memoCache.index] = Array(size), current = 0;
		      current < size;
		      current++
		    )
		      updateQueue[current] = REACT_MEMO_CACHE_SENTINEL;
		  memoCache.index++;
		  return updateQueue;
		}
		function basicStateReducer(state, action) {
		  return "function" === typeof action ? action(state) : action;
		}
		function updateReducer(reducer) {
		  var hook = updateWorkInProgressHook();
		  return updateReducerImpl(hook, currentHook, reducer);
		}
		function updateReducerImpl(hook, current, reducer) {
		  var queue = hook.queue;
		  if (null === queue) throw Error(formatProdErrorMessage(311));
		  queue.lastRenderedReducer = reducer;
		  var baseQueue = hook.baseQueue,
		    pendingQueue = queue.pending;
		  if (null !== pendingQueue) {
		    if (null !== baseQueue) {
		      var baseFirst = baseQueue.next;
		      baseQueue.next = pendingQueue.next;
		      pendingQueue.next = baseFirst;
		    }
		    current.baseQueue = baseQueue = pendingQueue;
		    queue.pending = null;
		  }
		  pendingQueue = hook.baseState;
		  if (null === baseQueue) hook.memoizedState = pendingQueue;
		  else {
		    current = baseQueue.next;
		    var newBaseQueueFirst = (baseFirst = null),
		      newBaseQueueLast = null,
		      update = current,
		      didReadFromEntangledAsyncAction$32 = false;
		    do {
		      var updateLane = update.lane & -536870913;
		      if (
		        updateLane !== update.lane
		          ? (workInProgressRootRenderLanes & updateLane) === updateLane
		          : (renderLanes & updateLane) === updateLane
		      ) {
		        var revertLane = update.revertLane;
		        if (0 === revertLane)
		          null !== newBaseQueueLast &&
		            (newBaseQueueLast = newBaseQueueLast.next =
		              {
		                lane: 0,
		                revertLane: 0,
		                action: update.action,
		                hasEagerState: update.hasEagerState,
		                eagerState: update.eagerState,
		                next: null
		              }),
		            updateLane === currentEntangledLane &&
		              (didReadFromEntangledAsyncAction$32 = true);
		        else if ((renderLanes & revertLane) === revertLane) {
		          update = update.next;
		          revertLane === currentEntangledLane &&
		            (didReadFromEntangledAsyncAction$32 = true);
		          continue;
		        } else
		          (updateLane = {
		            lane: 0,
		            revertLane: update.revertLane,
		            action: update.action,
		            hasEagerState: update.hasEagerState,
		            eagerState: update.eagerState,
		            next: null
		          }),
		            null === newBaseQueueLast
		              ? ((newBaseQueueFirst = newBaseQueueLast = updateLane),
		                (baseFirst = pendingQueue))
		              : (newBaseQueueLast = newBaseQueueLast.next = updateLane),
		            (currentlyRenderingFiber.lanes |= revertLane),
		            (workInProgressRootSkippedLanes |= revertLane);
		        updateLane = update.action;
		        shouldDoubleInvokeUserFnsInHooksDEV &&
		          reducer(pendingQueue, updateLane);
		        pendingQueue = update.hasEagerState
		          ? update.eagerState
		          : reducer(pendingQueue, updateLane);
		      } else
		        (revertLane = {
		          lane: updateLane,
		          revertLane: update.revertLane,
		          action: update.action,
		          hasEagerState: update.hasEagerState,
		          eagerState: update.eagerState,
		          next: null
		        }),
		          null === newBaseQueueLast
		            ? ((newBaseQueueFirst = newBaseQueueLast = revertLane),
		              (baseFirst = pendingQueue))
		            : (newBaseQueueLast = newBaseQueueLast.next = revertLane),
		          (currentlyRenderingFiber.lanes |= updateLane),
		          (workInProgressRootSkippedLanes |= updateLane);
		      update = update.next;
		    } while (null !== update && update !== current);
		    null === newBaseQueueLast
		      ? (baseFirst = pendingQueue)
		      : (newBaseQueueLast.next = newBaseQueueFirst);
		    if (
		      !objectIs(pendingQueue, hook.memoizedState) &&
		      ((didReceiveUpdate = true),
		      didReadFromEntangledAsyncAction$32 &&
		        ((reducer = currentEntangledActionThenable), null !== reducer))
		    )
		      throw reducer;
		    hook.memoizedState = pendingQueue;
		    hook.baseState = baseFirst;
		    hook.baseQueue = newBaseQueueLast;
		    queue.lastRenderedState = pendingQueue;
		  }
		  null === baseQueue && (queue.lanes = 0);
		  return [hook.memoizedState, queue.dispatch];
		}
		function rerenderReducer(reducer) {
		  var hook = updateWorkInProgressHook(),
		    queue = hook.queue;
		  if (null === queue) throw Error(formatProdErrorMessage(311));
		  queue.lastRenderedReducer = reducer;
		  var dispatch = queue.dispatch,
		    lastRenderPhaseUpdate = queue.pending,
		    newState = hook.memoizedState;
		  if (null !== lastRenderPhaseUpdate) {
		    queue.pending = null;
		    var update = (lastRenderPhaseUpdate = lastRenderPhaseUpdate.next);
		    do (newState = reducer(newState, update.action)), (update = update.next);
		    while (update !== lastRenderPhaseUpdate);
		    objectIs(newState, hook.memoizedState) || (didReceiveUpdate = true);
		    hook.memoizedState = newState;
		    null === hook.baseQueue && (hook.baseState = newState);
		    queue.lastRenderedState = newState;
		  }
		  return [newState, dispatch];
		}
		function updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
		  var fiber = currentlyRenderingFiber,
		    hook = updateWorkInProgressHook(),
		    isHydrating$jscomp$0 = isHydrating;
		  if (isHydrating$jscomp$0) {
		    if (void 0 === getServerSnapshot) throw Error(formatProdErrorMessage(407));
		    getServerSnapshot = getServerSnapshot();
		  } else getServerSnapshot = getSnapshot();
		  var snapshotChanged = !objectIs(
		    (currentHook || hook).memoizedState,
		    getServerSnapshot
		  );
		  snapshotChanged &&
		    ((hook.memoizedState = getServerSnapshot), (didReceiveUpdate = true));
		  hook = hook.queue;
		  var create = subscribeToStore.bind(null, fiber, hook, subscribe);
		  updateEffectImpl(2048, 8, create, [subscribe]);
		  if (
		    hook.getSnapshot !== getSnapshot ||
		    snapshotChanged ||
		    (null !== workInProgressHook && workInProgressHook.memoizedState.tag & 1)
		  ) {
		    fiber.flags |= 2048;
		    pushSimpleEffect(
		      9,
		      createEffectInstance(),
		      updateStoreInstance.bind(
		        null,
		        fiber,
		        hook,
		        getServerSnapshot,
		        getSnapshot
		      ),
		      null
		    );
		    if (null === workInProgressRoot) throw Error(formatProdErrorMessage(349));
		    isHydrating$jscomp$0 ||
		      0 !== (renderLanes & 124) ||
		      pushStoreConsistencyCheck(fiber, getSnapshot, getServerSnapshot);
		  }
		  return getServerSnapshot;
		}
		function pushStoreConsistencyCheck(fiber, getSnapshot, renderedSnapshot) {
		  fiber.flags |= 16384;
		  fiber = { getSnapshot: getSnapshot, value: renderedSnapshot };
		  getSnapshot = currentlyRenderingFiber.updateQueue;
		  null === getSnapshot
		    ? ((getSnapshot = createFunctionComponentUpdateQueue()),
		      (currentlyRenderingFiber.updateQueue = getSnapshot),
		      (getSnapshot.stores = [fiber]))
		    : ((renderedSnapshot = getSnapshot.stores),
		      null === renderedSnapshot
		        ? (getSnapshot.stores = [fiber])
		        : renderedSnapshot.push(fiber));
		}
		function updateStoreInstance(fiber, inst, nextSnapshot, getSnapshot) {
		  inst.value = nextSnapshot;
		  inst.getSnapshot = getSnapshot;
		  checkIfSnapshotChanged(inst) && forceStoreRerender(fiber);
		}
		function subscribeToStore(fiber, inst, subscribe) {
		  return subscribe(function () {
		    checkIfSnapshotChanged(inst) && forceStoreRerender(fiber);
		  });
		}
		function checkIfSnapshotChanged(inst) {
		  var latestGetSnapshot = inst.getSnapshot;
		  inst = inst.value;
		  try {
		    var nextValue = latestGetSnapshot();
		    return !objectIs(inst, nextValue);
		  } catch (error) {
		    return true;
		  }
		}
		function forceStoreRerender(fiber) {
		  var root = enqueueConcurrentRenderForLane(fiber, 2);
		  null !== root && scheduleUpdateOnFiber(root, fiber, 2);
		}
		function mountStateImpl(initialState) {
		  var hook = mountWorkInProgressHook();
		  if ("function" === typeof initialState) {
		    var initialStateInitializer = initialState;
		    initialState = initialStateInitializer();
		    if (shouldDoubleInvokeUserFnsInHooksDEV) {
		      setIsStrictModeForDevtools(true);
		      try {
		        initialStateInitializer();
		      } finally {
		        setIsStrictModeForDevtools(false);
		      }
		    }
		  }
		  hook.memoizedState = hook.baseState = initialState;
		  hook.queue = {
		    pending: null,
		    lanes: 0,
		    dispatch: null,
		    lastRenderedReducer: basicStateReducer,
		    lastRenderedState: initialState
		  };
		  return hook;
		}
		function updateOptimisticImpl(hook, current, passthrough, reducer) {
		  hook.baseState = passthrough;
		  return updateReducerImpl(
		    hook,
		    currentHook,
		    "function" === typeof reducer ? reducer : basicStateReducer
		  );
		}
		function dispatchActionState(
		  fiber,
		  actionQueue,
		  setPendingState,
		  setState,
		  payload
		) {
		  if (isRenderPhaseUpdate(fiber)) throw Error(formatProdErrorMessage(485));
		  fiber = actionQueue.action;
		  if (null !== fiber) {
		    var actionNode = {
		      payload: payload,
		      action: fiber,
		      next: null,
		      isTransition: true,
		      status: "pending",
		      value: null,
		      reason: null,
		      listeners: [],
		      then: function (listener) {
		        actionNode.listeners.push(listener);
		      }
		    };
		    null !== ReactSharedInternals.T
		      ? setPendingState(true)
		      : (actionNode.isTransition = false);
		    setState(actionNode);
		    setPendingState = actionQueue.pending;
		    null === setPendingState
		      ? ((actionNode.next = actionQueue.pending = actionNode),
		        runActionStateAction(actionQueue, actionNode))
		      : ((actionNode.next = setPendingState.next),
		        (actionQueue.pending = setPendingState.next = actionNode));
		  }
		}
		function runActionStateAction(actionQueue, node) {
		  var action = node.action,
		    payload = node.payload,
		    prevState = actionQueue.state;
		  if (node.isTransition) {
		    var prevTransition = ReactSharedInternals.T,
		      currentTransition = {};
		    ReactSharedInternals.T = currentTransition;
		    try {
		      var returnValue = action(prevState, payload),
		        onStartTransitionFinish = ReactSharedInternals.S;
		      null !== onStartTransitionFinish &&
		        onStartTransitionFinish(currentTransition, returnValue);
		      handleActionReturnValue(actionQueue, node, returnValue);
		    } catch (error) {
		      onActionError(actionQueue, node, error);
		    } finally {
		      ReactSharedInternals.T = prevTransition;
		    }
		  } else
		    try {
		      (prevTransition = action(prevState, payload)),
		        handleActionReturnValue(actionQueue, node, prevTransition);
		    } catch (error$38) {
		      onActionError(actionQueue, node, error$38);
		    }
		}
		function handleActionReturnValue(actionQueue, node, returnValue) {
		  null !== returnValue &&
		  "object" === typeof returnValue &&
		  "function" === typeof returnValue.then
		    ? returnValue.then(
		        function (nextState) {
		          onActionSuccess(actionQueue, node, nextState);
		        },
		        function (error) {
		          return onActionError(actionQueue, node, error);
		        }
		      )
		    : onActionSuccess(actionQueue, node, returnValue);
		}
		function onActionSuccess(actionQueue, actionNode, nextState) {
		  actionNode.status = "fulfilled";
		  actionNode.value = nextState;
		  notifyActionListeners(actionNode);
		  actionQueue.state = nextState;
		  actionNode = actionQueue.pending;
		  null !== actionNode &&
		    ((nextState = actionNode.next),
		    nextState === actionNode
		      ? (actionQueue.pending = null)
		      : ((nextState = nextState.next),
		        (actionNode.next = nextState),
		        runActionStateAction(actionQueue, nextState)));
		}
		function onActionError(actionQueue, actionNode, error) {
		  var last = actionQueue.pending;
		  actionQueue.pending = null;
		  if (null !== last) {
		    last = last.next;
		    do
		      (actionNode.status = "rejected"),
		        (actionNode.reason = error),
		        notifyActionListeners(actionNode),
		        (actionNode = actionNode.next);
		    while (actionNode !== last);
		  }
		  actionQueue.action = null;
		}
		function notifyActionListeners(actionNode) {
		  actionNode = actionNode.listeners;
		  for (var i = 0; i < actionNode.length; i++) (0, actionNode[i])();
		}
		function actionStateReducer(oldState, newState) {
		  return newState;
		}
		function mountActionState(action, initialStateProp) {
		  if (isHydrating) {
		    var ssrFormState = workInProgressRoot.formState;
		    if (null !== ssrFormState) {
		      a: {
		        var JSCompiler_inline_result = currentlyRenderingFiber;
		        if (isHydrating) {
		          if (nextHydratableInstance) {
		            b: {
		              var JSCompiler_inline_result$jscomp$0 = nextHydratableInstance;
		              for (
		                var inRootOrSingleton = rootOrSingletonContext;
		                8 !== JSCompiler_inline_result$jscomp$0.nodeType;

		              ) {
		                if (!inRootOrSingleton) {
		                  JSCompiler_inline_result$jscomp$0 = null;
		                  break b;
		                }
		                JSCompiler_inline_result$jscomp$0 = getNextHydratable(
		                  JSCompiler_inline_result$jscomp$0.nextSibling
		                );
		                if (null === JSCompiler_inline_result$jscomp$0) {
		                  JSCompiler_inline_result$jscomp$0 = null;
		                  break b;
		                }
		              }
		              inRootOrSingleton = JSCompiler_inline_result$jscomp$0.data;
		              JSCompiler_inline_result$jscomp$0 =
		                "F!" === inRootOrSingleton || "F" === inRootOrSingleton
		                  ? JSCompiler_inline_result$jscomp$0
		                  : null;
		            }
		            if (JSCompiler_inline_result$jscomp$0) {
		              nextHydratableInstance = getNextHydratable(
		                JSCompiler_inline_result$jscomp$0.nextSibling
		              );
		              JSCompiler_inline_result =
		                "F!" === JSCompiler_inline_result$jscomp$0.data;
		              break a;
		            }
		          }
		          throwOnHydrationMismatch(JSCompiler_inline_result);
		        }
		        JSCompiler_inline_result = false;
		      }
		      JSCompiler_inline_result && (initialStateProp = ssrFormState[0]);
		    }
		  }
		  ssrFormState = mountWorkInProgressHook();
		  ssrFormState.memoizedState = ssrFormState.baseState = initialStateProp;
		  JSCompiler_inline_result = {
		    pending: null,
		    lanes: 0,
		    dispatch: null,
		    lastRenderedReducer: actionStateReducer,
		    lastRenderedState: initialStateProp
		  };
		  ssrFormState.queue = JSCompiler_inline_result;
		  ssrFormState = dispatchSetState.bind(
		    null,
		    currentlyRenderingFiber,
		    JSCompiler_inline_result
		  );
		  JSCompiler_inline_result.dispatch = ssrFormState;
		  JSCompiler_inline_result = mountStateImpl(false);
		  inRootOrSingleton = dispatchOptimisticSetState.bind(
		    null,
		    currentlyRenderingFiber,
		    false,
		    JSCompiler_inline_result.queue
		  );
		  JSCompiler_inline_result = mountWorkInProgressHook();
		  JSCompiler_inline_result$jscomp$0 = {
		    state: initialStateProp,
		    dispatch: null,
		    action: action,
		    pending: null
		  };
		  JSCompiler_inline_result.queue = JSCompiler_inline_result$jscomp$0;
		  ssrFormState = dispatchActionState.bind(
		    null,
		    currentlyRenderingFiber,
		    JSCompiler_inline_result$jscomp$0,
		    inRootOrSingleton,
		    ssrFormState
		  );
		  JSCompiler_inline_result$jscomp$0.dispatch = ssrFormState;
		  JSCompiler_inline_result.memoizedState = action;
		  return [initialStateProp, ssrFormState, false];
		}
		function updateActionState(action) {
		  var stateHook = updateWorkInProgressHook();
		  return updateActionStateImpl(stateHook, currentHook, action);
		}
		function updateActionStateImpl(stateHook, currentStateHook, action) {
		  currentStateHook = updateReducerImpl(
		    stateHook,
		    currentStateHook,
		    actionStateReducer
		  )[0];
		  stateHook = updateReducer(basicStateReducer)[0];
		  if (
		    "object" === typeof currentStateHook &&
		    null !== currentStateHook &&
		    "function" === typeof currentStateHook.then
		  )
		    try {
		      var state = useThenable(currentStateHook);
		    } catch (x) {
		      if (x === SuspenseException) throw SuspenseActionException;
		      throw x;
		    }
		  else state = currentStateHook;
		  currentStateHook = updateWorkInProgressHook();
		  var actionQueue = currentStateHook.queue,
		    dispatch = actionQueue.dispatch;
		  action !== currentStateHook.memoizedState &&
		    ((currentlyRenderingFiber.flags |= 2048),
		    pushSimpleEffect(
		      9,
		      createEffectInstance(),
		      actionStateActionEffect.bind(null, actionQueue, action),
		      null
		    ));
		  return [state, dispatch, stateHook];
		}
		function actionStateActionEffect(actionQueue, action) {
		  actionQueue.action = action;
		}
		function rerenderActionState(action) {
		  var stateHook = updateWorkInProgressHook(),
		    currentStateHook = currentHook;
		  if (null !== currentStateHook)
		    return updateActionStateImpl(stateHook, currentStateHook, action);
		  updateWorkInProgressHook();
		  stateHook = stateHook.memoizedState;
		  currentStateHook = updateWorkInProgressHook();
		  var dispatch = currentStateHook.queue.dispatch;
		  currentStateHook.memoizedState = action;
		  return [stateHook, dispatch, false];
		}
		function pushSimpleEffect(tag, inst, create, createDeps) {
		  tag = { tag: tag, create: create, deps: createDeps, inst: inst, next: null };
		  inst = currentlyRenderingFiber.updateQueue;
		  null === inst &&
		    ((inst = createFunctionComponentUpdateQueue()),
		    (currentlyRenderingFiber.updateQueue = inst));
		  create = inst.lastEffect;
		  null === create
		    ? (inst.lastEffect = tag.next = tag)
		    : ((createDeps = create.next),
		      (create.next = tag),
		      (tag.next = createDeps),
		      (inst.lastEffect = tag));
		  return tag;
		}
		function createEffectInstance() {
		  return { destroy: void 0, resource: void 0 };
		}
		function updateRef() {
		  return updateWorkInProgressHook().memoizedState;
		}
		function mountEffectImpl(fiberFlags, hookFlags, create, createDeps) {
		  var hook = mountWorkInProgressHook();
		  createDeps = void 0 === createDeps ? null : createDeps;
		  currentlyRenderingFiber.flags |= fiberFlags;
		  hook.memoizedState = pushSimpleEffect(
		    1 | hookFlags,
		    createEffectInstance(),
		    create,
		    createDeps
		  );
		}
		function updateEffectImpl(fiberFlags, hookFlags, create, deps) {
		  var hook = updateWorkInProgressHook();
		  deps = void 0 === deps ? null : deps;
		  var inst = hook.memoizedState.inst;
		  null !== currentHook &&
		  null !== deps &&
		  areHookInputsEqual(deps, currentHook.memoizedState.deps)
		    ? (hook.memoizedState = pushSimpleEffect(hookFlags, inst, create, deps))
		    : ((currentlyRenderingFiber.flags |= fiberFlags),
		      (hook.memoizedState = pushSimpleEffect(
		        1 | hookFlags,
		        inst,
		        create,
		        deps
		      )));
		}
		function mountEffect(create, createDeps) {
		  mountEffectImpl(8390656, 8, create, createDeps);
		}
		function updateEffect(create, createDeps) {
		  updateEffectImpl(2048, 8, create, createDeps);
		}
		function updateInsertionEffect(create, deps) {
		  return updateEffectImpl(4, 2, create, deps);
		}
		function updateLayoutEffect(create, deps) {
		  return updateEffectImpl(4, 4, create, deps);
		}
		function imperativeHandleEffect(create, ref) {
		  if ("function" === typeof ref) {
		    create = create();
		    var refCleanup = ref(create);
		    return function () {
		      "function" === typeof refCleanup ? refCleanup() : ref(null);
		    };
		  }
		  if (null !== ref && void 0 !== ref)
		    return (
		      (create = create()),
		      (ref.current = create),
		      function () {
		        ref.current = null;
		      }
		    );
		}
		function updateImperativeHandle(ref, create, deps) {
		  deps = null !== deps && void 0 !== deps ? deps.concat([ref]) : null;
		  updateEffectImpl(4, 4, imperativeHandleEffect.bind(null, create, ref), deps);
		}
		function mountDebugValue() {}
		function updateCallback(callback, deps) {
		  var hook = updateWorkInProgressHook();
		  deps = void 0 === deps ? null : deps;
		  var prevState = hook.memoizedState;
		  if (null !== deps && areHookInputsEqual(deps, prevState[1]))
		    return prevState[0];
		  hook.memoizedState = [callback, deps];
		  return callback;
		}
		function updateMemo(nextCreate, deps) {
		  var hook = updateWorkInProgressHook();
		  deps = void 0 === deps ? null : deps;
		  var prevState = hook.memoizedState;
		  if (null !== deps && areHookInputsEqual(deps, prevState[1]))
		    return prevState[0];
		  prevState = nextCreate();
		  if (shouldDoubleInvokeUserFnsInHooksDEV) {
		    setIsStrictModeForDevtools(true);
		    try {
		      nextCreate();
		    } finally {
		      setIsStrictModeForDevtools(false);
		    }
		  }
		  hook.memoizedState = [prevState, deps];
		  return prevState;
		}
		function mountDeferredValueImpl(hook, value, initialValue) {
		  if (void 0 === initialValue || 0 !== (renderLanes & 1073741824))
		    return (hook.memoizedState = value);
		  hook.memoizedState = initialValue;
		  hook = requestDeferredLane();
		  currentlyRenderingFiber.lanes |= hook;
		  workInProgressRootSkippedLanes |= hook;
		  return initialValue;
		}
		function updateDeferredValueImpl(hook, prevValue, value, initialValue) {
		  if (objectIs(value, prevValue)) return value;
		  if (null !== currentTreeHiddenStackCursor.current)
		    return (
		      (hook = mountDeferredValueImpl(hook, value, initialValue)),
		      objectIs(hook, prevValue) || (didReceiveUpdate = true),
		      hook
		    );
		  if (0 === (renderLanes & 42))
		    return (didReceiveUpdate = true), (hook.memoizedState = value);
		  hook = requestDeferredLane();
		  currentlyRenderingFiber.lanes |= hook;
		  workInProgressRootSkippedLanes |= hook;
		  return prevValue;
		}
		function startTransition(fiber, queue, pendingState, finishedState, callback) {
		  var previousPriority = ReactDOMSharedInternals.p;
		  ReactDOMSharedInternals.p =
		    0 !== previousPriority && 8 > previousPriority ? previousPriority : 8;
		  var prevTransition = ReactSharedInternals.T,
		    currentTransition = {};
		  ReactSharedInternals.T = currentTransition;
		  dispatchOptimisticSetState(fiber, false, queue, pendingState);
		  try {
		    var returnValue = callback(),
		      onStartTransitionFinish = ReactSharedInternals.S;
		    null !== onStartTransitionFinish &&
		      onStartTransitionFinish(currentTransition, returnValue);
		    if (
		      null !== returnValue &&
		      "object" === typeof returnValue &&
		      "function" === typeof returnValue.then
		    ) {
		      var thenableForFinishedState = chainThenableValue(
		        returnValue,
		        finishedState
		      );
		      dispatchSetStateInternal(
		        fiber,
		        queue,
		        thenableForFinishedState,
		        requestUpdateLane(fiber)
		      );
		    } else
		      dispatchSetStateInternal(
		        fiber,
		        queue,
		        finishedState,
		        requestUpdateLane(fiber)
		      );
		  } catch (error) {
		    dispatchSetStateInternal(
		      fiber,
		      queue,
		      { then: function () {}, status: "rejected", reason: error },
		      requestUpdateLane()
		    );
		  } finally {
		    (ReactDOMSharedInternals.p = previousPriority),
		      (ReactSharedInternals.T = prevTransition);
		  }
		}
		function noop$2() {}
		function startHostTransition(formFiber, pendingState, action, formData) {
		  if (5 !== formFiber.tag) throw Error(formatProdErrorMessage(476));
		  var queue = ensureFormComponentIsStateful(formFiber).queue;
		  startTransition(
		    formFiber,
		    queue,
		    pendingState,
		    sharedNotPendingObject,
		    null === action
		      ? noop$2
		      : function () {
		          requestFormReset$1(formFiber);
		          return action(formData);
		        }
		  );
		}
		function ensureFormComponentIsStateful(formFiber) {
		  var existingStateHook = formFiber.memoizedState;
		  if (null !== existingStateHook) return existingStateHook;
		  existingStateHook = {
		    memoizedState: sharedNotPendingObject,
		    baseState: sharedNotPendingObject,
		    baseQueue: null,
		    queue: {
		      pending: null,
		      lanes: 0,
		      dispatch: null,
		      lastRenderedReducer: basicStateReducer,
		      lastRenderedState: sharedNotPendingObject
		    },
		    next: null
		  };
		  var initialResetState = {};
		  existingStateHook.next = {
		    memoizedState: initialResetState,
		    baseState: initialResetState,
		    baseQueue: null,
		    queue: {
		      pending: null,
		      lanes: 0,
		      dispatch: null,
		      lastRenderedReducer: basicStateReducer,
		      lastRenderedState: initialResetState
		    },
		    next: null
		  };
		  formFiber.memoizedState = existingStateHook;
		  formFiber = formFiber.alternate;
		  null !== formFiber && (formFiber.memoizedState = existingStateHook);
		  return existingStateHook;
		}
		function requestFormReset$1(formFiber) {
		  var resetStateQueue = ensureFormComponentIsStateful(formFiber).next.queue;
		  dispatchSetStateInternal(formFiber, resetStateQueue, {}, requestUpdateLane());
		}
		function useHostTransitionStatus() {
		  return readContext(HostTransitionContext);
		}
		function updateId() {
		  return updateWorkInProgressHook().memoizedState;
		}
		function updateRefresh() {
		  return updateWorkInProgressHook().memoizedState;
		}
		function refreshCache(fiber) {
		  for (var provider = fiber.return; null !== provider; ) {
		    switch (provider.tag) {
		      case 24:
		      case 3:
		        var lane = requestUpdateLane();
		        fiber = createUpdate(lane);
		        var root$41 = enqueueUpdate(provider, fiber, lane);
		        null !== root$41 &&
		          (scheduleUpdateOnFiber(root$41, provider, lane),
		          entangleTransitions(root$41, provider, lane));
		        provider = { cache: createCache() };
		        fiber.payload = provider;
		        return;
		    }
		    provider = provider.return;
		  }
		}
		function dispatchReducerAction(fiber, queue, action) {
		  var lane = requestUpdateLane();
		  action = {
		    lane: lane,
		    revertLane: 0,
		    action: action,
		    hasEagerState: false,
		    eagerState: null,
		    next: null
		  };
		  isRenderPhaseUpdate(fiber)
		    ? enqueueRenderPhaseUpdate(queue, action)
		    : ((action = enqueueConcurrentHookUpdate(fiber, queue, action, lane)),
		      null !== action &&
		        (scheduleUpdateOnFiber(action, fiber, lane),
		        entangleTransitionUpdate(action, queue, lane)));
		}
		function dispatchSetState(fiber, queue, action) {
		  var lane = requestUpdateLane();
		  dispatchSetStateInternal(fiber, queue, action, lane);
		}
		function dispatchSetStateInternal(fiber, queue, action, lane) {
		  var update = {
		    lane: lane,
		    revertLane: 0,
		    action: action,
		    hasEagerState: false,
		    eagerState: null,
		    next: null
		  };
		  if (isRenderPhaseUpdate(fiber)) enqueueRenderPhaseUpdate(queue, update);
		  else {
		    var alternate = fiber.alternate;
		    if (
		      0 === fiber.lanes &&
		      (null === alternate || 0 === alternate.lanes) &&
		      ((alternate = queue.lastRenderedReducer), null !== alternate)
		    )
		      try {
		        var currentState = queue.lastRenderedState,
		          eagerState = alternate(currentState, action);
		        update.hasEagerState = !0;
		        update.eagerState = eagerState;
		        if (objectIs(eagerState, currentState))
		          return (
		            enqueueUpdate$1(fiber, queue, update, 0),
		            null === workInProgressRoot && finishQueueingConcurrentUpdates(),
		            !1
		          );
		      } catch (error) {
		      } finally {
		      }
		    action = enqueueConcurrentHookUpdate(fiber, queue, update, lane);
		    if (null !== action)
		      return (
		        scheduleUpdateOnFiber(action, fiber, lane),
		        entangleTransitionUpdate(action, queue, lane),
		        true
		      );
		  }
		  return false;
		}
		function dispatchOptimisticSetState(fiber, throwIfDuringRender, queue, action) {
		  action = {
		    lane: 2,
		    revertLane: requestTransitionLane(),
		    action: action,
		    hasEagerState: false,
		    eagerState: null,
		    next: null
		  };
		  if (isRenderPhaseUpdate(fiber)) {
		    if (throwIfDuringRender) throw Error(formatProdErrorMessage(479));
		  } else
		    (throwIfDuringRender = enqueueConcurrentHookUpdate(
		      fiber,
		      queue,
		      action,
		      2
		    )),
		      null !== throwIfDuringRender &&
		        scheduleUpdateOnFiber(throwIfDuringRender, fiber, 2);
		}
		function isRenderPhaseUpdate(fiber) {
		  var alternate = fiber.alternate;
		  return (
		    fiber === currentlyRenderingFiber ||
		    (null !== alternate && alternate === currentlyRenderingFiber)
		  );
		}
		function enqueueRenderPhaseUpdate(queue, update) {
		  didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate =
		    true;
		  var pending = queue.pending;
		  null === pending
		    ? (update.next = update)
		    : ((update.next = pending.next), (pending.next = update));
		  queue.pending = update;
		}
		function entangleTransitionUpdate(root, queue, lane) {
		  if (0 !== (lane & 4194048)) {
		    var queueLanes = queue.lanes;
		    queueLanes &= root.pendingLanes;
		    lane |= queueLanes;
		    queue.lanes = lane;
		    markRootEntangled(root, lane);
		  }
		}
		var ContextOnlyDispatcher = {
		    readContext: readContext,
		    use: use,
		    useCallback: throwInvalidHookError,
		    useContext: throwInvalidHookError,
		    useEffect: throwInvalidHookError,
		    useImperativeHandle: throwInvalidHookError,
		    useLayoutEffect: throwInvalidHookError,
		    useInsertionEffect: throwInvalidHookError,
		    useMemo: throwInvalidHookError,
		    useReducer: throwInvalidHookError,
		    useRef: throwInvalidHookError,
		    useState: throwInvalidHookError,
		    useDebugValue: throwInvalidHookError,
		    useDeferredValue: throwInvalidHookError,
		    useTransition: throwInvalidHookError,
		    useSyncExternalStore: throwInvalidHookError,
		    useId: throwInvalidHookError,
		    useHostTransitionStatus: throwInvalidHookError,
		    useFormState: throwInvalidHookError,
		    useActionState: throwInvalidHookError,
		    useOptimistic: throwInvalidHookError,
		    useMemoCache: throwInvalidHookError,
		    useCacheRefresh: throwInvalidHookError
		  },
		  HooksDispatcherOnMount = {
		    readContext: readContext,
		    use: use,
		    useCallback: function (callback, deps) {
		      mountWorkInProgressHook().memoizedState = [
		        callback,
		        void 0 === deps ? null : deps
		      ];
		      return callback;
		    },
		    useContext: readContext,
		    useEffect: mountEffect,
		    useImperativeHandle: function (ref, create, deps) {
		      deps = null !== deps && void 0 !== deps ? deps.concat([ref]) : null;
		      mountEffectImpl(
		        4194308,
		        4,
		        imperativeHandleEffect.bind(null, create, ref),
		        deps
		      );
		    },
		    useLayoutEffect: function (create, deps) {
		      return mountEffectImpl(4194308, 4, create, deps);
		    },
		    useInsertionEffect: function (create, deps) {
		      mountEffectImpl(4, 2, create, deps);
		    },
		    useMemo: function (nextCreate, deps) {
		      var hook = mountWorkInProgressHook();
		      deps = void 0 === deps ? null : deps;
		      var nextValue = nextCreate();
		      if (shouldDoubleInvokeUserFnsInHooksDEV) {
		        setIsStrictModeForDevtools(true);
		        try {
		          nextCreate();
		        } finally {
		          setIsStrictModeForDevtools(false);
		        }
		      }
		      hook.memoizedState = [nextValue, deps];
		      return nextValue;
		    },
		    useReducer: function (reducer, initialArg, init) {
		      var hook = mountWorkInProgressHook();
		      if (void 0 !== init) {
		        var initialState = init(initialArg);
		        if (shouldDoubleInvokeUserFnsInHooksDEV) {
		          setIsStrictModeForDevtools(true);
		          try {
		            init(initialArg);
		          } finally {
		            setIsStrictModeForDevtools(false);
		          }
		        }
		      } else initialState = initialArg;
		      hook.memoizedState = hook.baseState = initialState;
		      reducer = {
		        pending: null,
		        lanes: 0,
		        dispatch: null,
		        lastRenderedReducer: reducer,
		        lastRenderedState: initialState
		      };
		      hook.queue = reducer;
		      reducer = reducer.dispatch = dispatchReducerAction.bind(
		        null,
		        currentlyRenderingFiber,
		        reducer
		      );
		      return [hook.memoizedState, reducer];
		    },
		    useRef: function (initialValue) {
		      var hook = mountWorkInProgressHook();
		      initialValue = { current: initialValue };
		      return (hook.memoizedState = initialValue);
		    },
		    useState: function (initialState) {
		      initialState = mountStateImpl(initialState);
		      var queue = initialState.queue,
		        dispatch = dispatchSetState.bind(null, currentlyRenderingFiber, queue);
		      queue.dispatch = dispatch;
		      return [initialState.memoizedState, dispatch];
		    },
		    useDebugValue: mountDebugValue,
		    useDeferredValue: function (value, initialValue) {
		      var hook = mountWorkInProgressHook();
		      return mountDeferredValueImpl(hook, value, initialValue);
		    },
		    useTransition: function () {
		      var stateHook = mountStateImpl(false);
		      stateHook = startTransition.bind(
		        null,
		        currentlyRenderingFiber,
		        stateHook.queue,
		        true,
		        false
		      );
		      mountWorkInProgressHook().memoizedState = stateHook;
		      return [false, stateHook];
		    },
		    useSyncExternalStore: function (subscribe, getSnapshot, getServerSnapshot) {
		      var fiber = currentlyRenderingFiber,
		        hook = mountWorkInProgressHook();
		      if (isHydrating) {
		        if (void 0 === getServerSnapshot)
		          throw Error(formatProdErrorMessage(407));
		        getServerSnapshot = getServerSnapshot();
		      } else {
		        getServerSnapshot = getSnapshot();
		        if (null === workInProgressRoot)
		          throw Error(formatProdErrorMessage(349));
		        0 !== (workInProgressRootRenderLanes & 124) ||
		          pushStoreConsistencyCheck(fiber, getSnapshot, getServerSnapshot);
		      }
		      hook.memoizedState = getServerSnapshot;
		      var inst = { value: getServerSnapshot, getSnapshot: getSnapshot };
		      hook.queue = inst;
		      mountEffect(subscribeToStore.bind(null, fiber, inst, subscribe), [
		        subscribe
		      ]);
		      fiber.flags |= 2048;
		      pushSimpleEffect(
		        9,
		        createEffectInstance(),
		        updateStoreInstance.bind(
		          null,
		          fiber,
		          inst,
		          getServerSnapshot,
		          getSnapshot
		        ),
		        null
		      );
		      return getServerSnapshot;
		    },
		    useId: function () {
		      var hook = mountWorkInProgressHook(),
		        identifierPrefix = workInProgressRoot.identifierPrefix;
		      if (isHydrating) {
		        var JSCompiler_inline_result = treeContextOverflow;
		        var idWithLeadingBit = treeContextId;
		        JSCompiler_inline_result =
		          (
		            idWithLeadingBit & ~(1 << (32 - clz32(idWithLeadingBit) - 1))
		          ).toString(32) + JSCompiler_inline_result;
		        identifierPrefix =
		          "\u00ab" + identifierPrefix + "R" + JSCompiler_inline_result;
		        JSCompiler_inline_result = localIdCounter++;
		        0 < JSCompiler_inline_result &&
		          (identifierPrefix += "H" + JSCompiler_inline_result.toString(32));
		        identifierPrefix += "\u00bb";
		      } else
		        (JSCompiler_inline_result = globalClientIdCounter++),
		          (identifierPrefix =
		            "\u00ab" +
		            identifierPrefix +
		            "r" +
		            JSCompiler_inline_result.toString(32) +
		            "\u00bb");
		      return (hook.memoizedState = identifierPrefix);
		    },
		    useHostTransitionStatus: useHostTransitionStatus,
		    useFormState: mountActionState,
		    useActionState: mountActionState,
		    useOptimistic: function (passthrough) {
		      var hook = mountWorkInProgressHook();
		      hook.memoizedState = hook.baseState = passthrough;
		      var queue = {
		        pending: null,
		        lanes: 0,
		        dispatch: null,
		        lastRenderedReducer: null,
		        lastRenderedState: null
		      };
		      hook.queue = queue;
		      hook = dispatchOptimisticSetState.bind(
		        null,
		        currentlyRenderingFiber,
		        true,
		        queue
		      );
		      queue.dispatch = hook;
		      return [passthrough, hook];
		    },
		    useMemoCache: useMemoCache,
		    useCacheRefresh: function () {
		      return (mountWorkInProgressHook().memoizedState = refreshCache.bind(
		        null,
		        currentlyRenderingFiber
		      ));
		    }
		  },
		  HooksDispatcherOnUpdate = {
		    readContext: readContext,
		    use: use,
		    useCallback: updateCallback,
		    useContext: readContext,
		    useEffect: updateEffect,
		    useImperativeHandle: updateImperativeHandle,
		    useInsertionEffect: updateInsertionEffect,
		    useLayoutEffect: updateLayoutEffect,
		    useMemo: updateMemo,
		    useReducer: updateReducer,
		    useRef: updateRef,
		    useState: function () {
		      return updateReducer(basicStateReducer);
		    },
		    useDebugValue: mountDebugValue,
		    useDeferredValue: function (value, initialValue) {
		      var hook = updateWorkInProgressHook();
		      return updateDeferredValueImpl(
		        hook,
		        currentHook.memoizedState,
		        value,
		        initialValue
		      );
		    },
		    useTransition: function () {
		      var booleanOrThenable = updateReducer(basicStateReducer)[0],
		        start = updateWorkInProgressHook().memoizedState;
		      return [
		        "boolean" === typeof booleanOrThenable
		          ? booleanOrThenable
		          : useThenable(booleanOrThenable),
		        start
		      ];
		    },
		    useSyncExternalStore: updateSyncExternalStore,
		    useId: updateId,
		    useHostTransitionStatus: useHostTransitionStatus,
		    useFormState: updateActionState,
		    useActionState: updateActionState,
		    useOptimistic: function (passthrough, reducer) {
		      var hook = updateWorkInProgressHook();
		      return updateOptimisticImpl(hook, currentHook, passthrough, reducer);
		    },
		    useMemoCache: useMemoCache,
		    useCacheRefresh: updateRefresh
		  },
		  HooksDispatcherOnRerender = {
		    readContext: readContext,
		    use: use,
		    useCallback: updateCallback,
		    useContext: readContext,
		    useEffect: updateEffect,
		    useImperativeHandle: updateImperativeHandle,
		    useInsertionEffect: updateInsertionEffect,
		    useLayoutEffect: updateLayoutEffect,
		    useMemo: updateMemo,
		    useReducer: rerenderReducer,
		    useRef: updateRef,
		    useState: function () {
		      return rerenderReducer(basicStateReducer);
		    },
		    useDebugValue: mountDebugValue,
		    useDeferredValue: function (value, initialValue) {
		      var hook = updateWorkInProgressHook();
		      return null === currentHook
		        ? mountDeferredValueImpl(hook, value, initialValue)
		        : updateDeferredValueImpl(
		            hook,
		            currentHook.memoizedState,
		            value,
		            initialValue
		          );
		    },
		    useTransition: function () {
		      var booleanOrThenable = rerenderReducer(basicStateReducer)[0],
		        start = updateWorkInProgressHook().memoizedState;
		      return [
		        "boolean" === typeof booleanOrThenable
		          ? booleanOrThenable
		          : useThenable(booleanOrThenable),
		        start
		      ];
		    },
		    useSyncExternalStore: updateSyncExternalStore,
		    useId: updateId,
		    useHostTransitionStatus: useHostTransitionStatus,
		    useFormState: rerenderActionState,
		    useActionState: rerenderActionState,
		    useOptimistic: function (passthrough, reducer) {
		      var hook = updateWorkInProgressHook();
		      if (null !== currentHook)
		        return updateOptimisticImpl(hook, currentHook, passthrough, reducer);
		      hook.baseState = passthrough;
		      return [passthrough, hook.queue.dispatch];
		    },
		    useMemoCache: useMemoCache,
		    useCacheRefresh: updateRefresh
		  },
		  thenableState = null,
		  thenableIndexCounter = 0;
		function unwrapThenable(thenable) {
		  var index = thenableIndexCounter;
		  thenableIndexCounter += 1;
		  null === thenableState && (thenableState = []);
		  return trackUsedThenable(thenableState, thenable, index);
		}
		function coerceRef(workInProgress, element) {
		  element = element.props.ref;
		  workInProgress.ref = void 0 !== element ? element : null;
		}
		function throwOnInvalidObjectType(returnFiber, newChild) {
		  if (newChild.$$typeof === REACT_LEGACY_ELEMENT_TYPE)
		    throw Error(formatProdErrorMessage(525));
		  returnFiber = Object.prototype.toString.call(newChild);
		  throw Error(
		    formatProdErrorMessage(
		      31,
		      "[object Object]" === returnFiber
		        ? "object with keys {" + Object.keys(newChild).join(", ") + "}"
		        : returnFiber
		    )
		  );
		}
		function resolveLazy(lazyType) {
		  var init = lazyType._init;
		  return init(lazyType._payload);
		}
		function createChildReconciler(shouldTrackSideEffects) {
		  function deleteChild(returnFiber, childToDelete) {
		    if (shouldTrackSideEffects) {
		      var deletions = returnFiber.deletions;
		      null === deletions
		        ? ((returnFiber.deletions = [childToDelete]), (returnFiber.flags |= 16))
		        : deletions.push(childToDelete);
		    }
		  }
		  function deleteRemainingChildren(returnFiber, currentFirstChild) {
		    if (!shouldTrackSideEffects) return null;
		    for (; null !== currentFirstChild; )
		      deleteChild(returnFiber, currentFirstChild),
		        (currentFirstChild = currentFirstChild.sibling);
		    return null;
		  }
		  function mapRemainingChildren(currentFirstChild) {
		    for (var existingChildren = new Map(); null !== currentFirstChild; )
		      null !== currentFirstChild.key
		        ? existingChildren.set(currentFirstChild.key, currentFirstChild)
		        : existingChildren.set(currentFirstChild.index, currentFirstChild),
		        (currentFirstChild = currentFirstChild.sibling);
		    return existingChildren;
		  }
		  function useFiber(fiber, pendingProps) {
		    fiber = createWorkInProgress(fiber, pendingProps);
		    fiber.index = 0;
		    fiber.sibling = null;
		    return fiber;
		  }
		  function placeChild(newFiber, lastPlacedIndex, newIndex) {
		    newFiber.index = newIndex;
		    if (!shouldTrackSideEffects)
		      return (newFiber.flags |= 1048576), lastPlacedIndex;
		    newIndex = newFiber.alternate;
		    if (null !== newIndex)
		      return (
		        (newIndex = newIndex.index),
		        newIndex < lastPlacedIndex
		          ? ((newFiber.flags |= 67108866), lastPlacedIndex)
		          : newIndex
		      );
		    newFiber.flags |= 67108866;
		    return lastPlacedIndex;
		  }
		  function placeSingleChild(newFiber) {
		    shouldTrackSideEffects &&
		      null === newFiber.alternate &&
		      (newFiber.flags |= 67108866);
		    return newFiber;
		  }
		  function updateTextNode(returnFiber, current, textContent, lanes) {
		    if (null === current || 6 !== current.tag)
		      return (
		        (current = createFiberFromText(textContent, returnFiber.mode, lanes)),
		        (current.return = returnFiber),
		        current
		      );
		    current = useFiber(current, textContent);
		    current.return = returnFiber;
		    return current;
		  }
		  function updateElement(returnFiber, current, element, lanes) {
		    var elementType = element.type;
		    if (elementType === REACT_FRAGMENT_TYPE)
		      return updateFragment(
		        returnFiber,
		        current,
		        element.props.children,
		        lanes,
		        element.key
		      );
		    if (
		      null !== current &&
		      (current.elementType === elementType ||
		        ("object" === typeof elementType &&
		          null !== elementType &&
		          elementType.$$typeof === REACT_LAZY_TYPE &&
		          resolveLazy(elementType) === current.type))
		    )
		      return (
		        (current = useFiber(current, element.props)),
		        coerceRef(current, element),
		        (current.return = returnFiber),
		        current
		      );
		    current = createFiberFromTypeAndProps(
		      element.type,
		      element.key,
		      element.props,
		      null,
		      returnFiber.mode,
		      lanes
		    );
		    coerceRef(current, element);
		    current.return = returnFiber;
		    return current;
		  }
		  function updatePortal(returnFiber, current, portal, lanes) {
		    if (
		      null === current ||
		      4 !== current.tag ||
		      current.stateNode.containerInfo !== portal.containerInfo ||
		      current.stateNode.implementation !== portal.implementation
		    )
		      return (
		        (current = createFiberFromPortal(portal, returnFiber.mode, lanes)),
		        (current.return = returnFiber),
		        current
		      );
		    current = useFiber(current, portal.children || []);
		    current.return = returnFiber;
		    return current;
		  }
		  function updateFragment(returnFiber, current, fragment, lanes, key) {
		    if (null === current || 7 !== current.tag)
		      return (
		        (current = createFiberFromFragment(
		          fragment,
		          returnFiber.mode,
		          lanes,
		          key
		        )),
		        (current.return = returnFiber),
		        current
		      );
		    current = useFiber(current, fragment);
		    current.return = returnFiber;
		    return current;
		  }
		  function createChild(returnFiber, newChild, lanes) {
		    if (
		      ("string" === typeof newChild && "" !== newChild) ||
		      "number" === typeof newChild ||
		      "bigint" === typeof newChild
		    )
		      return (
		        (newChild = createFiberFromText(
		          "" + newChild,
		          returnFiber.mode,
		          lanes
		        )),
		        (newChild.return = returnFiber),
		        newChild
		      );
		    if ("object" === typeof newChild && null !== newChild) {
		      switch (newChild.$$typeof) {
		        case REACT_ELEMENT_TYPE:
		          return (
		            (lanes = createFiberFromTypeAndProps(
		              newChild.type,
		              newChild.key,
		              newChild.props,
		              null,
		              returnFiber.mode,
		              lanes
		            )),
		            coerceRef(lanes, newChild),
		            (lanes.return = returnFiber),
		            lanes
		          );
		        case REACT_PORTAL_TYPE:
		          return (
		            (newChild = createFiberFromPortal(
		              newChild,
		              returnFiber.mode,
		              lanes
		            )),
		            (newChild.return = returnFiber),
		            newChild
		          );
		        case REACT_LAZY_TYPE:
		          var init = newChild._init;
		          newChild = init(newChild._payload);
		          return createChild(returnFiber, newChild, lanes);
		      }
		      if (isArrayImpl(newChild) || getIteratorFn(newChild))
		        return (
		          (newChild = createFiberFromFragment(
		            newChild,
		            returnFiber.mode,
		            lanes,
		            null
		          )),
		          (newChild.return = returnFiber),
		          newChild
		        );
		      if ("function" === typeof newChild.then)
		        return createChild(returnFiber, unwrapThenable(newChild), lanes);
		      if (newChild.$$typeof === REACT_CONTEXT_TYPE)
		        return createChild(
		          returnFiber,
		          readContextDuringReconciliation(returnFiber, newChild),
		          lanes
		        );
		      throwOnInvalidObjectType(returnFiber, newChild);
		    }
		    return null;
		  }
		  function updateSlot(returnFiber, oldFiber, newChild, lanes) {
		    var key = null !== oldFiber ? oldFiber.key : null;
		    if (
		      ("string" === typeof newChild && "" !== newChild) ||
		      "number" === typeof newChild ||
		      "bigint" === typeof newChild
		    )
		      return null !== key
		        ? null
		        : updateTextNode(returnFiber, oldFiber, "" + newChild, lanes);
		    if ("object" === typeof newChild && null !== newChild) {
		      switch (newChild.$$typeof) {
		        case REACT_ELEMENT_TYPE:
		          return newChild.key === key
		            ? updateElement(returnFiber, oldFiber, newChild, lanes)
		            : null;
		        case REACT_PORTAL_TYPE:
		          return newChild.key === key
		            ? updatePortal(returnFiber, oldFiber, newChild, lanes)
		            : null;
		        case REACT_LAZY_TYPE:
		          return (
		            (key = newChild._init),
		            (newChild = key(newChild._payload)),
		            updateSlot(returnFiber, oldFiber, newChild, lanes)
		          );
		      }
		      if (isArrayImpl(newChild) || getIteratorFn(newChild))
		        return null !== key
		          ? null
		          : updateFragment(returnFiber, oldFiber, newChild, lanes, null);
		      if ("function" === typeof newChild.then)
		        return updateSlot(
		          returnFiber,
		          oldFiber,
		          unwrapThenable(newChild),
		          lanes
		        );
		      if (newChild.$$typeof === REACT_CONTEXT_TYPE)
		        return updateSlot(
		          returnFiber,
		          oldFiber,
		          readContextDuringReconciliation(returnFiber, newChild),
		          lanes
		        );
		      throwOnInvalidObjectType(returnFiber, newChild);
		    }
		    return null;
		  }
		  function updateFromMap(
		    existingChildren,
		    returnFiber,
		    newIdx,
		    newChild,
		    lanes
		  ) {
		    if (
		      ("string" === typeof newChild && "" !== newChild) ||
		      "number" === typeof newChild ||
		      "bigint" === typeof newChild
		    )
		      return (
		        (existingChildren = existingChildren.get(newIdx) || null),
		        updateTextNode(returnFiber, existingChildren, "" + newChild, lanes)
		      );
		    if ("object" === typeof newChild && null !== newChild) {
		      switch (newChild.$$typeof) {
		        case REACT_ELEMENT_TYPE:
		          return (
		            (existingChildren =
		              existingChildren.get(
		                null === newChild.key ? newIdx : newChild.key
		              ) || null),
		            updateElement(returnFiber, existingChildren, newChild, lanes)
		          );
		        case REACT_PORTAL_TYPE:
		          return (
		            (existingChildren =
		              existingChildren.get(
		                null === newChild.key ? newIdx : newChild.key
		              ) || null),
		            updatePortal(returnFiber, existingChildren, newChild, lanes)
		          );
		        case REACT_LAZY_TYPE:
		          var init = newChild._init;
		          newChild = init(newChild._payload);
		          return updateFromMap(
		            existingChildren,
		            returnFiber,
		            newIdx,
		            newChild,
		            lanes
		          );
		      }
		      if (isArrayImpl(newChild) || getIteratorFn(newChild))
		        return (
		          (existingChildren = existingChildren.get(newIdx) || null),
		          updateFragment(returnFiber, existingChildren, newChild, lanes, null)
		        );
		      if ("function" === typeof newChild.then)
		        return updateFromMap(
		          existingChildren,
		          returnFiber,
		          newIdx,
		          unwrapThenable(newChild),
		          lanes
		        );
		      if (newChild.$$typeof === REACT_CONTEXT_TYPE)
		        return updateFromMap(
		          existingChildren,
		          returnFiber,
		          newIdx,
		          readContextDuringReconciliation(returnFiber, newChild),
		          lanes
		        );
		      throwOnInvalidObjectType(returnFiber, newChild);
		    }
		    return null;
		  }
		  function reconcileChildrenArray(
		    returnFiber,
		    currentFirstChild,
		    newChildren,
		    lanes
		  ) {
		    for (
		      var resultingFirstChild = null,
		        previousNewFiber = null,
		        oldFiber = currentFirstChild,
		        newIdx = (currentFirstChild = 0),
		        nextOldFiber = null;
		      null !== oldFiber && newIdx < newChildren.length;
		      newIdx++
		    ) {
		      oldFiber.index > newIdx
		        ? ((nextOldFiber = oldFiber), (oldFiber = null))
		        : (nextOldFiber = oldFiber.sibling);
		      var newFiber = updateSlot(
		        returnFiber,
		        oldFiber,
		        newChildren[newIdx],
		        lanes
		      );
		      if (null === newFiber) {
		        null === oldFiber && (oldFiber = nextOldFiber);
		        break;
		      }
		      shouldTrackSideEffects &&
		        oldFiber &&
		        null === newFiber.alternate &&
		        deleteChild(returnFiber, oldFiber);
		      currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);
		      null === previousNewFiber
		        ? (resultingFirstChild = newFiber)
		        : (previousNewFiber.sibling = newFiber);
		      previousNewFiber = newFiber;
		      oldFiber = nextOldFiber;
		    }
		    if (newIdx === newChildren.length)
		      return (
		        deleteRemainingChildren(returnFiber, oldFiber),
		        isHydrating && pushTreeFork(returnFiber, newIdx),
		        resultingFirstChild
		      );
		    if (null === oldFiber) {
		      for (; newIdx < newChildren.length; newIdx++)
		        (oldFiber = createChild(returnFiber, newChildren[newIdx], lanes)),
		          null !== oldFiber &&
		            ((currentFirstChild = placeChild(
		              oldFiber,
		              currentFirstChild,
		              newIdx
		            )),
		            null === previousNewFiber
		              ? (resultingFirstChild = oldFiber)
		              : (previousNewFiber.sibling = oldFiber),
		            (previousNewFiber = oldFiber));
		      isHydrating && pushTreeFork(returnFiber, newIdx);
		      return resultingFirstChild;
		    }
		    for (
		      oldFiber = mapRemainingChildren(oldFiber);
		      newIdx < newChildren.length;
		      newIdx++
		    )
		      (nextOldFiber = updateFromMap(
		        oldFiber,
		        returnFiber,
		        newIdx,
		        newChildren[newIdx],
		        lanes
		      )),
		        null !== nextOldFiber &&
		          (shouldTrackSideEffects &&
		            null !== nextOldFiber.alternate &&
		            oldFiber.delete(
		              null === nextOldFiber.key ? newIdx : nextOldFiber.key
		            ),
		          (currentFirstChild = placeChild(
		            nextOldFiber,
		            currentFirstChild,
		            newIdx
		          )),
		          null === previousNewFiber
		            ? (resultingFirstChild = nextOldFiber)
		            : (previousNewFiber.sibling = nextOldFiber),
		          (previousNewFiber = nextOldFiber));
		    shouldTrackSideEffects &&
		      oldFiber.forEach(function (child) {
		        return deleteChild(returnFiber, child);
		      });
		    isHydrating && pushTreeFork(returnFiber, newIdx);
		    return resultingFirstChild;
		  }
		  function reconcileChildrenIterator(
		    returnFiber,
		    currentFirstChild,
		    newChildren,
		    lanes
		  ) {
		    if (null == newChildren) throw Error(formatProdErrorMessage(151));
		    for (
		      var resultingFirstChild = null,
		        previousNewFiber = null,
		        oldFiber = currentFirstChild,
		        newIdx = (currentFirstChild = 0),
		        nextOldFiber = null,
		        step = newChildren.next();
		      null !== oldFiber && !step.done;
		      newIdx++, step = newChildren.next()
		    ) {
		      oldFiber.index > newIdx
		        ? ((nextOldFiber = oldFiber), (oldFiber = null))
		        : (nextOldFiber = oldFiber.sibling);
		      var newFiber = updateSlot(returnFiber, oldFiber, step.value, lanes);
		      if (null === newFiber) {
		        null === oldFiber && (oldFiber = nextOldFiber);
		        break;
		      }
		      shouldTrackSideEffects &&
		        oldFiber &&
		        null === newFiber.alternate &&
		        deleteChild(returnFiber, oldFiber);
		      currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);
		      null === previousNewFiber
		        ? (resultingFirstChild = newFiber)
		        : (previousNewFiber.sibling = newFiber);
		      previousNewFiber = newFiber;
		      oldFiber = nextOldFiber;
		    }
		    if (step.done)
		      return (
		        deleteRemainingChildren(returnFiber, oldFiber),
		        isHydrating && pushTreeFork(returnFiber, newIdx),
		        resultingFirstChild
		      );
		    if (null === oldFiber) {
		      for (; !step.done; newIdx++, step = newChildren.next())
		        (step = createChild(returnFiber, step.value, lanes)),
		          null !== step &&
		            ((currentFirstChild = placeChild(step, currentFirstChild, newIdx)),
		            null === previousNewFiber
		              ? (resultingFirstChild = step)
		              : (previousNewFiber.sibling = step),
		            (previousNewFiber = step));
		      isHydrating && pushTreeFork(returnFiber, newIdx);
		      return resultingFirstChild;
		    }
		    for (
		      oldFiber = mapRemainingChildren(oldFiber);
		      !step.done;
		      newIdx++, step = newChildren.next()
		    )
		      (step = updateFromMap(oldFiber, returnFiber, newIdx, step.value, lanes)),
		        null !== step &&
		          (shouldTrackSideEffects &&
		            null !== step.alternate &&
		            oldFiber.delete(null === step.key ? newIdx : step.key),
		          (currentFirstChild = placeChild(step, currentFirstChild, newIdx)),
		          null === previousNewFiber
		            ? (resultingFirstChild = step)
		            : (previousNewFiber.sibling = step),
		          (previousNewFiber = step));
		    shouldTrackSideEffects &&
		      oldFiber.forEach(function (child) {
		        return deleteChild(returnFiber, child);
		      });
		    isHydrating && pushTreeFork(returnFiber, newIdx);
		    return resultingFirstChild;
		  }
		  function reconcileChildFibersImpl(
		    returnFiber,
		    currentFirstChild,
		    newChild,
		    lanes
		  ) {
		    "object" === typeof newChild &&
		      null !== newChild &&
		      newChild.type === REACT_FRAGMENT_TYPE &&
		      null === newChild.key &&
		      (newChild = newChild.props.children);
		    if ("object" === typeof newChild && null !== newChild) {
		      switch (newChild.$$typeof) {
		        case REACT_ELEMENT_TYPE:
		          a: {
		            for (var key = newChild.key; null !== currentFirstChild; ) {
		              if (currentFirstChild.key === key) {
		                key = newChild.type;
		                if (key === REACT_FRAGMENT_TYPE) {
		                  if (7 === currentFirstChild.tag) {
		                    deleteRemainingChildren(
		                      returnFiber,
		                      currentFirstChild.sibling
		                    );
		                    lanes = useFiber(
		                      currentFirstChild,
		                      newChild.props.children
		                    );
		                    lanes.return = returnFiber;
		                    returnFiber = lanes;
		                    break a;
		                  }
		                } else if (
		                  currentFirstChild.elementType === key ||
		                  ("object" === typeof key &&
		                    null !== key &&
		                    key.$$typeof === REACT_LAZY_TYPE &&
		                    resolveLazy(key) === currentFirstChild.type)
		                ) {
		                  deleteRemainingChildren(
		                    returnFiber,
		                    currentFirstChild.sibling
		                  );
		                  lanes = useFiber(currentFirstChild, newChild.props);
		                  coerceRef(lanes, newChild);
		                  lanes.return = returnFiber;
		                  returnFiber = lanes;
		                  break a;
		                }
		                deleteRemainingChildren(returnFiber, currentFirstChild);
		                break;
		              } else deleteChild(returnFiber, currentFirstChild);
		              currentFirstChild = currentFirstChild.sibling;
		            }
		            newChild.type === REACT_FRAGMENT_TYPE
		              ? ((lanes = createFiberFromFragment(
		                  newChild.props.children,
		                  returnFiber.mode,
		                  lanes,
		                  newChild.key
		                )),
		                (lanes.return = returnFiber),
		                (returnFiber = lanes))
		              : ((lanes = createFiberFromTypeAndProps(
		                  newChild.type,
		                  newChild.key,
		                  newChild.props,
		                  null,
		                  returnFiber.mode,
		                  lanes
		                )),
		                coerceRef(lanes, newChild),
		                (lanes.return = returnFiber),
		                (returnFiber = lanes));
		          }
		          return placeSingleChild(returnFiber);
		        case REACT_PORTAL_TYPE:
		          a: {
		            for (key = newChild.key; null !== currentFirstChild; ) {
		              if (currentFirstChild.key === key)
		                if (
		                  4 === currentFirstChild.tag &&
		                  currentFirstChild.stateNode.containerInfo ===
		                    newChild.containerInfo &&
		                  currentFirstChild.stateNode.implementation ===
		                    newChild.implementation
		                ) {
		                  deleteRemainingChildren(
		                    returnFiber,
		                    currentFirstChild.sibling
		                  );
		                  lanes = useFiber(currentFirstChild, newChild.children || []);
		                  lanes.return = returnFiber;
		                  returnFiber = lanes;
		                  break a;
		                } else {
		                  deleteRemainingChildren(returnFiber, currentFirstChild);
		                  break;
		                }
		              else deleteChild(returnFiber, currentFirstChild);
		              currentFirstChild = currentFirstChild.sibling;
		            }
		            lanes = createFiberFromPortal(newChild, returnFiber.mode, lanes);
		            lanes.return = returnFiber;
		            returnFiber = lanes;
		          }
		          return placeSingleChild(returnFiber);
		        case REACT_LAZY_TYPE:
		          return (
		            (key = newChild._init),
		            (newChild = key(newChild._payload)),
		            reconcileChildFibersImpl(
		              returnFiber,
		              currentFirstChild,
		              newChild,
		              lanes
		            )
		          );
		      }
		      if (isArrayImpl(newChild))
		        return reconcileChildrenArray(
		          returnFiber,
		          currentFirstChild,
		          newChild,
		          lanes
		        );
		      if (getIteratorFn(newChild)) {
		        key = getIteratorFn(newChild);
		        if ("function" !== typeof key) throw Error(formatProdErrorMessage(150));
		        newChild = key.call(newChild);
		        return reconcileChildrenIterator(
		          returnFiber,
		          currentFirstChild,
		          newChild,
		          lanes
		        );
		      }
		      if ("function" === typeof newChild.then)
		        return reconcileChildFibersImpl(
		          returnFiber,
		          currentFirstChild,
		          unwrapThenable(newChild),
		          lanes
		        );
		      if (newChild.$$typeof === REACT_CONTEXT_TYPE)
		        return reconcileChildFibersImpl(
		          returnFiber,
		          currentFirstChild,
		          readContextDuringReconciliation(returnFiber, newChild),
		          lanes
		        );
		      throwOnInvalidObjectType(returnFiber, newChild);
		    }
		    return ("string" === typeof newChild && "" !== newChild) ||
		      "number" === typeof newChild ||
		      "bigint" === typeof newChild
		      ? ((newChild = "" + newChild),
		        null !== currentFirstChild && 6 === currentFirstChild.tag
		          ? (deleteRemainingChildren(returnFiber, currentFirstChild.sibling),
		            (lanes = useFiber(currentFirstChild, newChild)),
		            (lanes.return = returnFiber),
		            (returnFiber = lanes))
		          : (deleteRemainingChildren(returnFiber, currentFirstChild),
		            (lanes = createFiberFromText(newChild, returnFiber.mode, lanes)),
		            (lanes.return = returnFiber),
		            (returnFiber = lanes)),
		        placeSingleChild(returnFiber))
		      : deleteRemainingChildren(returnFiber, currentFirstChild);
		  }
		  return function (returnFiber, currentFirstChild, newChild, lanes) {
		    try {
		      thenableIndexCounter = 0;
		      var firstChildFiber = reconcileChildFibersImpl(
		        returnFiber,
		        currentFirstChild,
		        newChild,
		        lanes
		      );
		      thenableState = null;
		      return firstChildFiber;
		    } catch (x) {
		      if (x === SuspenseException || x === SuspenseActionException) throw x;
		      var fiber = createFiberImplClass(29, x, null, returnFiber.mode);
		      fiber.lanes = lanes;
		      fiber.return = returnFiber;
		      return fiber;
		    } finally {
		    }
		  };
		}
		var reconcileChildFibers = createChildReconciler(true),
		  mountChildFibers = createChildReconciler(false),
		  suspenseHandlerStackCursor = createCursor(null),
		  shellBoundary = null;
		function pushPrimaryTreeSuspenseHandler(handler) {
		  var current = handler.alternate;
		  push(suspenseStackCursor, suspenseStackCursor.current & 1);
		  push(suspenseHandlerStackCursor, handler);
		  null === shellBoundary &&
		    (null === current || null !== currentTreeHiddenStackCursor.current
		      ? (shellBoundary = handler)
		      : null !== current.memoizedState && (shellBoundary = handler));
		}
		function pushOffscreenSuspenseHandler(fiber) {
		  if (22 === fiber.tag) {
		    if (
		      (push(suspenseStackCursor, suspenseStackCursor.current),
		      push(suspenseHandlerStackCursor, fiber),
		      null === shellBoundary)
		    ) {
		      var current = fiber.alternate;
		      null !== current &&
		        null !== current.memoizedState &&
		        (shellBoundary = fiber);
		    }
		  } else reuseSuspenseHandlerOnStack();
		}
		function reuseSuspenseHandlerOnStack() {
		  push(suspenseStackCursor, suspenseStackCursor.current);
		  push(suspenseHandlerStackCursor, suspenseHandlerStackCursor.current);
		}
		function popSuspenseHandler(fiber) {
		  pop(suspenseHandlerStackCursor);
		  shellBoundary === fiber && (shellBoundary = null);
		  pop(suspenseStackCursor);
		}
		var suspenseStackCursor = createCursor(0);
		function findFirstSuspended(row) {
		  for (var node = row; null !== node; ) {
		    if (13 === node.tag) {
		      var state = node.memoizedState;
		      if (
		        null !== state &&
		        ((state = state.dehydrated),
		        null === state ||
		          "$?" === state.data ||
		          isSuspenseInstanceFallback(state))
		      )
		        return node;
		    } else if (19 === node.tag && void 0 !== node.memoizedProps.revealOrder) {
		      if (0 !== (node.flags & 128)) return node;
		    } else if (null !== node.child) {
		      node.child.return = node;
		      node = node.child;
		      continue;
		    }
		    if (node === row) break;
		    for (; null === node.sibling; ) {
		      if (null === node.return || node.return === row) return null;
		      node = node.return;
		    }
		    node.sibling.return = node.return;
		    node = node.sibling;
		  }
		  return null;
		}
		function applyDerivedStateFromProps(
		  workInProgress,
		  ctor,
		  getDerivedStateFromProps,
		  nextProps
		) {
		  ctor = workInProgress.memoizedState;
		  getDerivedStateFromProps = getDerivedStateFromProps(nextProps, ctor);
		  getDerivedStateFromProps =
		    null === getDerivedStateFromProps || void 0 === getDerivedStateFromProps
		      ? ctor
		      : assign({}, ctor, getDerivedStateFromProps);
		  workInProgress.memoizedState = getDerivedStateFromProps;
		  0 === workInProgress.lanes &&
		    (workInProgress.updateQueue.baseState = getDerivedStateFromProps);
		}
		var classComponentUpdater = {
		  enqueueSetState: function (inst, payload, callback) {
		    inst = inst._reactInternals;
		    var lane = requestUpdateLane(),
		      update = createUpdate(lane);
		    update.payload = payload;
		    void 0 !== callback && null !== callback && (update.callback = callback);
		    payload = enqueueUpdate(inst, update, lane);
		    null !== payload &&
		      (scheduleUpdateOnFiber(payload, inst, lane),
		      entangleTransitions(payload, inst, lane));
		  },
		  enqueueReplaceState: function (inst, payload, callback) {
		    inst = inst._reactInternals;
		    var lane = requestUpdateLane(),
		      update = createUpdate(lane);
		    update.tag = 1;
		    update.payload = payload;
		    void 0 !== callback && null !== callback && (update.callback = callback);
		    payload = enqueueUpdate(inst, update, lane);
		    null !== payload &&
		      (scheduleUpdateOnFiber(payload, inst, lane),
		      entangleTransitions(payload, inst, lane));
		  },
		  enqueueForceUpdate: function (inst, callback) {
		    inst = inst._reactInternals;
		    var lane = requestUpdateLane(),
		      update = createUpdate(lane);
		    update.tag = 2;
		    void 0 !== callback && null !== callback && (update.callback = callback);
		    callback = enqueueUpdate(inst, update, lane);
		    null !== callback &&
		      (scheduleUpdateOnFiber(callback, inst, lane),
		      entangleTransitions(callback, inst, lane));
		  }
		};
		function checkShouldComponentUpdate(
		  workInProgress,
		  ctor,
		  oldProps,
		  newProps,
		  oldState,
		  newState,
		  nextContext
		) {
		  workInProgress = workInProgress.stateNode;
		  return "function" === typeof workInProgress.shouldComponentUpdate
		    ? workInProgress.shouldComponentUpdate(newProps, newState, nextContext)
		    : ctor.prototype && ctor.prototype.isPureReactComponent
		      ? !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState)
		      : true;
		}
		function callComponentWillReceiveProps(
		  workInProgress,
		  instance,
		  newProps,
		  nextContext
		) {
		  workInProgress = instance.state;
		  "function" === typeof instance.componentWillReceiveProps &&
		    instance.componentWillReceiveProps(newProps, nextContext);
		  "function" === typeof instance.UNSAFE_componentWillReceiveProps &&
		    instance.UNSAFE_componentWillReceiveProps(newProps, nextContext);
		  instance.state !== workInProgress &&
		    classComponentUpdater.enqueueReplaceState(instance, instance.state, null);
		}
		function resolveClassComponentProps(Component, baseProps) {
		  var newProps = baseProps;
		  if ("ref" in baseProps) {
		    newProps = {};
		    for (var propName in baseProps)
		      "ref" !== propName && (newProps[propName] = baseProps[propName]);
		  }
		  if ((Component = Component.defaultProps)) {
		    newProps === baseProps && (newProps = assign({}, newProps));
		    for (var propName$73 in Component)
		      void 0 === newProps[propName$73] &&
		        (newProps[propName$73] = Component[propName$73]);
		  }
		  return newProps;
		}
		var reportGlobalError =
		  "function" === typeof reportError
		    ? reportError
		    : function (error) {
		        if (
		          "object" === typeof window &&
		          "function" === typeof window.ErrorEvent
		        ) {
		          var event = new window.ErrorEvent("error", {
		            bubbles: true,
		            cancelable: true,
		            message:
		              "object" === typeof error &&
		              null !== error &&
		              "string" === typeof error.message
		                ? String(error.message)
		                : String(error),
		            error: error
		          });
		          if (!window.dispatchEvent(event)) return;
		        } else if (
		          "object" === typeof process &&
		          "function" === typeof process.emit
		        ) {
		          process.emit("uncaughtException", error);
		          return;
		        }
		        console.error(error);
		      };
		function defaultOnUncaughtError(error) {
		  reportGlobalError(error);
		}
		function defaultOnCaughtError(error) {
		  console.error(error);
		}
		function defaultOnRecoverableError(error) {
		  reportGlobalError(error);
		}
		function logUncaughtError(root, errorInfo) {
		  try {
		    var onUncaughtError = root.onUncaughtError;
		    onUncaughtError(errorInfo.value, { componentStack: errorInfo.stack });
		  } catch (e$74) {
		    setTimeout(function () {
		      throw e$74;
		    });
		  }
		}
		function logCaughtError(root, boundary, errorInfo) {
		  try {
		    var onCaughtError = root.onCaughtError;
		    onCaughtError(errorInfo.value, {
		      componentStack: errorInfo.stack,
		      errorBoundary: 1 === boundary.tag ? boundary.stateNode : null
		    });
		  } catch (e$75) {
		    setTimeout(function () {
		      throw e$75;
		    });
		  }
		}
		function createRootErrorUpdate(root, errorInfo, lane) {
		  lane = createUpdate(lane);
		  lane.tag = 3;
		  lane.payload = { element: null };
		  lane.callback = function () {
		    logUncaughtError(root, errorInfo);
		  };
		  return lane;
		}
		function createClassErrorUpdate(lane) {
		  lane = createUpdate(lane);
		  lane.tag = 3;
		  return lane;
		}
		function initializeClassErrorUpdate(update, root, fiber, errorInfo) {
		  var getDerivedStateFromError = fiber.type.getDerivedStateFromError;
		  if ("function" === typeof getDerivedStateFromError) {
		    var error = errorInfo.value;
		    update.payload = function () {
		      return getDerivedStateFromError(error);
		    };
		    update.callback = function () {
		      logCaughtError(root, fiber, errorInfo);
		    };
		  }
		  var inst = fiber.stateNode;
		  null !== inst &&
		    "function" === typeof inst.componentDidCatch &&
		    (update.callback = function () {
		      logCaughtError(root, fiber, errorInfo);
		      "function" !== typeof getDerivedStateFromError &&
		        (null === legacyErrorBoundariesThatAlreadyFailed
		          ? (legacyErrorBoundariesThatAlreadyFailed = new Set([this]))
		          : legacyErrorBoundariesThatAlreadyFailed.add(this));
		      var stack = errorInfo.stack;
		      this.componentDidCatch(errorInfo.value, {
		        componentStack: null !== stack ? stack : ""
		      });
		    });
		}
		function throwException(
		  root,
		  returnFiber,
		  sourceFiber,
		  value,
		  rootRenderLanes
		) {
		  sourceFiber.flags |= 32768;
		  if (
		    null !== value &&
		    "object" === typeof value &&
		    "function" === typeof value.then
		  ) {
		    returnFiber = sourceFiber.alternate;
		    null !== returnFiber &&
		      propagateParentContextChanges(
		        returnFiber,
		        sourceFiber,
		        rootRenderLanes,
		        true
		      );
		    sourceFiber = suspenseHandlerStackCursor.current;
		    if (null !== sourceFiber) {
		      switch (sourceFiber.tag) {
		        case 13:
		          return (
		            null === shellBoundary
		              ? renderDidSuspendDelayIfPossible()
		              : null === sourceFiber.alternate &&
		                0 === workInProgressRootExitStatus &&
		                (workInProgressRootExitStatus = 3),
		            (sourceFiber.flags &= -257),
		            (sourceFiber.flags |= 65536),
		            (sourceFiber.lanes = rootRenderLanes),
		            value === noopSuspenseyCommitThenable
		              ? (sourceFiber.flags |= 16384)
		              : ((returnFiber = sourceFiber.updateQueue),
		                null === returnFiber
		                  ? (sourceFiber.updateQueue = new Set([value]))
		                  : returnFiber.add(value),
		                attachPingListener(root, value, rootRenderLanes)),
		            false
		          );
		        case 22:
		          return (
		            (sourceFiber.flags |= 65536),
		            value === noopSuspenseyCommitThenable
		              ? (sourceFiber.flags |= 16384)
		              : ((returnFiber = sourceFiber.updateQueue),
		                null === returnFiber
		                  ? ((returnFiber = {
		                      transitions: null,
		                      markerInstances: null,
		                      retryQueue: new Set([value])
		                    }),
		                    (sourceFiber.updateQueue = returnFiber))
		                  : ((sourceFiber = returnFiber.retryQueue),
		                    null === sourceFiber
		                      ? (returnFiber.retryQueue = new Set([value]))
		                      : sourceFiber.add(value)),
		                attachPingListener(root, value, rootRenderLanes)),
		            false
		          );
		      }
		      throw Error(formatProdErrorMessage(435, sourceFiber.tag));
		    }
		    attachPingListener(root, value, rootRenderLanes);
		    renderDidSuspendDelayIfPossible();
		    return false;
		  }
		  if (isHydrating)
		    return (
		      (returnFiber = suspenseHandlerStackCursor.current),
		      null !== returnFiber
		        ? (0 === (returnFiber.flags & 65536) && (returnFiber.flags |= 256),
		          (returnFiber.flags |= 65536),
		          (returnFiber.lanes = rootRenderLanes),
		          value !== HydrationMismatchException &&
		            ((root = Error(formatProdErrorMessage(422), { cause: value })),
		            queueHydrationError(createCapturedValueAtFiber(root, sourceFiber))))
		        : (value !== HydrationMismatchException &&
		            ((returnFiber = Error(formatProdErrorMessage(423), {
		              cause: value
		            })),
		            queueHydrationError(
		              createCapturedValueAtFiber(returnFiber, sourceFiber)
		            )),
		          (root = root.current.alternate),
		          (root.flags |= 65536),
		          (rootRenderLanes &= -rootRenderLanes),
		          (root.lanes |= rootRenderLanes),
		          (value = createCapturedValueAtFiber(value, sourceFiber)),
		          (rootRenderLanes = createRootErrorUpdate(
		            root.stateNode,
		            value,
		            rootRenderLanes
		          )),
		          enqueueCapturedUpdate(root, rootRenderLanes),
		          4 !== workInProgressRootExitStatus &&
		            (workInProgressRootExitStatus = 2)),
		      false
		    );
		  var wrapperError = Error(formatProdErrorMessage(520), { cause: value });
		  wrapperError = createCapturedValueAtFiber(wrapperError, sourceFiber);
		  null === workInProgressRootConcurrentErrors
		    ? (workInProgressRootConcurrentErrors = [wrapperError])
		    : workInProgressRootConcurrentErrors.push(wrapperError);
		  4 !== workInProgressRootExitStatus && (workInProgressRootExitStatus = 2);
		  if (null === returnFiber) return true;
		  value = createCapturedValueAtFiber(value, sourceFiber);
		  sourceFiber = returnFiber;
		  do {
		    switch (sourceFiber.tag) {
		      case 3:
		        return (
		          (sourceFiber.flags |= 65536),
		          (root = rootRenderLanes & -rootRenderLanes),
		          (sourceFiber.lanes |= root),
		          (root = createRootErrorUpdate(sourceFiber.stateNode, value, root)),
		          enqueueCapturedUpdate(sourceFiber, root),
		          false
		        );
		      case 1:
		        if (
		          ((returnFiber = sourceFiber.type),
		          (wrapperError = sourceFiber.stateNode),
		          0 === (sourceFiber.flags & 128) &&
		            ("function" === typeof returnFiber.getDerivedStateFromError ||
		              (null !== wrapperError &&
		                "function" === typeof wrapperError.componentDidCatch &&
		                (null === legacyErrorBoundariesThatAlreadyFailed ||
		                  !legacyErrorBoundariesThatAlreadyFailed.has(wrapperError)))))
		        )
		          return (
		            (sourceFiber.flags |= 65536),
		            (rootRenderLanes &= -rootRenderLanes),
		            (sourceFiber.lanes |= rootRenderLanes),
		            (rootRenderLanes = createClassErrorUpdate(rootRenderLanes)),
		            initializeClassErrorUpdate(
		              rootRenderLanes,
		              root,
		              sourceFiber,
		              value
		            ),
		            enqueueCapturedUpdate(sourceFiber, rootRenderLanes),
		            false
		          );
		    }
		    sourceFiber = sourceFiber.return;
		  } while (null !== sourceFiber);
		  return false;
		}
		var SelectiveHydrationException = Error(formatProdErrorMessage(461)),
		  didReceiveUpdate = false;
		function reconcileChildren(current, workInProgress, nextChildren, renderLanes) {
		  workInProgress.child =
		    null === current
		      ? mountChildFibers(workInProgress, null, nextChildren, renderLanes)
		      : reconcileChildFibers(
		          workInProgress,
		          current.child,
		          nextChildren,
		          renderLanes
		        );
		}
		function updateForwardRef(
		  current,
		  workInProgress,
		  Component,
		  nextProps,
		  renderLanes
		) {
		  Component = Component.render;
		  var ref = workInProgress.ref;
		  if ("ref" in nextProps) {
		    var propsWithoutRef = {};
		    for (var key in nextProps)
		      "ref" !== key && (propsWithoutRef[key] = nextProps[key]);
		  } else propsWithoutRef = nextProps;
		  prepareToReadContext(workInProgress);
		  nextProps = renderWithHooks(
		    current,
		    workInProgress,
		    Component,
		    propsWithoutRef,
		    ref,
		    renderLanes
		  );
		  key = checkDidRenderIdHook();
		  if (null !== current && !didReceiveUpdate)
		    return (
		      bailoutHooks(current, workInProgress, renderLanes),
		      bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes)
		    );
		  isHydrating && key && pushMaterializedTreeId(workInProgress);
		  workInProgress.flags |= 1;
		  reconcileChildren(current, workInProgress, nextProps, renderLanes);
		  return workInProgress.child;
		}
		function updateMemoComponent(
		  current,
		  workInProgress,
		  Component,
		  nextProps,
		  renderLanes
		) {
		  if (null === current) {
		    var type = Component.type;
		    if (
		      "function" === typeof type &&
		      !shouldConstruct(type) &&
		      void 0 === type.defaultProps &&
		      null === Component.compare
		    )
		      return (
		        (workInProgress.tag = 15),
		        (workInProgress.type = type),
		        updateSimpleMemoComponent(
		          current,
		          workInProgress,
		          type,
		          nextProps,
		          renderLanes
		        )
		      );
		    current = createFiberFromTypeAndProps(
		      Component.type,
		      null,
		      nextProps,
		      workInProgress,
		      workInProgress.mode,
		      renderLanes
		    );
		    current.ref = workInProgress.ref;
		    current.return = workInProgress;
		    return (workInProgress.child = current);
		  }
		  type = current.child;
		  if (!checkScheduledUpdateOrContext(current, renderLanes)) {
		    var prevProps = type.memoizedProps;
		    Component = Component.compare;
		    Component = null !== Component ? Component : shallowEqual;
		    if (Component(prevProps, nextProps) && current.ref === workInProgress.ref)
		      return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
		  }
		  workInProgress.flags |= 1;
		  current = createWorkInProgress(type, nextProps);
		  current.ref = workInProgress.ref;
		  current.return = workInProgress;
		  return (workInProgress.child = current);
		}
		function updateSimpleMemoComponent(
		  current,
		  workInProgress,
		  Component,
		  nextProps,
		  renderLanes
		) {
		  if (null !== current) {
		    var prevProps = current.memoizedProps;
		    if (
		      shallowEqual(prevProps, nextProps) &&
		      current.ref === workInProgress.ref
		    )
		      if (
		        ((didReceiveUpdate = false),
		        (workInProgress.pendingProps = nextProps = prevProps),
		        checkScheduledUpdateOrContext(current, renderLanes))
		      )
		        0 !== (current.flags & 131072) && (didReceiveUpdate = true);
		      else
		        return (
		          (workInProgress.lanes = current.lanes),
		          bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes)
		        );
		  }
		  return updateFunctionComponent(
		    current,
		    workInProgress,
		    Component,
		    nextProps,
		    renderLanes
		  );
		}
		function updateOffscreenComponent(current, workInProgress, renderLanes) {
		  var nextProps = workInProgress.pendingProps,
		    nextChildren = nextProps.children,
		    prevState = null !== current ? current.memoizedState : null;
		  if ("hidden" === nextProps.mode) {
		    if (0 !== (workInProgress.flags & 128)) {
		      nextProps =
		        null !== prevState ? prevState.baseLanes | renderLanes : renderLanes;
		      if (null !== current) {
		        nextChildren = workInProgress.child = current.child;
		        for (prevState = 0; null !== nextChildren; )
		          (prevState =
		            prevState | nextChildren.lanes | nextChildren.childLanes),
		            (nextChildren = nextChildren.sibling);
		        workInProgress.childLanes = prevState & ~nextProps;
		      } else (workInProgress.childLanes = 0), (workInProgress.child = null);
		      return deferHiddenOffscreenComponent(
		        current,
		        workInProgress,
		        nextProps,
		        renderLanes
		      );
		    }
		    if (0 !== (renderLanes & 536870912))
		      (workInProgress.memoizedState = { baseLanes: 0, cachePool: null }),
		        null !== current &&
		          pushTransition(
		            workInProgress,
		            null !== prevState ? prevState.cachePool : null
		          ),
		        null !== prevState
		          ? pushHiddenContext(workInProgress, prevState)
		          : reuseHiddenContextOnStack(),
		        pushOffscreenSuspenseHandler(workInProgress);
		    else
		      return (
		        (workInProgress.lanes = workInProgress.childLanes = 536870912),
		        deferHiddenOffscreenComponent(
		          current,
		          workInProgress,
		          null !== prevState ? prevState.baseLanes | renderLanes : renderLanes,
		          renderLanes
		        )
		      );
		  } else
		    null !== prevState
		      ? (pushTransition(workInProgress, prevState.cachePool),
		        pushHiddenContext(workInProgress, prevState),
		        reuseSuspenseHandlerOnStack(),
		        (workInProgress.memoizedState = null))
		      : (null !== current && pushTransition(workInProgress, null),
		        reuseHiddenContextOnStack(),
		        reuseSuspenseHandlerOnStack());
		  reconcileChildren(current, workInProgress, nextChildren, renderLanes);
		  return workInProgress.child;
		}
		function deferHiddenOffscreenComponent(
		  current,
		  workInProgress,
		  nextBaseLanes,
		  renderLanes
		) {
		  var JSCompiler_inline_result = peekCacheFromPool();
		  JSCompiler_inline_result =
		    null === JSCompiler_inline_result
		      ? null
		      : { parent: CacheContext._currentValue, pool: JSCompiler_inline_result };
		  workInProgress.memoizedState = {
		    baseLanes: nextBaseLanes,
		    cachePool: JSCompiler_inline_result
		  };
		  null !== current && pushTransition(workInProgress, null);
		  reuseHiddenContextOnStack();
		  pushOffscreenSuspenseHandler(workInProgress);
		  null !== current &&
		    propagateParentContextChanges(current, workInProgress, renderLanes, true);
		  return null;
		}
		function markRef(current, workInProgress) {
		  var ref = workInProgress.ref;
		  if (null === ref)
		    null !== current &&
		      null !== current.ref &&
		      (workInProgress.flags |= 4194816);
		  else {
		    if ("function" !== typeof ref && "object" !== typeof ref)
		      throw Error(formatProdErrorMessage(284));
		    if (null === current || current.ref !== ref)
		      workInProgress.flags |= 4194816;
		  }
		}
		function updateFunctionComponent(
		  current,
		  workInProgress,
		  Component,
		  nextProps,
		  renderLanes
		) {
		  prepareToReadContext(workInProgress);
		  Component = renderWithHooks(
		    current,
		    workInProgress,
		    Component,
		    nextProps,
		    void 0,
		    renderLanes
		  );
		  nextProps = checkDidRenderIdHook();
		  if (null !== current && !didReceiveUpdate)
		    return (
		      bailoutHooks(current, workInProgress, renderLanes),
		      bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes)
		    );
		  isHydrating && nextProps && pushMaterializedTreeId(workInProgress);
		  workInProgress.flags |= 1;
		  reconcileChildren(current, workInProgress, Component, renderLanes);
		  return workInProgress.child;
		}
		function replayFunctionComponent(
		  current,
		  workInProgress,
		  nextProps,
		  Component,
		  secondArg,
		  renderLanes
		) {
		  prepareToReadContext(workInProgress);
		  workInProgress.updateQueue = null;
		  nextProps = renderWithHooksAgain(
		    workInProgress,
		    Component,
		    nextProps,
		    secondArg
		  );
		  finishRenderingHooks(current);
		  Component = checkDidRenderIdHook();
		  if (null !== current && !didReceiveUpdate)
		    return (
		      bailoutHooks(current, workInProgress, renderLanes),
		      bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes)
		    );
		  isHydrating && Component && pushMaterializedTreeId(workInProgress);
		  workInProgress.flags |= 1;
		  reconcileChildren(current, workInProgress, nextProps, renderLanes);
		  return workInProgress.child;
		}
		function updateClassComponent(
		  current,
		  workInProgress,
		  Component,
		  nextProps,
		  renderLanes
		) {
		  prepareToReadContext(workInProgress);
		  if (null === workInProgress.stateNode) {
		    var context = emptyContextObject,
		      contextType = Component.contextType;
		    "object" === typeof contextType &&
		      null !== contextType &&
		      (context = readContext(contextType));
		    context = new Component(nextProps, context);
		    workInProgress.memoizedState =
		      null !== context.state && void 0 !== context.state ? context.state : null;
		    context.updater = classComponentUpdater;
		    workInProgress.stateNode = context;
		    context._reactInternals = workInProgress;
		    context = workInProgress.stateNode;
		    context.props = nextProps;
		    context.state = workInProgress.memoizedState;
		    context.refs = {};
		    initializeUpdateQueue(workInProgress);
		    contextType = Component.contextType;
		    context.context =
		      "object" === typeof contextType && null !== contextType
		        ? readContext(contextType)
		        : emptyContextObject;
		    context.state = workInProgress.memoizedState;
		    contextType = Component.getDerivedStateFromProps;
		    "function" === typeof contextType &&
		      (applyDerivedStateFromProps(
		        workInProgress,
		        Component,
		        contextType,
		        nextProps
		      ),
		      (context.state = workInProgress.memoizedState));
		    "function" === typeof Component.getDerivedStateFromProps ||
		      "function" === typeof context.getSnapshotBeforeUpdate ||
		      ("function" !== typeof context.UNSAFE_componentWillMount &&
		        "function" !== typeof context.componentWillMount) ||
		      ((contextType = context.state),
		      "function" === typeof context.componentWillMount &&
		        context.componentWillMount(),
		      "function" === typeof context.UNSAFE_componentWillMount &&
		        context.UNSAFE_componentWillMount(),
		      contextType !== context.state &&
		        classComponentUpdater.enqueueReplaceState(context, context.state, null),
		      processUpdateQueue(workInProgress, nextProps, context, renderLanes),
		      suspendIfUpdateReadFromEntangledAsyncAction(),
		      (context.state = workInProgress.memoizedState));
		    "function" === typeof context.componentDidMount &&
		      (workInProgress.flags |= 4194308);
		    nextProps = true;
		  } else if (null === current) {
		    context = workInProgress.stateNode;
		    var unresolvedOldProps = workInProgress.memoizedProps,
		      oldProps = resolveClassComponentProps(Component, unresolvedOldProps);
		    context.props = oldProps;
		    var oldContext = context.context,
		      contextType$jscomp$0 = Component.contextType;
		    contextType = emptyContextObject;
		    "object" === typeof contextType$jscomp$0 &&
		      null !== contextType$jscomp$0 &&
		      (contextType = readContext(contextType$jscomp$0));
		    var getDerivedStateFromProps = Component.getDerivedStateFromProps;
		    contextType$jscomp$0 =
		      "function" === typeof getDerivedStateFromProps ||
		      "function" === typeof context.getSnapshotBeforeUpdate;
		    unresolvedOldProps = workInProgress.pendingProps !== unresolvedOldProps;
		    contextType$jscomp$0 ||
		      ("function" !== typeof context.UNSAFE_componentWillReceiveProps &&
		        "function" !== typeof context.componentWillReceiveProps) ||
		      ((unresolvedOldProps || oldContext !== contextType) &&
		        callComponentWillReceiveProps(
		          workInProgress,
		          context,
		          nextProps,
		          contextType
		        ));
		    hasForceUpdate = false;
		    var oldState = workInProgress.memoizedState;
		    context.state = oldState;
		    processUpdateQueue(workInProgress, nextProps, context, renderLanes);
		    suspendIfUpdateReadFromEntangledAsyncAction();
		    oldContext = workInProgress.memoizedState;
		    unresolvedOldProps || oldState !== oldContext || hasForceUpdate
		      ? ("function" === typeof getDerivedStateFromProps &&
		          (applyDerivedStateFromProps(
		            workInProgress,
		            Component,
		            getDerivedStateFromProps,
		            nextProps
		          ),
		          (oldContext = workInProgress.memoizedState)),
		        (oldProps =
		          hasForceUpdate ||
		          checkShouldComponentUpdate(
		            workInProgress,
		            Component,
		            oldProps,
		            nextProps,
		            oldState,
		            oldContext,
		            contextType
		          ))
		          ? (contextType$jscomp$0 ||
		              ("function" !== typeof context.UNSAFE_componentWillMount &&
		                "function" !== typeof context.componentWillMount) ||
		              ("function" === typeof context.componentWillMount &&
		                context.componentWillMount(),
		              "function" === typeof context.UNSAFE_componentWillMount &&
		                context.UNSAFE_componentWillMount()),
		            "function" === typeof context.componentDidMount &&
		              (workInProgress.flags |= 4194308))
		          : ("function" === typeof context.componentDidMount &&
		              (workInProgress.flags |= 4194308),
		            (workInProgress.memoizedProps = nextProps),
		            (workInProgress.memoizedState = oldContext)),
		        (context.props = nextProps),
		        (context.state = oldContext),
		        (context.context = contextType),
		        (nextProps = oldProps))
		      : ("function" === typeof context.componentDidMount &&
		          (workInProgress.flags |= 4194308),
		        (nextProps = false));
		  } else {
		    context = workInProgress.stateNode;
		    cloneUpdateQueue(current, workInProgress);
		    contextType = workInProgress.memoizedProps;
		    contextType$jscomp$0 = resolveClassComponentProps(Component, contextType);
		    context.props = contextType$jscomp$0;
		    getDerivedStateFromProps = workInProgress.pendingProps;
		    oldState = context.context;
		    oldContext = Component.contextType;
		    oldProps = emptyContextObject;
		    "object" === typeof oldContext &&
		      null !== oldContext &&
		      (oldProps = readContext(oldContext));
		    unresolvedOldProps = Component.getDerivedStateFromProps;
		    (oldContext =
		      "function" === typeof unresolvedOldProps ||
		      "function" === typeof context.getSnapshotBeforeUpdate) ||
		      ("function" !== typeof context.UNSAFE_componentWillReceiveProps &&
		        "function" !== typeof context.componentWillReceiveProps) ||
		      ((contextType !== getDerivedStateFromProps || oldState !== oldProps) &&
		        callComponentWillReceiveProps(
		          workInProgress,
		          context,
		          nextProps,
		          oldProps
		        ));
		    hasForceUpdate = false;
		    oldState = workInProgress.memoizedState;
		    context.state = oldState;
		    processUpdateQueue(workInProgress, nextProps, context, renderLanes);
		    suspendIfUpdateReadFromEntangledAsyncAction();
		    var newState = workInProgress.memoizedState;
		    contextType !== getDerivedStateFromProps ||
		    oldState !== newState ||
		    hasForceUpdate ||
		    (null !== current &&
		      null !== current.dependencies &&
		      checkIfContextChanged(current.dependencies))
		      ? ("function" === typeof unresolvedOldProps &&
		          (applyDerivedStateFromProps(
		            workInProgress,
		            Component,
		            unresolvedOldProps,
		            nextProps
		          ),
		          (newState = workInProgress.memoizedState)),
		        (contextType$jscomp$0 =
		          hasForceUpdate ||
		          checkShouldComponentUpdate(
		            workInProgress,
		            Component,
		            contextType$jscomp$0,
		            nextProps,
		            oldState,
		            newState,
		            oldProps
		          ) ||
		          (null !== current &&
		            null !== current.dependencies &&
		            checkIfContextChanged(current.dependencies)))
		          ? (oldContext ||
		              ("function" !== typeof context.UNSAFE_componentWillUpdate &&
		                "function" !== typeof context.componentWillUpdate) ||
		              ("function" === typeof context.componentWillUpdate &&
		                context.componentWillUpdate(nextProps, newState, oldProps),
		              "function" === typeof context.UNSAFE_componentWillUpdate &&
		                context.UNSAFE_componentWillUpdate(
		                  nextProps,
		                  newState,
		                  oldProps
		                )),
		            "function" === typeof context.componentDidUpdate &&
		              (workInProgress.flags |= 4),
		            "function" === typeof context.getSnapshotBeforeUpdate &&
		              (workInProgress.flags |= 1024))
		          : ("function" !== typeof context.componentDidUpdate ||
		              (contextType === current.memoizedProps &&
		                oldState === current.memoizedState) ||
		              (workInProgress.flags |= 4),
		            "function" !== typeof context.getSnapshotBeforeUpdate ||
		              (contextType === current.memoizedProps &&
		                oldState === current.memoizedState) ||
		              (workInProgress.flags |= 1024),
		            (workInProgress.memoizedProps = nextProps),
		            (workInProgress.memoizedState = newState)),
		        (context.props = nextProps),
		        (context.state = newState),
		        (context.context = oldProps),
		        (nextProps = contextType$jscomp$0))
		      : ("function" !== typeof context.componentDidUpdate ||
		          (contextType === current.memoizedProps &&
		            oldState === current.memoizedState) ||
		          (workInProgress.flags |= 4),
		        "function" !== typeof context.getSnapshotBeforeUpdate ||
		          (contextType === current.memoizedProps &&
		            oldState === current.memoizedState) ||
		          (workInProgress.flags |= 1024),
		        (nextProps = false));
		  }
		  context = nextProps;
		  markRef(current, workInProgress);
		  nextProps = 0 !== (workInProgress.flags & 128);
		  context || nextProps
		    ? ((context = workInProgress.stateNode),
		      (Component =
		        nextProps && "function" !== typeof Component.getDerivedStateFromError
		          ? null
		          : context.render()),
		      (workInProgress.flags |= 1),
		      null !== current && nextProps
		        ? ((workInProgress.child = reconcileChildFibers(
		            workInProgress,
		            current.child,
		            null,
		            renderLanes
		          )),
		          (workInProgress.child = reconcileChildFibers(
		            workInProgress,
		            null,
		            Component,
		            renderLanes
		          )))
		        : reconcileChildren(current, workInProgress, Component, renderLanes),
		      (workInProgress.memoizedState = context.state),
		      (current = workInProgress.child))
		    : (current = bailoutOnAlreadyFinishedWork(
		        current,
		        workInProgress,
		        renderLanes
		      ));
		  return current;
		}
		function mountHostRootWithoutHydrating(
		  current,
		  workInProgress,
		  nextChildren,
		  renderLanes
		) {
		  resetHydrationState();
		  workInProgress.flags |= 256;
		  reconcileChildren(current, workInProgress, nextChildren, renderLanes);
		  return workInProgress.child;
		}
		var SUSPENDED_MARKER = {
		  dehydrated: null,
		  treeContext: null,
		  retryLane: 0,
		  hydrationErrors: null
		};
		function mountSuspenseOffscreenState(renderLanes) {
		  return { baseLanes: renderLanes, cachePool: getSuspendedCache() };
		}
		function getRemainingWorkInPrimaryTree(
		  current,
		  primaryTreeDidDefer,
		  renderLanes
		) {
		  current = null !== current ? current.childLanes & ~renderLanes : 0;
		  primaryTreeDidDefer && (current |= workInProgressDeferredLane);
		  return current;
		}
		function updateSuspenseComponent(current, workInProgress, renderLanes) {
		  var nextProps = workInProgress.pendingProps,
		    showFallback = false,
		    didSuspend = 0 !== (workInProgress.flags & 128),
		    JSCompiler_temp;
		  (JSCompiler_temp = didSuspend) ||
		    (JSCompiler_temp =
		      null !== current && null === current.memoizedState
		        ? false
		        : 0 !== (suspenseStackCursor.current & 2));
		  JSCompiler_temp && ((showFallback = true), (workInProgress.flags &= -129));
		  JSCompiler_temp = 0 !== (workInProgress.flags & 32);
		  workInProgress.flags &= -33;
		  if (null === current) {
		    if (isHydrating) {
		      showFallback
		        ? pushPrimaryTreeSuspenseHandler(workInProgress)
		        : reuseSuspenseHandlerOnStack();
		      if (isHydrating) {
		        var nextInstance = nextHydratableInstance,
		          JSCompiler_temp$jscomp$0;
		        if ((JSCompiler_temp$jscomp$0 = nextInstance)) {
		          c: {
		            JSCompiler_temp$jscomp$0 = nextInstance;
		            for (
		              nextInstance = rootOrSingletonContext;
		              8 !== JSCompiler_temp$jscomp$0.nodeType;

		            ) {
		              if (!nextInstance) {
		                nextInstance = null;
		                break c;
		              }
		              JSCompiler_temp$jscomp$0 = getNextHydratable(
		                JSCompiler_temp$jscomp$0.nextSibling
		              );
		              if (null === JSCompiler_temp$jscomp$0) {
		                nextInstance = null;
		                break c;
		              }
		            }
		            nextInstance = JSCompiler_temp$jscomp$0;
		          }
		          null !== nextInstance
		            ? ((workInProgress.memoizedState = {
		                dehydrated: nextInstance,
		                treeContext:
		                  null !== treeContextProvider
		                    ? { id: treeContextId, overflow: treeContextOverflow }
		                    : null,
		                retryLane: 536870912,
		                hydrationErrors: null
		              }),
		              (JSCompiler_temp$jscomp$0 = createFiberImplClass(
		                18,
		                null,
		                null,
		                0
		              )),
		              (JSCompiler_temp$jscomp$0.stateNode = nextInstance),
		              (JSCompiler_temp$jscomp$0.return = workInProgress),
		              (workInProgress.child = JSCompiler_temp$jscomp$0),
		              (hydrationParentFiber = workInProgress),
		              (nextHydratableInstance = null),
		              (JSCompiler_temp$jscomp$0 = true))
		            : (JSCompiler_temp$jscomp$0 = false);
		        }
		        JSCompiler_temp$jscomp$0 || throwOnHydrationMismatch(workInProgress);
		      }
		      nextInstance = workInProgress.memoizedState;
		      if (
		        null !== nextInstance &&
		        ((nextInstance = nextInstance.dehydrated), null !== nextInstance)
		      )
		        return (
		          isSuspenseInstanceFallback(nextInstance)
		            ? (workInProgress.lanes = 32)
		            : (workInProgress.lanes = 536870912),
		          null
		        );
		      popSuspenseHandler(workInProgress);
		    }
		    nextInstance = nextProps.children;
		    nextProps = nextProps.fallback;
		    if (showFallback)
		      return (
		        reuseSuspenseHandlerOnStack(),
		        (showFallback = workInProgress.mode),
		        (nextInstance = mountWorkInProgressOffscreenFiber(
		          { mode: "hidden", children: nextInstance },
		          showFallback
		        )),
		        (nextProps = createFiberFromFragment(
		          nextProps,
		          showFallback,
		          renderLanes,
		          null
		        )),
		        (nextInstance.return = workInProgress),
		        (nextProps.return = workInProgress),
		        (nextInstance.sibling = nextProps),
		        (workInProgress.child = nextInstance),
		        (showFallback = workInProgress.child),
		        (showFallback.memoizedState = mountSuspenseOffscreenState(renderLanes)),
		        (showFallback.childLanes = getRemainingWorkInPrimaryTree(
		          current,
		          JSCompiler_temp,
		          renderLanes
		        )),
		        (workInProgress.memoizedState = SUSPENDED_MARKER),
		        nextProps
		      );
		    pushPrimaryTreeSuspenseHandler(workInProgress);
		    return mountSuspensePrimaryChildren(workInProgress, nextInstance);
		  }
		  JSCompiler_temp$jscomp$0 = current.memoizedState;
		  if (
		    null !== JSCompiler_temp$jscomp$0 &&
		    ((nextInstance = JSCompiler_temp$jscomp$0.dehydrated),
		    null !== nextInstance)
		  ) {
		    if (didSuspend)
		      workInProgress.flags & 256
		        ? (pushPrimaryTreeSuspenseHandler(workInProgress),
		          (workInProgress.flags &= -257),
		          (workInProgress = retrySuspenseComponentWithoutHydrating(
		            current,
		            workInProgress,
		            renderLanes
		          )))
		        : null !== workInProgress.memoizedState
		          ? (reuseSuspenseHandlerOnStack(),
		            (workInProgress.child = current.child),
		            (workInProgress.flags |= 128),
		            (workInProgress = null))
		          : (reuseSuspenseHandlerOnStack(),
		            (showFallback = nextProps.fallback),
		            (nextInstance = workInProgress.mode),
		            (nextProps = mountWorkInProgressOffscreenFiber(
		              { mode: "visible", children: nextProps.children },
		              nextInstance
		            )),
		            (showFallback = createFiberFromFragment(
		              showFallback,
		              nextInstance,
		              renderLanes,
		              null
		            )),
		            (showFallback.flags |= 2),
		            (nextProps.return = workInProgress),
		            (showFallback.return = workInProgress),
		            (nextProps.sibling = showFallback),
		            (workInProgress.child = nextProps),
		            reconcileChildFibers(
		              workInProgress,
		              current.child,
		              null,
		              renderLanes
		            ),
		            (nextProps = workInProgress.child),
		            (nextProps.memoizedState =
		              mountSuspenseOffscreenState(renderLanes)),
		            (nextProps.childLanes = getRemainingWorkInPrimaryTree(
		              current,
		              JSCompiler_temp,
		              renderLanes
		            )),
		            (workInProgress.memoizedState = SUSPENDED_MARKER),
		            (workInProgress = showFallback));
		    else if (
		      (pushPrimaryTreeSuspenseHandler(workInProgress),
		      isSuspenseInstanceFallback(nextInstance))
		    ) {
		      JSCompiler_temp =
		        nextInstance.nextSibling && nextInstance.nextSibling.dataset;
		      if (JSCompiler_temp) var digest = JSCompiler_temp.dgst;
		      JSCompiler_temp = digest;
		      nextProps = Error(formatProdErrorMessage(419));
		      nextProps.stack = "";
		      nextProps.digest = JSCompiler_temp;
		      queueHydrationError({ value: nextProps, source: null, stack: null });
		      workInProgress = retrySuspenseComponentWithoutHydrating(
		        current,
		        workInProgress,
		        renderLanes
		      );
		    } else if (
		      (didReceiveUpdate ||
		        propagateParentContextChanges(current, workInProgress, renderLanes, false),
		      (JSCompiler_temp = 0 !== (renderLanes & current.childLanes)),
		      didReceiveUpdate || JSCompiler_temp)
		    ) {
		      JSCompiler_temp = workInProgressRoot;
		      if (
		        null !== JSCompiler_temp &&
		        ((nextProps = renderLanes & -renderLanes),
		        (nextProps =
		          0 !== (nextProps & 42)
		            ? 1
		            : getBumpedLaneForHydrationByLane(nextProps)),
		        (nextProps =
		          0 !== (nextProps & (JSCompiler_temp.suspendedLanes | renderLanes))
		            ? 0
		            : nextProps),
		        0 !== nextProps && nextProps !== JSCompiler_temp$jscomp$0.retryLane)
		      )
		        throw (
		          ((JSCompiler_temp$jscomp$0.retryLane = nextProps),
		          enqueueConcurrentRenderForLane(current, nextProps),
		          scheduleUpdateOnFiber(JSCompiler_temp, current, nextProps),
		          SelectiveHydrationException)
		        );
		      "$?" === nextInstance.data || renderDidSuspendDelayIfPossible();
		      workInProgress = retrySuspenseComponentWithoutHydrating(
		        current,
		        workInProgress,
		        renderLanes
		      );
		    } else
		      "$?" === nextInstance.data
		        ? ((workInProgress.flags |= 192),
		          (workInProgress.child = current.child),
		          (workInProgress = null))
		        : ((current = JSCompiler_temp$jscomp$0.treeContext),
		          (nextHydratableInstance = getNextHydratable(
		            nextInstance.nextSibling
		          )),
		          (hydrationParentFiber = workInProgress),
		          (isHydrating = true),
		          (hydrationErrors = null),
		          (rootOrSingletonContext = false),
		          null !== current &&
		            ((idStack[idStackIndex++] = treeContextId),
		            (idStack[idStackIndex++] = treeContextOverflow),
		            (idStack[idStackIndex++] = treeContextProvider),
		            (treeContextId = current.id),
		            (treeContextOverflow = current.overflow),
		            (treeContextProvider = workInProgress)),
		          (workInProgress = mountSuspensePrimaryChildren(
		            workInProgress,
		            nextProps.children
		          )),
		          (workInProgress.flags |= 4096));
		    return workInProgress;
		  }
		  if (showFallback)
		    return (
		      reuseSuspenseHandlerOnStack(),
		      (showFallback = nextProps.fallback),
		      (nextInstance = workInProgress.mode),
		      (JSCompiler_temp$jscomp$0 = current.child),
		      (digest = JSCompiler_temp$jscomp$0.sibling),
		      (nextProps = createWorkInProgress(JSCompiler_temp$jscomp$0, {
		        mode: "hidden",
		        children: nextProps.children
		      })),
		      (nextProps.subtreeFlags =
		        JSCompiler_temp$jscomp$0.subtreeFlags & 65011712),
		      null !== digest
		        ? (showFallback = createWorkInProgress(digest, showFallback))
		        : ((showFallback = createFiberFromFragment(
		            showFallback,
		            nextInstance,
		            renderLanes,
		            null
		          )),
		          (showFallback.flags |= 2)),
		      (showFallback.return = workInProgress),
		      (nextProps.return = workInProgress),
		      (nextProps.sibling = showFallback),
		      (workInProgress.child = nextProps),
		      (nextProps = showFallback),
		      (showFallback = workInProgress.child),
		      (nextInstance = current.child.memoizedState),
		      null === nextInstance
		        ? (nextInstance = mountSuspenseOffscreenState(renderLanes))
		        : ((JSCompiler_temp$jscomp$0 = nextInstance.cachePool),
		          null !== JSCompiler_temp$jscomp$0
		            ? ((digest = CacheContext._currentValue),
		              (JSCompiler_temp$jscomp$0 =
		                JSCompiler_temp$jscomp$0.parent !== digest
		                  ? { parent: digest, pool: digest }
		                  : JSCompiler_temp$jscomp$0))
		            : (JSCompiler_temp$jscomp$0 = getSuspendedCache()),
		          (nextInstance = {
		            baseLanes: nextInstance.baseLanes | renderLanes,
		            cachePool: JSCompiler_temp$jscomp$0
		          })),
		      (showFallback.memoizedState = nextInstance),
		      (showFallback.childLanes = getRemainingWorkInPrimaryTree(
		        current,
		        JSCompiler_temp,
		        renderLanes
		      )),
		      (workInProgress.memoizedState = SUSPENDED_MARKER),
		      nextProps
		    );
		  pushPrimaryTreeSuspenseHandler(workInProgress);
		  renderLanes = current.child;
		  current = renderLanes.sibling;
		  renderLanes = createWorkInProgress(renderLanes, {
		    mode: "visible",
		    children: nextProps.children
		  });
		  renderLanes.return = workInProgress;
		  renderLanes.sibling = null;
		  null !== current &&
		    ((JSCompiler_temp = workInProgress.deletions),
		    null === JSCompiler_temp
		      ? ((workInProgress.deletions = [current]), (workInProgress.flags |= 16))
		      : JSCompiler_temp.push(current));
		  workInProgress.child = renderLanes;
		  workInProgress.memoizedState = null;
		  return renderLanes;
		}
		function mountSuspensePrimaryChildren(workInProgress, primaryChildren) {
		  primaryChildren = mountWorkInProgressOffscreenFiber(
		    { mode: "visible", children: primaryChildren },
		    workInProgress.mode
		  );
		  primaryChildren.return = workInProgress;
		  return (workInProgress.child = primaryChildren);
		}
		function mountWorkInProgressOffscreenFiber(offscreenProps, mode) {
		  offscreenProps = createFiberImplClass(22, offscreenProps, null, mode);
		  offscreenProps.lanes = 0;
		  offscreenProps.stateNode = {
		    _visibility: 1,
		    _pendingMarkers: null,
		    _retryCache: null,
		    _transitions: null
		  };
		  return offscreenProps;
		}
		function retrySuspenseComponentWithoutHydrating(
		  current,
		  workInProgress,
		  renderLanes
		) {
		  reconcileChildFibers(workInProgress, current.child, null, renderLanes);
		  current = mountSuspensePrimaryChildren(
		    workInProgress,
		    workInProgress.pendingProps.children
		  );
		  current.flags |= 2;
		  workInProgress.memoizedState = null;
		  return current;
		}
		function scheduleSuspenseWorkOnFiber(fiber, renderLanes, propagationRoot) {
		  fiber.lanes |= renderLanes;
		  var alternate = fiber.alternate;
		  null !== alternate && (alternate.lanes |= renderLanes);
		  scheduleContextWorkOnParentPath(fiber.return, renderLanes, propagationRoot);
		}
		function initSuspenseListRenderState(
		  workInProgress,
		  isBackwards,
		  tail,
		  lastContentRow,
		  tailMode
		) {
		  var renderState = workInProgress.memoizedState;
		  null === renderState
		    ? (workInProgress.memoizedState = {
		        isBackwards: isBackwards,
		        rendering: null,
		        renderingStartTime: 0,
		        last: lastContentRow,
		        tail: tail,
		        tailMode: tailMode
		      })
		    : ((renderState.isBackwards = isBackwards),
		      (renderState.rendering = null),
		      (renderState.renderingStartTime = 0),
		      (renderState.last = lastContentRow),
		      (renderState.tail = tail),
		      (renderState.tailMode = tailMode));
		}
		function updateSuspenseListComponent(current, workInProgress, renderLanes) {
		  var nextProps = workInProgress.pendingProps,
		    revealOrder = nextProps.revealOrder,
		    tailMode = nextProps.tail;
		  reconcileChildren(current, workInProgress, nextProps.children, renderLanes);
		  nextProps = suspenseStackCursor.current;
		  if (0 !== (nextProps & 2))
		    (nextProps = (nextProps & 1) | 2), (workInProgress.flags |= 128);
		  else {
		    if (null !== current && 0 !== (current.flags & 128))
		      a: for (current = workInProgress.child; null !== current; ) {
		        if (13 === current.tag)
		          null !== current.memoizedState &&
		            scheduleSuspenseWorkOnFiber(current, renderLanes, workInProgress);
		        else if (19 === current.tag)
		          scheduleSuspenseWorkOnFiber(current, renderLanes, workInProgress);
		        else if (null !== current.child) {
		          current.child.return = current;
		          current = current.child;
		          continue;
		        }
		        if (current === workInProgress) break a;
		        for (; null === current.sibling; ) {
		          if (null === current.return || current.return === workInProgress)
		            break a;
		          current = current.return;
		        }
		        current.sibling.return = current.return;
		        current = current.sibling;
		      }
		    nextProps &= 1;
		  }
		  push(suspenseStackCursor, nextProps);
		  switch (revealOrder) {
		    case "forwards":
		      renderLanes = workInProgress.child;
		      for (revealOrder = null; null !== renderLanes; )
		        (current = renderLanes.alternate),
		          null !== current &&
		            null === findFirstSuspended(current) &&
		            (revealOrder = renderLanes),
		          (renderLanes = renderLanes.sibling);
		      renderLanes = revealOrder;
		      null === renderLanes
		        ? ((revealOrder = workInProgress.child), (workInProgress.child = null))
		        : ((revealOrder = renderLanes.sibling), (renderLanes.sibling = null));
		      initSuspenseListRenderState(
		        workInProgress,
		        false,
		        revealOrder,
		        renderLanes,
		        tailMode
		      );
		      break;
		    case "backwards":
		      renderLanes = null;
		      revealOrder = workInProgress.child;
		      for (workInProgress.child = null; null !== revealOrder; ) {
		        current = revealOrder.alternate;
		        if (null !== current && null === findFirstSuspended(current)) {
		          workInProgress.child = revealOrder;
		          break;
		        }
		        current = revealOrder.sibling;
		        revealOrder.sibling = renderLanes;
		        renderLanes = revealOrder;
		        revealOrder = current;
		      }
		      initSuspenseListRenderState(
		        workInProgress,
		        true,
		        renderLanes,
		        null,
		        tailMode
		      );
		      break;
		    case "together":
		      initSuspenseListRenderState(workInProgress, false, null, null, void 0);
		      break;
		    default:
		      workInProgress.memoizedState = null;
		  }
		  return workInProgress.child;
		}
		function bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes) {
		  null !== current && (workInProgress.dependencies = current.dependencies);
		  workInProgressRootSkippedLanes |= workInProgress.lanes;
		  if (0 === (renderLanes & workInProgress.childLanes))
		    if (null !== current) {
		      if (
		        (propagateParentContextChanges(
		          current,
		          workInProgress,
		          renderLanes,
		          false
		        ),
		        0 === (renderLanes & workInProgress.childLanes))
		      )
		        return null;
		    } else return null;
		  if (null !== current && workInProgress.child !== current.child)
		    throw Error(formatProdErrorMessage(153));
		  if (null !== workInProgress.child) {
		    current = workInProgress.child;
		    renderLanes = createWorkInProgress(current, current.pendingProps);
		    workInProgress.child = renderLanes;
		    for (renderLanes.return = workInProgress; null !== current.sibling; )
		      (current = current.sibling),
		        (renderLanes = renderLanes.sibling =
		          createWorkInProgress(current, current.pendingProps)),
		        (renderLanes.return = workInProgress);
		    renderLanes.sibling = null;
		  }
		  return workInProgress.child;
		}
		function checkScheduledUpdateOrContext(current, renderLanes) {
		  if (0 !== (current.lanes & renderLanes)) return true;
		  current = current.dependencies;
		  return null !== current && checkIfContextChanged(current) ? true : false;
		}
		function attemptEarlyBailoutIfNoScheduledUpdate(
		  current,
		  workInProgress,
		  renderLanes
		) {
		  switch (workInProgress.tag) {
		    case 3:
		      pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);
		      pushProvider(workInProgress, CacheContext, current.memoizedState.cache);
		      resetHydrationState();
		      break;
		    case 27:
		    case 5:
		      pushHostContext(workInProgress);
		      break;
		    case 4:
		      pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);
		      break;
		    case 10:
		      pushProvider(
		        workInProgress,
		        workInProgress.type,
		        workInProgress.memoizedProps.value
		      );
		      break;
		    case 13:
		      var state = workInProgress.memoizedState;
		      if (null !== state) {
		        if (null !== state.dehydrated)
		          return (
		            pushPrimaryTreeSuspenseHandler(workInProgress),
		            (workInProgress.flags |= 128),
		            null
		          );
		        if (0 !== (renderLanes & workInProgress.child.childLanes))
		          return updateSuspenseComponent(current, workInProgress, renderLanes);
		        pushPrimaryTreeSuspenseHandler(workInProgress);
		        current = bailoutOnAlreadyFinishedWork(
		          current,
		          workInProgress,
		          renderLanes
		        );
		        return null !== current ? current.sibling : null;
		      }
		      pushPrimaryTreeSuspenseHandler(workInProgress);
		      break;
		    case 19:
		      var didSuspendBefore = 0 !== (current.flags & 128);
		      state = 0 !== (renderLanes & workInProgress.childLanes);
		      state ||
		        (propagateParentContextChanges(
		          current,
		          workInProgress,
		          renderLanes,
		          false
		        ),
		        (state = 0 !== (renderLanes & workInProgress.childLanes)));
		      if (didSuspendBefore) {
		        if (state)
		          return updateSuspenseListComponent(
		            current,
		            workInProgress,
		            renderLanes
		          );
		        workInProgress.flags |= 128;
		      }
		      didSuspendBefore = workInProgress.memoizedState;
		      null !== didSuspendBefore &&
		        ((didSuspendBefore.rendering = null),
		        (didSuspendBefore.tail = null),
		        (didSuspendBefore.lastEffect = null));
		      push(suspenseStackCursor, suspenseStackCursor.current);
		      if (state) break;
		      else return null;
		    case 22:
		    case 23:
		      return (
		        (workInProgress.lanes = 0),
		        updateOffscreenComponent(current, workInProgress, renderLanes)
		      );
		    case 24:
		      pushProvider(workInProgress, CacheContext, current.memoizedState.cache);
		  }
		  return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
		}
		function beginWork(current, workInProgress, renderLanes) {
		  if (null !== current)
		    if (current.memoizedProps !== workInProgress.pendingProps)
		      didReceiveUpdate = true;
		    else {
		      if (
		        !checkScheduledUpdateOrContext(current, renderLanes) &&
		        0 === (workInProgress.flags & 128)
		      )
		        return (
		          (didReceiveUpdate = false),
		          attemptEarlyBailoutIfNoScheduledUpdate(
		            current,
		            workInProgress,
		            renderLanes
		          )
		        );
		      didReceiveUpdate = 0 !== (current.flags & 131072) ? true : false;
		    }
		  else
		    (didReceiveUpdate = false),
		      isHydrating &&
		        0 !== (workInProgress.flags & 1048576) &&
		        pushTreeId(workInProgress, treeForkCount, workInProgress.index);
		  workInProgress.lanes = 0;
		  switch (workInProgress.tag) {
		    case 16:
		      a: {
		        current = workInProgress.pendingProps;
		        var lazyComponent = workInProgress.elementType,
		          init = lazyComponent._init;
		        lazyComponent = init(lazyComponent._payload);
		        workInProgress.type = lazyComponent;
		        if ("function" === typeof lazyComponent)
		          shouldConstruct(lazyComponent)
		            ? ((current = resolveClassComponentProps(lazyComponent, current)),
		              (workInProgress.tag = 1),
		              (workInProgress = updateClassComponent(
		                null,
		                workInProgress,
		                lazyComponent,
		                current,
		                renderLanes
		              )))
		            : ((workInProgress.tag = 0),
		              (workInProgress = updateFunctionComponent(
		                null,
		                workInProgress,
		                lazyComponent,
		                current,
		                renderLanes
		              )));
		        else {
		          if (void 0 !== lazyComponent && null !== lazyComponent)
		            if (
		              ((init = lazyComponent.$$typeof), init === REACT_FORWARD_REF_TYPE)
		            ) {
		              workInProgress.tag = 11;
		              workInProgress = updateForwardRef(
		                null,
		                workInProgress,
		                lazyComponent,
		                current,
		                renderLanes
		              );
		              break a;
		            } else if (init === REACT_MEMO_TYPE) {
		              workInProgress.tag = 14;
		              workInProgress = updateMemoComponent(
		                null,
		                workInProgress,
		                lazyComponent,
		                current,
		                renderLanes
		              );
		              break a;
		            }
		          workInProgress =
		            getComponentNameFromType(lazyComponent) || lazyComponent;
		          throw Error(formatProdErrorMessage(306, workInProgress, ""));
		        }
		      }
		      return workInProgress;
		    case 0:
		      return updateFunctionComponent(
		        current,
		        workInProgress,
		        workInProgress.type,
		        workInProgress.pendingProps,
		        renderLanes
		      );
		    case 1:
		      return (
		        (lazyComponent = workInProgress.type),
		        (init = resolveClassComponentProps(
		          lazyComponent,
		          workInProgress.pendingProps
		        )),
		        updateClassComponent(
		          current,
		          workInProgress,
		          lazyComponent,
		          init,
		          renderLanes
		        )
		      );
		    case 3:
		      a: {
		        pushHostContainer(
		          workInProgress,
		          workInProgress.stateNode.containerInfo
		        );
		        if (null === current) throw Error(formatProdErrorMessage(387));
		        lazyComponent = workInProgress.pendingProps;
		        var prevState = workInProgress.memoizedState;
		        init = prevState.element;
		        cloneUpdateQueue(current, workInProgress);
		        processUpdateQueue(workInProgress, lazyComponent, null, renderLanes);
		        var nextState = workInProgress.memoizedState;
		        lazyComponent = nextState.cache;
		        pushProvider(workInProgress, CacheContext, lazyComponent);
		        lazyComponent !== prevState.cache &&
		          propagateContextChanges(
		            workInProgress,
		            [CacheContext],
		            renderLanes,
		            true
		          );
		        suspendIfUpdateReadFromEntangledAsyncAction();
		        lazyComponent = nextState.element;
		        if (prevState.isDehydrated)
		          if (
		            ((prevState = {
		              element: lazyComponent,
		              isDehydrated: false,
		              cache: nextState.cache
		            }),
		            (workInProgress.updateQueue.baseState = prevState),
		            (workInProgress.memoizedState = prevState),
		            workInProgress.flags & 256)
		          ) {
		            workInProgress = mountHostRootWithoutHydrating(
		              current,
		              workInProgress,
		              lazyComponent,
		              renderLanes
		            );
		            break a;
		          } else if (lazyComponent !== init) {
		            init = createCapturedValueAtFiber(
		              Error(formatProdErrorMessage(424)),
		              workInProgress
		            );
		            queueHydrationError(init);
		            workInProgress = mountHostRootWithoutHydrating(
		              current,
		              workInProgress,
		              lazyComponent,
		              renderLanes
		            );
		            break a;
		          } else {
		            current = workInProgress.stateNode.containerInfo;
		            switch (current.nodeType) {
		              case 9:
		                current = current.body;
		                break;
		              default:
		                current =
		                  "HTML" === current.nodeName
		                    ? current.ownerDocument.body
		                    : current;
		            }
		            nextHydratableInstance = getNextHydratable(current.firstChild);
		            hydrationParentFiber = workInProgress;
		            isHydrating = true;
		            hydrationErrors = null;
		            rootOrSingletonContext = true;
		            renderLanes = mountChildFibers(
		              workInProgress,
		              null,
		              lazyComponent,
		              renderLanes
		            );
		            for (workInProgress.child = renderLanes; renderLanes; )
		              (renderLanes.flags = (renderLanes.flags & -3) | 4096),
		                (renderLanes = renderLanes.sibling);
		          }
		        else {
		          resetHydrationState();
		          if (lazyComponent === init) {
		            workInProgress = bailoutOnAlreadyFinishedWork(
		              current,
		              workInProgress,
		              renderLanes
		            );
		            break a;
		          }
		          reconcileChildren(
		            current,
		            workInProgress,
		            lazyComponent,
		            renderLanes
		          );
		        }
		        workInProgress = workInProgress.child;
		      }
		      return workInProgress;
		    case 26:
		      return (
		        markRef(current, workInProgress),
		        null === current
		          ? (renderLanes = getResource(
		              workInProgress.type,
		              null,
		              workInProgress.pendingProps,
		              null
		            ))
		            ? (workInProgress.memoizedState = renderLanes)
		            : isHydrating ||
		              ((renderLanes = workInProgress.type),
		              (current = workInProgress.pendingProps),
		              (lazyComponent = getOwnerDocumentFromRootContainer(
		                rootInstanceStackCursor.current
		              ).createElement(renderLanes)),
		              (lazyComponent[internalInstanceKey] = workInProgress),
		              (lazyComponent[internalPropsKey] = current),
		              setInitialProperties(lazyComponent, renderLanes, current),
		              markNodeAsHoistable(lazyComponent),
		              (workInProgress.stateNode = lazyComponent))
		          : (workInProgress.memoizedState = getResource(
		              workInProgress.type,
		              current.memoizedProps,
		              workInProgress.pendingProps,
		              current.memoizedState
		            )),
		        null
		      );
		    case 27:
		      return (
		        pushHostContext(workInProgress),
		        null === current &&
		          isHydrating &&
		          ((lazyComponent = workInProgress.stateNode =
		            resolveSingletonInstance(
		              workInProgress.type,
		              workInProgress.pendingProps,
		              rootInstanceStackCursor.current
		            )),
		          (hydrationParentFiber = workInProgress),
		          (rootOrSingletonContext = true),
		          (init = nextHydratableInstance),
		          isSingletonScope(workInProgress.type)
		            ? ((previousHydratableOnEnteringScopedSingleton = init),
		              (nextHydratableInstance = getNextHydratable(
		                lazyComponent.firstChild
		              )))
		            : (nextHydratableInstance = init)),
		        reconcileChildren(
		          current,
		          workInProgress,
		          workInProgress.pendingProps.children,
		          renderLanes
		        ),
		        markRef(current, workInProgress),
		        null === current && (workInProgress.flags |= 4194304),
		        workInProgress.child
		      );
		    case 5:
		      if (null === current && isHydrating) {
		        if ((init = lazyComponent = nextHydratableInstance))
		          (lazyComponent = canHydrateInstance(
		            lazyComponent,
		            workInProgress.type,
		            workInProgress.pendingProps,
		            rootOrSingletonContext
		          )),
		            null !== lazyComponent
		              ? ((workInProgress.stateNode = lazyComponent),
		                (hydrationParentFiber = workInProgress),
		                (nextHydratableInstance = getNextHydratable(
		                  lazyComponent.firstChild
		                )),
		                (rootOrSingletonContext = false),
		                (init = true))
		              : (init = false);
		        init || throwOnHydrationMismatch(workInProgress);
		      }
		      pushHostContext(workInProgress);
		      init = workInProgress.type;
		      prevState = workInProgress.pendingProps;
		      nextState = null !== current ? current.memoizedProps : null;
		      lazyComponent = prevState.children;
		      shouldSetTextContent(init, prevState)
		        ? (lazyComponent = null)
		        : null !== nextState &&
		          shouldSetTextContent(init, nextState) &&
		          (workInProgress.flags |= 32);
		      null !== workInProgress.memoizedState &&
		        ((init = renderWithHooks(
		          current,
		          workInProgress,
		          TransitionAwareHostComponent,
		          null,
		          null,
		          renderLanes
		        )),
		        (HostTransitionContext._currentValue = init));
		      markRef(current, workInProgress);
		      reconcileChildren(current, workInProgress, lazyComponent, renderLanes);
		      return workInProgress.child;
		    case 6:
		      if (null === current && isHydrating) {
		        if ((current = renderLanes = nextHydratableInstance))
		          (renderLanes = canHydrateTextInstance(
		            renderLanes,
		            workInProgress.pendingProps,
		            rootOrSingletonContext
		          )),
		            null !== renderLanes
		              ? ((workInProgress.stateNode = renderLanes),
		                (hydrationParentFiber = workInProgress),
		                (nextHydratableInstance = null),
		                (current = true))
		              : (current = false);
		        current || throwOnHydrationMismatch(workInProgress);
		      }
		      return null;
		    case 13:
		      return updateSuspenseComponent(current, workInProgress, renderLanes);
		    case 4:
		      return (
		        pushHostContainer(
		          workInProgress,
		          workInProgress.stateNode.containerInfo
		        ),
		        (lazyComponent = workInProgress.pendingProps),
		        null === current
		          ? (workInProgress.child = reconcileChildFibers(
		              workInProgress,
		              null,
		              lazyComponent,
		              renderLanes
		            ))
		          : reconcileChildren(
		              current,
		              workInProgress,
		              lazyComponent,
		              renderLanes
		            ),
		        workInProgress.child
		      );
		    case 11:
		      return updateForwardRef(
		        current,
		        workInProgress,
		        workInProgress.type,
		        workInProgress.pendingProps,
		        renderLanes
		      );
		    case 7:
		      return (
		        reconcileChildren(
		          current,
		          workInProgress,
		          workInProgress.pendingProps,
		          renderLanes
		        ),
		        workInProgress.child
		      );
		    case 8:
		      return (
		        reconcileChildren(
		          current,
		          workInProgress,
		          workInProgress.pendingProps.children,
		          renderLanes
		        ),
		        workInProgress.child
		      );
		    case 12:
		      return (
		        reconcileChildren(
		          current,
		          workInProgress,
		          workInProgress.pendingProps.children,
		          renderLanes
		        ),
		        workInProgress.child
		      );
		    case 10:
		      return (
		        (lazyComponent = workInProgress.pendingProps),
		        pushProvider(workInProgress, workInProgress.type, lazyComponent.value),
		        reconcileChildren(
		          current,
		          workInProgress,
		          lazyComponent.children,
		          renderLanes
		        ),
		        workInProgress.child
		      );
		    case 9:
		      return (
		        (init = workInProgress.type._context),
		        (lazyComponent = workInProgress.pendingProps.children),
		        prepareToReadContext(workInProgress),
		        (init = readContext(init)),
		        (lazyComponent = lazyComponent(init)),
		        (workInProgress.flags |= 1),
		        reconcileChildren(current, workInProgress, lazyComponent, renderLanes),
		        workInProgress.child
		      );
		    case 14:
		      return updateMemoComponent(
		        current,
		        workInProgress,
		        workInProgress.type,
		        workInProgress.pendingProps,
		        renderLanes
		      );
		    case 15:
		      return updateSimpleMemoComponent(
		        current,
		        workInProgress,
		        workInProgress.type,
		        workInProgress.pendingProps,
		        renderLanes
		      );
		    case 19:
		      return updateSuspenseListComponent(current, workInProgress, renderLanes);
		    case 31:
		      return (
		        (lazyComponent = workInProgress.pendingProps),
		        (renderLanes = workInProgress.mode),
		        (lazyComponent = {
		          mode: lazyComponent.mode,
		          children: lazyComponent.children
		        }),
		        null === current
		          ? ((renderLanes = mountWorkInProgressOffscreenFiber(
		              lazyComponent,
		              renderLanes
		            )),
		            (renderLanes.ref = workInProgress.ref),
		            (workInProgress.child = renderLanes),
		            (renderLanes.return = workInProgress),
		            (workInProgress = renderLanes))
		          : ((renderLanes = createWorkInProgress(current.child, lazyComponent)),
		            (renderLanes.ref = workInProgress.ref),
		            (workInProgress.child = renderLanes),
		            (renderLanes.return = workInProgress),
		            (workInProgress = renderLanes)),
		        workInProgress
		      );
		    case 22:
		      return updateOffscreenComponent(current, workInProgress, renderLanes);
		    case 24:
		      return (
		        prepareToReadContext(workInProgress),
		        (lazyComponent = readContext(CacheContext)),
		        null === current
		          ? ((init = peekCacheFromPool()),
		            null === init &&
		              ((init = workInProgressRoot),
		              (prevState = createCache()),
		              (init.pooledCache = prevState),
		              prevState.refCount++,
		              null !== prevState && (init.pooledCacheLanes |= renderLanes),
		              (init = prevState)),
		            (workInProgress.memoizedState = {
		              parent: lazyComponent,
		              cache: init
		            }),
		            initializeUpdateQueue(workInProgress),
		            pushProvider(workInProgress, CacheContext, init))
		          : (0 !== (current.lanes & renderLanes) &&
		              (cloneUpdateQueue(current, workInProgress),
		              processUpdateQueue(workInProgress, null, null, renderLanes),
		              suspendIfUpdateReadFromEntangledAsyncAction()),
		            (init = current.memoizedState),
		            (prevState = workInProgress.memoizedState),
		            init.parent !== lazyComponent
		              ? ((init = { parent: lazyComponent, cache: lazyComponent }),
		                (workInProgress.memoizedState = init),
		                0 === workInProgress.lanes &&
		                  (workInProgress.memoizedState =
		                    workInProgress.updateQueue.baseState =
		                      init),
		                pushProvider(workInProgress, CacheContext, lazyComponent))
		              : ((lazyComponent = prevState.cache),
		                pushProvider(workInProgress, CacheContext, lazyComponent),
		                lazyComponent !== init.cache &&
		                  propagateContextChanges(
		                    workInProgress,
		                    [CacheContext],
		                    renderLanes,
		                    true
		                  ))),
		        reconcileChildren(
		          current,
		          workInProgress,
		          workInProgress.pendingProps.children,
		          renderLanes
		        ),
		        workInProgress.child
		      );
		    case 29:
		      throw workInProgress.pendingProps;
		  }
		  throw Error(formatProdErrorMessage(156, workInProgress.tag));
		}
		function markUpdate(workInProgress) {
		  workInProgress.flags |= 4;
		}
		function preloadResourceAndSuspendIfNeeded(workInProgress, resource) {
		  if ("stylesheet" !== resource.type || 0 !== (resource.state.loading & 4))
		    workInProgress.flags &= -16777217;
		  else if (((workInProgress.flags |= 16777216), !preloadResource(resource))) {
		    resource = suspenseHandlerStackCursor.current;
		    if (
		      null !== resource &&
		      ((workInProgressRootRenderLanes & 4194048) ===
		      workInProgressRootRenderLanes
		        ? null !== shellBoundary
		        : ((workInProgressRootRenderLanes & 62914560) !==
		            workInProgressRootRenderLanes &&
		            0 === (workInProgressRootRenderLanes & 536870912)) ||
		          resource !== shellBoundary)
		    )
		      throw (
		        ((suspendedThenable = noopSuspenseyCommitThenable),
		        SuspenseyCommitException)
		      );
		    workInProgress.flags |= 8192;
		  }
		}
		function scheduleRetryEffect(workInProgress, retryQueue) {
		  null !== retryQueue && (workInProgress.flags |= 4);
		  workInProgress.flags & 16384 &&
		    ((retryQueue =
		      22 !== workInProgress.tag ? claimNextRetryLane() : 536870912),
		    (workInProgress.lanes |= retryQueue),
		    (workInProgressSuspendedRetryLanes |= retryQueue));
		}
		function cutOffTailIfNeeded(renderState, hasRenderedATailFallback) {
		  if (!isHydrating)
		    switch (renderState.tailMode) {
		      case "hidden":
		        hasRenderedATailFallback = renderState.tail;
		        for (var lastTailNode = null; null !== hasRenderedATailFallback; )
		          null !== hasRenderedATailFallback.alternate &&
		            (lastTailNode = hasRenderedATailFallback),
		            (hasRenderedATailFallback = hasRenderedATailFallback.sibling);
		        null === lastTailNode
		          ? (renderState.tail = null)
		          : (lastTailNode.sibling = null);
		        break;
		      case "collapsed":
		        lastTailNode = renderState.tail;
		        for (var lastTailNode$113 = null; null !== lastTailNode; )
		          null !== lastTailNode.alternate && (lastTailNode$113 = lastTailNode),
		            (lastTailNode = lastTailNode.sibling);
		        null === lastTailNode$113
		          ? hasRenderedATailFallback || null === renderState.tail
		            ? (renderState.tail = null)
		            : (renderState.tail.sibling = null)
		          : (lastTailNode$113.sibling = null);
		    }
		}
		function bubbleProperties(completedWork) {
		  var didBailout =
		      null !== completedWork.alternate &&
		      completedWork.alternate.child === completedWork.child,
		    newChildLanes = 0,
		    subtreeFlags = 0;
		  if (didBailout)
		    for (var child$114 = completedWork.child; null !== child$114; )
		      (newChildLanes |= child$114.lanes | child$114.childLanes),
		        (subtreeFlags |= child$114.subtreeFlags & 65011712),
		        (subtreeFlags |= child$114.flags & 65011712),
		        (child$114.return = completedWork),
		        (child$114 = child$114.sibling);
		  else
		    for (child$114 = completedWork.child; null !== child$114; )
		      (newChildLanes |= child$114.lanes | child$114.childLanes),
		        (subtreeFlags |= child$114.subtreeFlags),
		        (subtreeFlags |= child$114.flags),
		        (child$114.return = completedWork),
		        (child$114 = child$114.sibling);
		  completedWork.subtreeFlags |= subtreeFlags;
		  completedWork.childLanes = newChildLanes;
		  return didBailout;
		}
		function completeWork(current, workInProgress, renderLanes) {
		  var newProps = workInProgress.pendingProps;
		  popTreeContext(workInProgress);
		  switch (workInProgress.tag) {
		    case 31:
		    case 16:
		    case 15:
		    case 0:
		    case 11:
		    case 7:
		    case 8:
		    case 12:
		    case 9:
		    case 14:
		      return bubbleProperties(workInProgress), null;
		    case 1:
		      return bubbleProperties(workInProgress), null;
		    case 3:
		      renderLanes = workInProgress.stateNode;
		      newProps = null;
		      null !== current && (newProps = current.memoizedState.cache);
		      workInProgress.memoizedState.cache !== newProps &&
		        (workInProgress.flags |= 2048);
		      popProvider(CacheContext);
		      popHostContainer();
		      renderLanes.pendingContext &&
		        ((renderLanes.context = renderLanes.pendingContext),
		        (renderLanes.pendingContext = null));
		      if (null === current || null === current.child)
		        popHydrationState(workInProgress)
		          ? markUpdate(workInProgress)
		          : null === current ||
		            (current.memoizedState.isDehydrated &&
		              0 === (workInProgress.flags & 256)) ||
		            ((workInProgress.flags |= 1024),
		            upgradeHydrationErrorsToRecoverable());
		      bubbleProperties(workInProgress);
		      return null;
		    case 26:
		      return (
		        (renderLanes = workInProgress.memoizedState),
		        null === current
		          ? (markUpdate(workInProgress),
		            null !== renderLanes
		              ? (bubbleProperties(workInProgress),
		                preloadResourceAndSuspendIfNeeded(workInProgress, renderLanes))
		              : (bubbleProperties(workInProgress),
		                (workInProgress.flags &= -16777217)))
		          : renderLanes
		            ? renderLanes !== current.memoizedState
		              ? (markUpdate(workInProgress),
		                bubbleProperties(workInProgress),
		                preloadResourceAndSuspendIfNeeded(workInProgress, renderLanes))
		              : (bubbleProperties(workInProgress),
		                (workInProgress.flags &= -16777217))
		            : (current.memoizedProps !== newProps && markUpdate(workInProgress),
		              bubbleProperties(workInProgress),
		              (workInProgress.flags &= -16777217)),
		        null
		      );
		    case 27:
		      popHostContext(workInProgress);
		      renderLanes = rootInstanceStackCursor.current;
		      var type = workInProgress.type;
		      if (null !== current && null != workInProgress.stateNode)
		        current.memoizedProps !== newProps && markUpdate(workInProgress);
		      else {
		        if (!newProps) {
		          if (null === workInProgress.stateNode)
		            throw Error(formatProdErrorMessage(166));
		          bubbleProperties(workInProgress);
		          return null;
		        }
		        current = contextStackCursor.current;
		        popHydrationState(workInProgress)
		          ? prepareToHydrateHostInstance(workInProgress)
		          : ((current = resolveSingletonInstance(type, newProps, renderLanes)),
		            (workInProgress.stateNode = current),
		            markUpdate(workInProgress));
		      }
		      bubbleProperties(workInProgress);
		      return null;
		    case 5:
		      popHostContext(workInProgress);
		      renderLanes = workInProgress.type;
		      if (null !== current && null != workInProgress.stateNode)
		        current.memoizedProps !== newProps && markUpdate(workInProgress);
		      else {
		        if (!newProps) {
		          if (null === workInProgress.stateNode)
		            throw Error(formatProdErrorMessage(166));
		          bubbleProperties(workInProgress);
		          return null;
		        }
		        current = contextStackCursor.current;
		        if (popHydrationState(workInProgress))
		          prepareToHydrateHostInstance(workInProgress);
		        else {
		          type = getOwnerDocumentFromRootContainer(
		            rootInstanceStackCursor.current
		          );
		          switch (current) {
		            case 1:
		              current = type.createElementNS(
		                "http://www.w3.org/2000/svg",
		                renderLanes
		              );
		              break;
		            case 2:
		              current = type.createElementNS(
		                "http://www.w3.org/1998/Math/MathML",
		                renderLanes
		              );
		              break;
		            default:
		              switch (renderLanes) {
		                case "svg":
		                  current = type.createElementNS(
		                    "http://www.w3.org/2000/svg",
		                    renderLanes
		                  );
		                  break;
		                case "math":
		                  current = type.createElementNS(
		                    "http://www.w3.org/1998/Math/MathML",
		                    renderLanes
		                  );
		                  break;
		                case "script":
		                  current = type.createElement("div");
		                  current.innerHTML = "<script>\x3c/script>";
		                  current = current.removeChild(current.firstChild);
		                  break;
		                case "select":
		                  current =
		                    "string" === typeof newProps.is
		                      ? type.createElement("select", { is: newProps.is })
		                      : type.createElement("select");
		                  newProps.multiple
		                    ? (current.multiple = true)
		                    : newProps.size && (current.size = newProps.size);
		                  break;
		                default:
		                  current =
		                    "string" === typeof newProps.is
		                      ? type.createElement(renderLanes, { is: newProps.is })
		                      : type.createElement(renderLanes);
		              }
		          }
		          current[internalInstanceKey] = workInProgress;
		          current[internalPropsKey] = newProps;
		          a: for (type = workInProgress.child; null !== type; ) {
		            if (5 === type.tag || 6 === type.tag)
		              current.appendChild(type.stateNode);
		            else if (4 !== type.tag && 27 !== type.tag && null !== type.child) {
		              type.child.return = type;
		              type = type.child;
		              continue;
		            }
		            if (type === workInProgress) break a;
		            for (; null === type.sibling; ) {
		              if (null === type.return || type.return === workInProgress)
		                break a;
		              type = type.return;
		            }
		            type.sibling.return = type.return;
		            type = type.sibling;
		          }
		          workInProgress.stateNode = current;
		          a: switch (
		            (setInitialProperties(current, renderLanes, newProps), renderLanes)
		          ) {
		            case "button":
		            case "input":
		            case "select":
		            case "textarea":
		              current = !!newProps.autoFocus;
		              break a;
		            case "img":
		              current = true;
		              break a;
		            default:
		              current = false;
		          }
		          current && markUpdate(workInProgress);
		        }
		      }
		      bubbleProperties(workInProgress);
		      workInProgress.flags &= -16777217;
		      return null;
		    case 6:
		      if (current && null != workInProgress.stateNode)
		        current.memoizedProps !== newProps && markUpdate(workInProgress);
		      else {
		        if ("string" !== typeof newProps && null === workInProgress.stateNode)
		          throw Error(formatProdErrorMessage(166));
		        current = rootInstanceStackCursor.current;
		        if (popHydrationState(workInProgress)) {
		          current = workInProgress.stateNode;
		          renderLanes = workInProgress.memoizedProps;
		          newProps = null;
		          type = hydrationParentFiber;
		          if (null !== type)
		            switch (type.tag) {
		              case 27:
		              case 5:
		                newProps = type.memoizedProps;
		            }
		          current[internalInstanceKey] = workInProgress;
		          current =
		            current.nodeValue === renderLanes ||
		            (null !== newProps && true === newProps.suppressHydrationWarning) ||
		            checkForUnmatchedText(current.nodeValue, renderLanes)
		              ? true
		              : false;
		          current || throwOnHydrationMismatch(workInProgress);
		        } else
		          (current =
		            getOwnerDocumentFromRootContainer(current).createTextNode(
		              newProps
		            )),
		            (current[internalInstanceKey] = workInProgress),
		            (workInProgress.stateNode = current);
		      }
		      bubbleProperties(workInProgress);
		      return null;
		    case 13:
		      newProps = workInProgress.memoizedState;
		      if (
		        null === current ||
		        (null !== current.memoizedState &&
		          null !== current.memoizedState.dehydrated)
		      ) {
		        type = popHydrationState(workInProgress);
		        if (null !== newProps && null !== newProps.dehydrated) {
		          if (null === current) {
		            if (!type) throw Error(formatProdErrorMessage(318));
		            type = workInProgress.memoizedState;
		            type = null !== type ? type.dehydrated : null;
		            if (!type) throw Error(formatProdErrorMessage(317));
		            type[internalInstanceKey] = workInProgress;
		          } else
		            resetHydrationState(),
		              0 === (workInProgress.flags & 128) &&
		                (workInProgress.memoizedState = null),
		              (workInProgress.flags |= 4);
		          bubbleProperties(workInProgress);
		          type = false;
		        } else
		          (type = upgradeHydrationErrorsToRecoverable()),
		            null !== current &&
		              null !== current.memoizedState &&
		              (current.memoizedState.hydrationErrors = type),
		            (type = true);
		        if (!type) {
		          if (workInProgress.flags & 256)
		            return popSuspenseHandler(workInProgress), workInProgress;
		          popSuspenseHandler(workInProgress);
		          return null;
		        }
		      }
		      popSuspenseHandler(workInProgress);
		      if (0 !== (workInProgress.flags & 128))
		        return (workInProgress.lanes = renderLanes), workInProgress;
		      renderLanes = null !== newProps;
		      current = null !== current && null !== current.memoizedState;
		      if (renderLanes) {
		        newProps = workInProgress.child;
		        type = null;
		        null !== newProps.alternate &&
		          null !== newProps.alternate.memoizedState &&
		          null !== newProps.alternate.memoizedState.cachePool &&
		          (type = newProps.alternate.memoizedState.cachePool.pool);
		        var cache$127 = null;
		        null !== newProps.memoizedState &&
		          null !== newProps.memoizedState.cachePool &&
		          (cache$127 = newProps.memoizedState.cachePool.pool);
		        cache$127 !== type && (newProps.flags |= 2048);
		      }
		      renderLanes !== current &&
		        renderLanes &&
		        (workInProgress.child.flags |= 8192);
		      scheduleRetryEffect(workInProgress, workInProgress.updateQueue);
		      bubbleProperties(workInProgress);
		      return null;
		    case 4:
		      return (
		        popHostContainer(),
		        null === current &&
		          listenToAllSupportedEvents(workInProgress.stateNode.containerInfo),
		        bubbleProperties(workInProgress),
		        null
		      );
		    case 10:
		      return (
		        popProvider(workInProgress.type), bubbleProperties(workInProgress), null
		      );
		    case 19:
		      pop(suspenseStackCursor);
		      type = workInProgress.memoizedState;
		      if (null === type) return bubbleProperties(workInProgress), null;
		      newProps = 0 !== (workInProgress.flags & 128);
		      cache$127 = type.rendering;
		      if (null === cache$127)
		        if (newProps) cutOffTailIfNeeded(type, false);
		        else {
		          if (
		            0 !== workInProgressRootExitStatus ||
		            (null !== current && 0 !== (current.flags & 128))
		          )
		            for (current = workInProgress.child; null !== current; ) {
		              cache$127 = findFirstSuspended(current);
		              if (null !== cache$127) {
		                workInProgress.flags |= 128;
		                cutOffTailIfNeeded(type, false);
		                current = cache$127.updateQueue;
		                workInProgress.updateQueue = current;
		                scheduleRetryEffect(workInProgress, current);
		                workInProgress.subtreeFlags = 0;
		                current = renderLanes;
		                for (renderLanes = workInProgress.child; null !== renderLanes; )
		                  resetWorkInProgress(renderLanes, current),
		                    (renderLanes = renderLanes.sibling);
		                push(
		                  suspenseStackCursor,
		                  (suspenseStackCursor.current & 1) | 2
		                );
		                return workInProgress.child;
		              }
		              current = current.sibling;
		            }
		          null !== type.tail &&
		            now() > workInProgressRootRenderTargetTime &&
		            ((workInProgress.flags |= 128),
		            (newProps = true),
		            cutOffTailIfNeeded(type, false),
		            (workInProgress.lanes = 4194304));
		        }
		      else {
		        if (!newProps)
		          if (((current = findFirstSuspended(cache$127)), null !== current)) {
		            if (
		              ((workInProgress.flags |= 128),
		              (newProps = true),
		              (current = current.updateQueue),
		              (workInProgress.updateQueue = current),
		              scheduleRetryEffect(workInProgress, current),
		              cutOffTailIfNeeded(type, true),
		              null === type.tail &&
		                "hidden" === type.tailMode &&
		                !cache$127.alternate &&
		                !isHydrating)
		            )
		              return bubbleProperties(workInProgress), null;
		          } else
		            2 * now() - type.renderingStartTime >
		              workInProgressRootRenderTargetTime &&
		              536870912 !== renderLanes &&
		              ((workInProgress.flags |= 128),
		              (newProps = true),
		              cutOffTailIfNeeded(type, false),
		              (workInProgress.lanes = 4194304));
		        type.isBackwards
		          ? ((cache$127.sibling = workInProgress.child),
		            (workInProgress.child = cache$127))
		          : ((current = type.last),
		            null !== current
		              ? (current.sibling = cache$127)
		              : (workInProgress.child = cache$127),
		            (type.last = cache$127));
		      }
		      if (null !== type.tail)
		        return (
		          (workInProgress = type.tail),
		          (type.rendering = workInProgress),
		          (type.tail = workInProgress.sibling),
		          (type.renderingStartTime = now()),
		          (workInProgress.sibling = null),
		          (current = suspenseStackCursor.current),
		          push(suspenseStackCursor, newProps ? (current & 1) | 2 : current & 1),
		          workInProgress
		        );
		      bubbleProperties(workInProgress);
		      return null;
		    case 22:
		    case 23:
		      return (
		        popSuspenseHandler(workInProgress),
		        popHiddenContext(),
		        (newProps = null !== workInProgress.memoizedState),
		        null !== current
		          ? (null !== current.memoizedState) !== newProps &&
		            (workInProgress.flags |= 8192)
		          : newProps && (workInProgress.flags |= 8192),
		        newProps
		          ? 0 !== (renderLanes & 536870912) &&
		            0 === (workInProgress.flags & 128) &&
		            (bubbleProperties(workInProgress),
		            workInProgress.subtreeFlags & 6 && (workInProgress.flags |= 8192))
		          : bubbleProperties(workInProgress),
		        (renderLanes = workInProgress.updateQueue),
		        null !== renderLanes &&
		          scheduleRetryEffect(workInProgress, renderLanes.retryQueue),
		        (renderLanes = null),
		        null !== current &&
		          null !== current.memoizedState &&
		          null !== current.memoizedState.cachePool &&
		          (renderLanes = current.memoizedState.cachePool.pool),
		        (newProps = null),
		        null !== workInProgress.memoizedState &&
		          null !== workInProgress.memoizedState.cachePool &&
		          (newProps = workInProgress.memoizedState.cachePool.pool),
		        newProps !== renderLanes && (workInProgress.flags |= 2048),
		        null !== current && pop(resumedCache),
		        null
		      );
		    case 24:
		      return (
		        (renderLanes = null),
		        null !== current && (renderLanes = current.memoizedState.cache),
		        workInProgress.memoizedState.cache !== renderLanes &&
		          (workInProgress.flags |= 2048),
		        popProvider(CacheContext),
		        bubbleProperties(workInProgress),
		        null
		      );
		    case 25:
		      return null;
		    case 30:
		      return null;
		  }
		  throw Error(formatProdErrorMessage(156, workInProgress.tag));
		}
		function unwindWork(current, workInProgress) {
		  popTreeContext(workInProgress);
		  switch (workInProgress.tag) {
		    case 1:
		      return (
		        (current = workInProgress.flags),
		        current & 65536
		          ? ((workInProgress.flags = (current & -65537) | 128), workInProgress)
		          : null
		      );
		    case 3:
		      return (
		        popProvider(CacheContext),
		        popHostContainer(),
		        (current = workInProgress.flags),
		        0 !== (current & 65536) && 0 === (current & 128)
		          ? ((workInProgress.flags = (current & -65537) | 128), workInProgress)
		          : null
		      );
		    case 26:
		    case 27:
		    case 5:
		      return popHostContext(workInProgress), null;
		    case 13:
		      popSuspenseHandler(workInProgress);
		      current = workInProgress.memoizedState;
		      if (null !== current && null !== current.dehydrated) {
		        if (null === workInProgress.alternate)
		          throw Error(formatProdErrorMessage(340));
		        resetHydrationState();
		      }
		      current = workInProgress.flags;
		      return current & 65536
		        ? ((workInProgress.flags = (current & -65537) | 128), workInProgress)
		        : null;
		    case 19:
		      return pop(suspenseStackCursor), null;
		    case 4:
		      return popHostContainer(), null;
		    case 10:
		      return popProvider(workInProgress.type), null;
		    case 22:
		    case 23:
		      return (
		        popSuspenseHandler(workInProgress),
		        popHiddenContext(),
		        null !== current && pop(resumedCache),
		        (current = workInProgress.flags),
		        current & 65536
		          ? ((workInProgress.flags = (current & -65537) | 128), workInProgress)
		          : null
		      );
		    case 24:
		      return popProvider(CacheContext), null;
		    case 25:
		      return null;
		    default:
		      return null;
		  }
		}
		function unwindInterruptedWork(current, interruptedWork) {
		  popTreeContext(interruptedWork);
		  switch (interruptedWork.tag) {
		    case 3:
		      popProvider(CacheContext);
		      popHostContainer();
		      break;
		    case 26:
		    case 27:
		    case 5:
		      popHostContext(interruptedWork);
		      break;
		    case 4:
		      popHostContainer();
		      break;
		    case 13:
		      popSuspenseHandler(interruptedWork);
		      break;
		    case 19:
		      pop(suspenseStackCursor);
		      break;
		    case 10:
		      popProvider(interruptedWork.type);
		      break;
		    case 22:
		    case 23:
		      popSuspenseHandler(interruptedWork);
		      popHiddenContext();
		      null !== current && pop(resumedCache);
		      break;
		    case 24:
		      popProvider(CacheContext);
		  }
		}
		function commitHookEffectListMount(flags, finishedWork) {
		  try {
		    var updateQueue = finishedWork.updateQueue,
		      lastEffect = null !== updateQueue ? updateQueue.lastEffect : null;
		    if (null !== lastEffect) {
		      var firstEffect = lastEffect.next;
		      updateQueue = firstEffect;
		      do {
		        if ((updateQueue.tag & flags) === flags) {
		          lastEffect = void 0;
		          var create = updateQueue.create,
		            inst = updateQueue.inst;
		          lastEffect = create();
		          inst.destroy = lastEffect;
		        }
		        updateQueue = updateQueue.next;
		      } while (updateQueue !== firstEffect);
		    }
		  } catch (error) {
		    captureCommitPhaseError(finishedWork, finishedWork.return, error);
		  }
		}
		function commitHookEffectListUnmount(
		  flags,
		  finishedWork,
		  nearestMountedAncestor$jscomp$0
		) {
		  try {
		    var updateQueue = finishedWork.updateQueue,
		      lastEffect = null !== updateQueue ? updateQueue.lastEffect : null;
		    if (null !== lastEffect) {
		      var firstEffect = lastEffect.next;
		      updateQueue = firstEffect;
		      do {
		        if ((updateQueue.tag & flags) === flags) {
		          var inst = updateQueue.inst,
		            destroy = inst.destroy;
		          if (void 0 !== destroy) {
		            inst.destroy = void 0;
		            lastEffect = finishedWork;
		            var nearestMountedAncestor = nearestMountedAncestor$jscomp$0,
		              destroy_ = destroy;
		            try {
		              destroy_();
		            } catch (error) {
		              captureCommitPhaseError(
		                lastEffect,
		                nearestMountedAncestor,
		                error
		              );
		            }
		          }
		        }
		        updateQueue = updateQueue.next;
		      } while (updateQueue !== firstEffect);
		    }
		  } catch (error) {
		    captureCommitPhaseError(finishedWork, finishedWork.return, error);
		  }
		}
		function commitClassCallbacks(finishedWork) {
		  var updateQueue = finishedWork.updateQueue;
		  if (null !== updateQueue) {
		    var instance = finishedWork.stateNode;
		    try {
		      commitCallbacks(updateQueue, instance);
		    } catch (error) {
		      captureCommitPhaseError(finishedWork, finishedWork.return, error);
		    }
		  }
		}
		function safelyCallComponentWillUnmount(
		  current,
		  nearestMountedAncestor,
		  instance
		) {
		  instance.props = resolveClassComponentProps(
		    current.type,
		    current.memoizedProps
		  );
		  instance.state = current.memoizedState;
		  try {
		    instance.componentWillUnmount();
		  } catch (error) {
		    captureCommitPhaseError(current, nearestMountedAncestor, error);
		  }
		}
		function safelyAttachRef(current, nearestMountedAncestor) {
		  try {
		    var ref = current.ref;
		    if (null !== ref) {
		      switch (current.tag) {
		        case 26:
		        case 27:
		        case 5:
		          var instanceToUse = current.stateNode;
		          break;
		        case 30:
		          instanceToUse = current.stateNode;
		          break;
		        default:
		          instanceToUse = current.stateNode;
		      }
		      "function" === typeof ref
		        ? (current.refCleanup = ref(instanceToUse))
		        : (ref.current = instanceToUse);
		    }
		  } catch (error) {
		    captureCommitPhaseError(current, nearestMountedAncestor, error);
		  }
		}
		function safelyDetachRef(current, nearestMountedAncestor) {
		  var ref = current.ref,
		    refCleanup = current.refCleanup;
		  if (null !== ref)
		    if ("function" === typeof refCleanup)
		      try {
		        refCleanup();
		      } catch (error) {
		        captureCommitPhaseError(current, nearestMountedAncestor, error);
		      } finally {
		        (current.refCleanup = null),
		          (current = current.alternate),
		          null != current && (current.refCleanup = null);
		      }
		    else if ("function" === typeof ref)
		      try {
		        ref(null);
		      } catch (error$143) {
		        captureCommitPhaseError(current, nearestMountedAncestor, error$143);
		      }
		    else ref.current = null;
		}
		function commitHostMount(finishedWork) {
		  var type = finishedWork.type,
		    props = finishedWork.memoizedProps,
		    instance = finishedWork.stateNode;
		  try {
		    a: switch (type) {
		      case "button":
		      case "input":
		      case "select":
		      case "textarea":
		        props.autoFocus && instance.focus();
		        break a;
		      case "img":
		        props.src
		          ? (instance.src = props.src)
		          : props.srcSet && (instance.srcset = props.srcSet);
		    }
		  } catch (error) {
		    captureCommitPhaseError(finishedWork, finishedWork.return, error);
		  }
		}
		function commitHostUpdate(finishedWork, newProps, oldProps) {
		  try {
		    var domElement = finishedWork.stateNode;
		    updateProperties(domElement, finishedWork.type, oldProps, newProps);
		    domElement[internalPropsKey] = newProps;
		  } catch (error) {
		    captureCommitPhaseError(finishedWork, finishedWork.return, error);
		  }
		}
		function isHostParent(fiber) {
		  return (
		    5 === fiber.tag ||
		    3 === fiber.tag ||
		    26 === fiber.tag ||
		    (27 === fiber.tag && isSingletonScope(fiber.type)) ||
		    4 === fiber.tag
		  );
		}
		function getHostSibling(fiber) {
		  a: for (;;) {
		    for (; null === fiber.sibling; ) {
		      if (null === fiber.return || isHostParent(fiber.return)) return null;
		      fiber = fiber.return;
		    }
		    fiber.sibling.return = fiber.return;
		    for (
		      fiber = fiber.sibling;
		      5 !== fiber.tag && 6 !== fiber.tag && 18 !== fiber.tag;

		    ) {
		      if (27 === fiber.tag && isSingletonScope(fiber.type)) continue a;
		      if (fiber.flags & 2) continue a;
		      if (null === fiber.child || 4 === fiber.tag) continue a;
		      else (fiber.child.return = fiber), (fiber = fiber.child);
		    }
		    if (!(fiber.flags & 2)) return fiber.stateNode;
		  }
		}
		function insertOrAppendPlacementNodeIntoContainer(node, before, parent) {
		  var tag = node.tag;
		  if (5 === tag || 6 === tag)
		    (node = node.stateNode),
		      before
		        ? (9 === parent.nodeType
		            ? parent.body
		            : "HTML" === parent.nodeName
		              ? parent.ownerDocument.body
		              : parent
		          ).insertBefore(node, before)
		        : ((before =
		            9 === parent.nodeType
		              ? parent.body
		              : "HTML" === parent.nodeName
		                ? parent.ownerDocument.body
		                : parent),
		          before.appendChild(node),
		          (parent = parent._reactRootContainer),
		          (null !== parent && void 0 !== parent) ||
		            null !== before.onclick ||
		            (before.onclick = noop$1));
		  else if (
		    4 !== tag &&
		    (27 === tag &&
		      isSingletonScope(node.type) &&
		      ((parent = node.stateNode), (before = null)),
		    (node = node.child),
		    null !== node)
		  )
		    for (
		      insertOrAppendPlacementNodeIntoContainer(node, before, parent),
		        node = node.sibling;
		      null !== node;

		    )
		      insertOrAppendPlacementNodeIntoContainer(node, before, parent),
		        (node = node.sibling);
		}
		function insertOrAppendPlacementNode(node, before, parent) {
		  var tag = node.tag;
		  if (5 === tag || 6 === tag)
		    (node = node.stateNode),
		      before ? parent.insertBefore(node, before) : parent.appendChild(node);
		  else if (
		    4 !== tag &&
		    (27 === tag && isSingletonScope(node.type) && (parent = node.stateNode),
		    (node = node.child),
		    null !== node)
		  )
		    for (
		      insertOrAppendPlacementNode(node, before, parent), node = node.sibling;
		      null !== node;

		    )
		      insertOrAppendPlacementNode(node, before, parent), (node = node.sibling);
		}
		function commitHostSingletonAcquisition(finishedWork) {
		  var singleton = finishedWork.stateNode,
		    props = finishedWork.memoizedProps;
		  try {
		    for (
		      var type = finishedWork.type, attributes = singleton.attributes;
		      attributes.length;

		    )
		      singleton.removeAttributeNode(attributes[0]);
		    setInitialProperties(singleton, type, props);
		    singleton[internalInstanceKey] = finishedWork;
		    singleton[internalPropsKey] = props;
		  } catch (error) {
		    captureCommitPhaseError(finishedWork, finishedWork.return, error);
		  }
		}
		var offscreenSubtreeIsHidden = false,
		  offscreenSubtreeWasHidden = false,
		  needsFormReset = false,
		  PossiblyWeakSet = "function" === typeof WeakSet ? WeakSet : Set,
		  nextEffect = null;
		function commitBeforeMutationEffects(root, firstChild) {
		  root = root.containerInfo;
		  eventsEnabled = _enabled;
		  root = getActiveElementDeep(root);
		  if (hasSelectionCapabilities(root)) {
		    if ("selectionStart" in root)
		      var JSCompiler_temp = {
		        start: root.selectionStart,
		        end: root.selectionEnd
		      };
		    else
		      a: {
		        JSCompiler_temp =
		          ((JSCompiler_temp = root.ownerDocument) &&
		            JSCompiler_temp.defaultView) ||
		          window;
		        var selection =
		          JSCompiler_temp.getSelection && JSCompiler_temp.getSelection();
		        if (selection && 0 !== selection.rangeCount) {
		          JSCompiler_temp = selection.anchorNode;
		          var anchorOffset = selection.anchorOffset,
		            focusNode = selection.focusNode;
		          selection = selection.focusOffset;
		          try {
		            JSCompiler_temp.nodeType, focusNode.nodeType;
		          } catch (e$20) {
		            JSCompiler_temp = null;
		            break a;
		          }
		          var length = 0,
		            start = -1,
		            end = -1,
		            indexWithinAnchor = 0,
		            indexWithinFocus = 0,
		            node = root,
		            parentNode = null;
		          b: for (;;) {
		            for (var next; ; ) {
		              node !== JSCompiler_temp ||
		                (0 !== anchorOffset && 3 !== node.nodeType) ||
		                (start = length + anchorOffset);
		              node !== focusNode ||
		                (0 !== selection && 3 !== node.nodeType) ||
		                (end = length + selection);
		              3 === node.nodeType && (length += node.nodeValue.length);
		              if (null === (next = node.firstChild)) break;
		              parentNode = node;
		              node = next;
		            }
		            for (;;) {
		              if (node === root) break b;
		              parentNode === JSCompiler_temp &&
		                ++indexWithinAnchor === anchorOffset &&
		                (start = length);
		              parentNode === focusNode &&
		                ++indexWithinFocus === selection &&
		                (end = length);
		              if (null !== (next = node.nextSibling)) break;
		              node = parentNode;
		              parentNode = node.parentNode;
		            }
		            node = next;
		          }
		          JSCompiler_temp =
		            -1 === start || -1 === end ? null : { start: start, end: end };
		        } else JSCompiler_temp = null;
		      }
		    JSCompiler_temp = JSCompiler_temp || { start: 0, end: 0 };
		  } else JSCompiler_temp = null;
		  selectionInformation = { focusedElem: root, selectionRange: JSCompiler_temp };
		  _enabled = false;
		  for (nextEffect = firstChild; null !== nextEffect; )
		    if (
		      ((firstChild = nextEffect),
		      (root = firstChild.child),
		      0 !== (firstChild.subtreeFlags & 1024) && null !== root)
		    )
		      (root.return = firstChild), (nextEffect = root);
		    else
		      for (; null !== nextEffect; ) {
		        firstChild = nextEffect;
		        focusNode = firstChild.alternate;
		        root = firstChild.flags;
		        switch (firstChild.tag) {
		          case 0:
		            break;
		          case 11:
		          case 15:
		            break;
		          case 1:
		            if (0 !== (root & 1024) && null !== focusNode) {
		              root = void 0;
		              JSCompiler_temp = firstChild;
		              anchorOffset = focusNode.memoizedProps;
		              focusNode = focusNode.memoizedState;
		              selection = JSCompiler_temp.stateNode;
		              try {
		                var resolvedPrevProps = resolveClassComponentProps(
		                  JSCompiler_temp.type,
		                  anchorOffset,
		                  JSCompiler_temp.elementType === JSCompiler_temp.type
		                );
		                root = selection.getSnapshotBeforeUpdate(
		                  resolvedPrevProps,
		                  focusNode
		                );
		                selection.__reactInternalSnapshotBeforeUpdate = root;
		              } catch (error) {
		                captureCommitPhaseError(
		                  JSCompiler_temp,
		                  JSCompiler_temp.return,
		                  error
		                );
		              }
		            }
		            break;
		          case 3:
		            if (0 !== (root & 1024))
		              if (
		                ((root = firstChild.stateNode.containerInfo),
		                (JSCompiler_temp = root.nodeType),
		                9 === JSCompiler_temp)
		              )
		                clearContainerSparingly(root);
		              else if (1 === JSCompiler_temp)
		                switch (root.nodeName) {
		                  case "HEAD":
		                  case "HTML":
		                  case "BODY":
		                    clearContainerSparingly(root);
		                    break;
		                  default:
		                    root.textContent = "";
		                }
		            break;
		          case 5:
		          case 26:
		          case 27:
		          case 6:
		          case 4:
		          case 17:
		            break;
		          default:
		            if (0 !== (root & 1024)) throw Error(formatProdErrorMessage(163));
		        }
		        root = firstChild.sibling;
		        if (null !== root) {
		          root.return = firstChild.return;
		          nextEffect = root;
		          break;
		        }
		        nextEffect = firstChild.return;
		      }
		}
		function commitLayoutEffectOnFiber(finishedRoot, current, finishedWork) {
		  var flags = finishedWork.flags;
		  switch (finishedWork.tag) {
		    case 0:
		    case 11:
		    case 15:
		      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
		      flags & 4 && commitHookEffectListMount(5, finishedWork);
		      break;
		    case 1:
		      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
		      if (flags & 4)
		        if (((finishedRoot = finishedWork.stateNode), null === current))
		          try {
		            finishedRoot.componentDidMount();
		          } catch (error) {
		            captureCommitPhaseError(finishedWork, finishedWork.return, error);
		          }
		        else {
		          var prevProps = resolveClassComponentProps(
		            finishedWork.type,
		            current.memoizedProps
		          );
		          current = current.memoizedState;
		          try {
		            finishedRoot.componentDidUpdate(
		              prevProps,
		              current,
		              finishedRoot.__reactInternalSnapshotBeforeUpdate
		            );
		          } catch (error$142) {
		            captureCommitPhaseError(
		              finishedWork,
		              finishedWork.return,
		              error$142
		            );
		          }
		        }
		      flags & 64 && commitClassCallbacks(finishedWork);
		      flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
		      break;
		    case 3:
		      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
		      if (
		        flags & 64 &&
		        ((finishedRoot = finishedWork.updateQueue), null !== finishedRoot)
		      ) {
		        current = null;
		        if (null !== finishedWork.child)
		          switch (finishedWork.child.tag) {
		            case 27:
		            case 5:
		              current = finishedWork.child.stateNode;
		              break;
		            case 1:
		              current = finishedWork.child.stateNode;
		          }
		        try {
		          commitCallbacks(finishedRoot, current);
		        } catch (error) {
		          captureCommitPhaseError(finishedWork, finishedWork.return, error);
		        }
		      }
		      break;
		    case 27:
		      null === current &&
		        flags & 4 &&
		        commitHostSingletonAcquisition(finishedWork);
		    case 26:
		    case 5:
		      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
		      null === current && flags & 4 && commitHostMount(finishedWork);
		      flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
		      break;
		    case 12:
		      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
		      break;
		    case 13:
		      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
		      flags & 4 && commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
		      flags & 64 &&
		        ((finishedRoot = finishedWork.memoizedState),
		        null !== finishedRoot &&
		          ((finishedRoot = finishedRoot.dehydrated),
		          null !== finishedRoot &&
		            ((finishedWork = retryDehydratedSuspenseBoundary.bind(
		              null,
		              finishedWork
		            )),
		            registerSuspenseInstanceRetry(finishedRoot, finishedWork))));
		      break;
		    case 22:
		      flags = null !== finishedWork.memoizedState || offscreenSubtreeIsHidden;
		      if (!flags) {
		        current =
		          (null !== current && null !== current.memoizedState) ||
		          offscreenSubtreeWasHidden;
		        prevProps = offscreenSubtreeIsHidden;
		        var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
		        offscreenSubtreeIsHidden = flags;
		        (offscreenSubtreeWasHidden = current) && !prevOffscreenSubtreeWasHidden
		          ? recursivelyTraverseReappearLayoutEffects(
		              finishedRoot,
		              finishedWork,
		              0 !== (finishedWork.subtreeFlags & 8772)
		            )
		          : recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
		        offscreenSubtreeIsHidden = prevProps;
		        offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
		      }
		      break;
		    case 30:
		      break;
		    default:
		      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
		  }
		}
		function detachFiberAfterEffects(fiber) {
		  var alternate = fiber.alternate;
		  null !== alternate &&
		    ((fiber.alternate = null), detachFiberAfterEffects(alternate));
		  fiber.child = null;
		  fiber.deletions = null;
		  fiber.sibling = null;
		  5 === fiber.tag &&
		    ((alternate = fiber.stateNode),
		    null !== alternate && detachDeletedInstance(alternate));
		  fiber.stateNode = null;
		  fiber.return = null;
		  fiber.dependencies = null;
		  fiber.memoizedProps = null;
		  fiber.memoizedState = null;
		  fiber.pendingProps = null;
		  fiber.stateNode = null;
		  fiber.updateQueue = null;
		}
		var hostParent = null,
		  hostParentIsContainer = false;
		function recursivelyTraverseDeletionEffects(
		  finishedRoot,
		  nearestMountedAncestor,
		  parent
		) {
		  for (parent = parent.child; null !== parent; )
		    commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, parent),
		      (parent = parent.sibling);
		}
		function commitDeletionEffectsOnFiber(
		  finishedRoot,
		  nearestMountedAncestor,
		  deletedFiber
		) {
		  if (injectedHook && "function" === typeof injectedHook.onCommitFiberUnmount)
		    try {
		      injectedHook.onCommitFiberUnmount(rendererID, deletedFiber);
		    } catch (err) {}
		  switch (deletedFiber.tag) {
		    case 26:
		      offscreenSubtreeWasHidden ||
		        safelyDetachRef(deletedFiber, nearestMountedAncestor);
		      recursivelyTraverseDeletionEffects(
		        finishedRoot,
		        nearestMountedAncestor,
		        deletedFiber
		      );
		      deletedFiber.memoizedState
		        ? deletedFiber.memoizedState.count--
		        : deletedFiber.stateNode &&
		          ((deletedFiber = deletedFiber.stateNode),
		          deletedFiber.parentNode.removeChild(deletedFiber));
		      break;
		    case 27:
		      offscreenSubtreeWasHidden ||
		        safelyDetachRef(deletedFiber, nearestMountedAncestor);
		      var prevHostParent = hostParent,
		        prevHostParentIsContainer = hostParentIsContainer;
		      isSingletonScope(deletedFiber.type) &&
		        ((hostParent = deletedFiber.stateNode), (hostParentIsContainer = false));
		      recursivelyTraverseDeletionEffects(
		        finishedRoot,
		        nearestMountedAncestor,
		        deletedFiber
		      );
		      releaseSingletonInstance(deletedFiber.stateNode);
		      hostParent = prevHostParent;
		      hostParentIsContainer = prevHostParentIsContainer;
		      break;
		    case 5:
		      offscreenSubtreeWasHidden ||
		        safelyDetachRef(deletedFiber, nearestMountedAncestor);
		    case 6:
		      prevHostParent = hostParent;
		      prevHostParentIsContainer = hostParentIsContainer;
		      hostParent = null;
		      recursivelyTraverseDeletionEffects(
		        finishedRoot,
		        nearestMountedAncestor,
		        deletedFiber
		      );
		      hostParent = prevHostParent;
		      hostParentIsContainer = prevHostParentIsContainer;
		      if (null !== hostParent)
		        if (hostParentIsContainer)
		          try {
		            (9 === hostParent.nodeType
		              ? hostParent.body
		              : "HTML" === hostParent.nodeName
		                ? hostParent.ownerDocument.body
		                : hostParent
		            ).removeChild(deletedFiber.stateNode);
		          } catch (error) {
		            captureCommitPhaseError(
		              deletedFiber,
		              nearestMountedAncestor,
		              error
		            );
		          }
		        else
		          try {
		            hostParent.removeChild(deletedFiber.stateNode);
		          } catch (error) {
		            captureCommitPhaseError(
		              deletedFiber,
		              nearestMountedAncestor,
		              error
		            );
		          }
		      break;
		    case 18:
		      null !== hostParent &&
		        (hostParentIsContainer
		          ? ((finishedRoot = hostParent),
		            clearSuspenseBoundary(
		              9 === finishedRoot.nodeType
		                ? finishedRoot.body
		                : "HTML" === finishedRoot.nodeName
		                  ? finishedRoot.ownerDocument.body
		                  : finishedRoot,
		              deletedFiber.stateNode
		            ),
		            retryIfBlockedOn(finishedRoot))
		          : clearSuspenseBoundary(hostParent, deletedFiber.stateNode));
		      break;
		    case 4:
		      prevHostParent = hostParent;
		      prevHostParentIsContainer = hostParentIsContainer;
		      hostParent = deletedFiber.stateNode.containerInfo;
		      hostParentIsContainer = true;
		      recursivelyTraverseDeletionEffects(
		        finishedRoot,
		        nearestMountedAncestor,
		        deletedFiber
		      );
		      hostParent = prevHostParent;
		      hostParentIsContainer = prevHostParentIsContainer;
		      break;
		    case 0:
		    case 11:
		    case 14:
		    case 15:
		      offscreenSubtreeWasHidden ||
		        commitHookEffectListUnmount(2, deletedFiber, nearestMountedAncestor);
		      offscreenSubtreeWasHidden ||
		        commitHookEffectListUnmount(4, deletedFiber, nearestMountedAncestor);
		      recursivelyTraverseDeletionEffects(
		        finishedRoot,
		        nearestMountedAncestor,
		        deletedFiber
		      );
		      break;
		    case 1:
		      offscreenSubtreeWasHidden ||
		        (safelyDetachRef(deletedFiber, nearestMountedAncestor),
		        (prevHostParent = deletedFiber.stateNode),
		        "function" === typeof prevHostParent.componentWillUnmount &&
		          safelyCallComponentWillUnmount(
		            deletedFiber,
		            nearestMountedAncestor,
		            prevHostParent
		          ));
		      recursivelyTraverseDeletionEffects(
		        finishedRoot,
		        nearestMountedAncestor,
		        deletedFiber
		      );
		      break;
		    case 21:
		      recursivelyTraverseDeletionEffects(
		        finishedRoot,
		        nearestMountedAncestor,
		        deletedFiber
		      );
		      break;
		    case 22:
		      offscreenSubtreeWasHidden =
		        (prevHostParent = offscreenSubtreeWasHidden) ||
		        null !== deletedFiber.memoizedState;
		      recursivelyTraverseDeletionEffects(
		        finishedRoot,
		        nearestMountedAncestor,
		        deletedFiber
		      );
		      offscreenSubtreeWasHidden = prevHostParent;
		      break;
		    default:
		      recursivelyTraverseDeletionEffects(
		        finishedRoot,
		        nearestMountedAncestor,
		        deletedFiber
		      );
		  }
		}
		function commitSuspenseHydrationCallbacks(finishedRoot, finishedWork) {
		  if (
		    null === finishedWork.memoizedState &&
		    ((finishedRoot = finishedWork.alternate),
		    null !== finishedRoot &&
		      ((finishedRoot = finishedRoot.memoizedState),
		      null !== finishedRoot &&
		        ((finishedRoot = finishedRoot.dehydrated), null !== finishedRoot)))
		  )
		    try {
		      retryIfBlockedOn(finishedRoot);
		    } catch (error) {
		      captureCommitPhaseError(finishedWork, finishedWork.return, error);
		    }
		}
		function getRetryCache(finishedWork) {
		  switch (finishedWork.tag) {
		    case 13:
		    case 19:
		      var retryCache = finishedWork.stateNode;
		      null === retryCache &&
		        (retryCache = finishedWork.stateNode = new PossiblyWeakSet());
		      return retryCache;
		    case 22:
		      return (
		        (finishedWork = finishedWork.stateNode),
		        (retryCache = finishedWork._retryCache),
		        null === retryCache &&
		          (retryCache = finishedWork._retryCache = new PossiblyWeakSet()),
		        retryCache
		      );
		    default:
		      throw Error(formatProdErrorMessage(435, finishedWork.tag));
		  }
		}
		function attachSuspenseRetryListeners(finishedWork, wakeables) {
		  var retryCache = getRetryCache(finishedWork);
		  wakeables.forEach(function (wakeable) {
		    var retry = resolveRetryWakeable.bind(null, finishedWork, wakeable);
		    retryCache.has(wakeable) ||
		      (retryCache.add(wakeable), wakeable.then(retry, retry));
		  });
		}
		function recursivelyTraverseMutationEffects(root$jscomp$0, parentFiber) {
		  var deletions = parentFiber.deletions;
		  if (null !== deletions)
		    for (var i = 0; i < deletions.length; i++) {
		      var childToDelete = deletions[i],
		        root = root$jscomp$0,
		        returnFiber = parentFiber,
		        parent = returnFiber;
		      a: for (; null !== parent; ) {
		        switch (parent.tag) {
		          case 27:
		            if (isSingletonScope(parent.type)) {
		              hostParent = parent.stateNode;
		              hostParentIsContainer = false;
		              break a;
		            }
		            break;
		          case 5:
		            hostParent = parent.stateNode;
		            hostParentIsContainer = false;
		            break a;
		          case 3:
		          case 4:
		            hostParent = parent.stateNode.containerInfo;
		            hostParentIsContainer = true;
		            break a;
		        }
		        parent = parent.return;
		      }
		      if (null === hostParent) throw Error(formatProdErrorMessage(160));
		      commitDeletionEffectsOnFiber(root, returnFiber, childToDelete);
		      hostParent = null;
		      hostParentIsContainer = false;
		      root = childToDelete.alternate;
		      null !== root && (root.return = null);
		      childToDelete.return = null;
		    }
		  if (parentFiber.subtreeFlags & 13878)
		    for (parentFiber = parentFiber.child; null !== parentFiber; )
		      commitMutationEffectsOnFiber(parentFiber, root$jscomp$0),
		        (parentFiber = parentFiber.sibling);
		}
		var currentHoistableRoot = null;
		function commitMutationEffectsOnFiber(finishedWork, root) {
		  var current = finishedWork.alternate,
		    flags = finishedWork.flags;
		  switch (finishedWork.tag) {
		    case 0:
		    case 11:
		    case 14:
		    case 15:
		      recursivelyTraverseMutationEffects(root, finishedWork);
		      commitReconciliationEffects(finishedWork);
		      flags & 4 &&
		        (commitHookEffectListUnmount(3, finishedWork, finishedWork.return),
		        commitHookEffectListMount(3, finishedWork),
		        commitHookEffectListUnmount(5, finishedWork, finishedWork.return));
		      break;
		    case 1:
		      recursivelyTraverseMutationEffects(root, finishedWork);
		      commitReconciliationEffects(finishedWork);
		      flags & 512 &&
		        (offscreenSubtreeWasHidden ||
		          null === current ||
		          safelyDetachRef(current, current.return));
		      flags & 64 &&
		        offscreenSubtreeIsHidden &&
		        ((finishedWork = finishedWork.updateQueue),
		        null !== finishedWork &&
		          ((flags = finishedWork.callbacks),
		          null !== flags &&
		            ((current = finishedWork.shared.hiddenCallbacks),
		            (finishedWork.shared.hiddenCallbacks =
		              null === current ? flags : current.concat(flags)))));
		      break;
		    case 26:
		      var hoistableRoot = currentHoistableRoot;
		      recursivelyTraverseMutationEffects(root, finishedWork);
		      commitReconciliationEffects(finishedWork);
		      flags & 512 &&
		        (offscreenSubtreeWasHidden ||
		          null === current ||
		          safelyDetachRef(current, current.return));
		      if (flags & 4) {
		        var currentResource = null !== current ? current.memoizedState : null;
		        flags = finishedWork.memoizedState;
		        if (null === current)
		          if (null === flags)
		            if (null === finishedWork.stateNode) {
		              a: {
		                flags = finishedWork.type;
		                current = finishedWork.memoizedProps;
		                hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
		                b: switch (flags) {
		                  case "title":
		                    currentResource =
		                      hoistableRoot.getElementsByTagName("title")[0];
		                    if (
		                      !currentResource ||
		                      currentResource[internalHoistableMarker] ||
		                      currentResource[internalInstanceKey] ||
		                      "http://www.w3.org/2000/svg" ===
		                        currentResource.namespaceURI ||
		                      currentResource.hasAttribute("itemprop")
		                    )
		                      (currentResource = hoistableRoot.createElement(flags)),
		                        hoistableRoot.head.insertBefore(
		                          currentResource,
		                          hoistableRoot.querySelector("head > title")
		                        );
		                    setInitialProperties(currentResource, flags, current);
		                    currentResource[internalInstanceKey] = finishedWork;
		                    markNodeAsHoistable(currentResource);
		                    flags = currentResource;
		                    break a;
		                  case "link":
		                    var maybeNodes = getHydratableHoistableCache(
		                      "link",
		                      "href",
		                      hoistableRoot
		                    ).get(flags + (current.href || ""));
		                    if (maybeNodes)
		                      for (var i = 0; i < maybeNodes.length; i++)
		                        if (
		                          ((currentResource = maybeNodes[i]),
		                          currentResource.getAttribute("href") ===
		                            (null == current.href || "" === current.href
		                              ? null
		                              : current.href) &&
		                            currentResource.getAttribute("rel") ===
		                              (null == current.rel ? null : current.rel) &&
		                            currentResource.getAttribute("title") ===
		                              (null == current.title ? null : current.title) &&
		                            currentResource.getAttribute("crossorigin") ===
		                              (null == current.crossOrigin
		                                ? null
		                                : current.crossOrigin))
		                        ) {
		                          maybeNodes.splice(i, 1);
		                          break b;
		                        }
		                    currentResource = hoistableRoot.createElement(flags);
		                    setInitialProperties(currentResource, flags, current);
		                    hoistableRoot.head.appendChild(currentResource);
		                    break;
		                  case "meta":
		                    if (
		                      (maybeNodes = getHydratableHoistableCache(
		                        "meta",
		                        "content",
		                        hoistableRoot
		                      ).get(flags + (current.content || "")))
		                    )
		                      for (i = 0; i < maybeNodes.length; i++)
		                        if (
		                          ((currentResource = maybeNodes[i]),
		                          currentResource.getAttribute("content") ===
		                            (null == current.content
		                              ? null
		                              : "" + current.content) &&
		                            currentResource.getAttribute("name") ===
		                              (null == current.name ? null : current.name) &&
		                            currentResource.getAttribute("property") ===
		                              (null == current.property
		                                ? null
		                                : current.property) &&
		                            currentResource.getAttribute("http-equiv") ===
		                              (null == current.httpEquiv
		                                ? null
		                                : current.httpEquiv) &&
		                            currentResource.getAttribute("charset") ===
		                              (null == current.charSet
		                                ? null
		                                : current.charSet))
		                        ) {
		                          maybeNodes.splice(i, 1);
		                          break b;
		                        }
		                    currentResource = hoistableRoot.createElement(flags);
		                    setInitialProperties(currentResource, flags, current);
		                    hoistableRoot.head.appendChild(currentResource);
		                    break;
		                  default:
		                    throw Error(formatProdErrorMessage(468, flags));
		                }
		                currentResource[internalInstanceKey] = finishedWork;
		                markNodeAsHoistable(currentResource);
		                flags = currentResource;
		              }
		              finishedWork.stateNode = flags;
		            } else
		              mountHoistable(
		                hoistableRoot,
		                finishedWork.type,
		                finishedWork.stateNode
		              );
		          else
		            finishedWork.stateNode = acquireResource(
		              hoistableRoot,
		              flags,
		              finishedWork.memoizedProps
		            );
		        else
		          currentResource !== flags
		            ? (null === currentResource
		                ? null !== current.stateNode &&
		                  ((current = current.stateNode),
		                  current.parentNode.removeChild(current))
		                : currentResource.count--,
		              null === flags
		                ? mountHoistable(
		                    hoistableRoot,
		                    finishedWork.type,
		                    finishedWork.stateNode
		                  )
		                : acquireResource(
		                    hoistableRoot,
		                    flags,
		                    finishedWork.memoizedProps
		                  ))
		            : null === flags &&
		              null !== finishedWork.stateNode &&
		              commitHostUpdate(
		                finishedWork,
		                finishedWork.memoizedProps,
		                current.memoizedProps
		              );
		      }
		      break;
		    case 27:
		      recursivelyTraverseMutationEffects(root, finishedWork);
		      commitReconciliationEffects(finishedWork);
		      flags & 512 &&
		        (offscreenSubtreeWasHidden ||
		          null === current ||
		          safelyDetachRef(current, current.return));
		      null !== current &&
		        flags & 4 &&
		        commitHostUpdate(
		          finishedWork,
		          finishedWork.memoizedProps,
		          current.memoizedProps
		        );
		      break;
		    case 5:
		      recursivelyTraverseMutationEffects(root, finishedWork);
		      commitReconciliationEffects(finishedWork);
		      flags & 512 &&
		        (offscreenSubtreeWasHidden ||
		          null === current ||
		          safelyDetachRef(current, current.return));
		      if (finishedWork.flags & 32) {
		        hoistableRoot = finishedWork.stateNode;
		        try {
		          setTextContent(hoistableRoot, "");
		        } catch (error) {
		          captureCommitPhaseError(finishedWork, finishedWork.return, error);
		        }
		      }
		      flags & 4 &&
		        null != finishedWork.stateNode &&
		        ((hoistableRoot = finishedWork.memoizedProps),
		        commitHostUpdate(
		          finishedWork,
		          hoistableRoot,
		          null !== current ? current.memoizedProps : hoistableRoot
		        ));
		      flags & 1024 && (needsFormReset = true);
		      break;
		    case 6:
		      recursivelyTraverseMutationEffects(root, finishedWork);
		      commitReconciliationEffects(finishedWork);
		      if (flags & 4) {
		        if (null === finishedWork.stateNode)
		          throw Error(formatProdErrorMessage(162));
		        flags = finishedWork.memoizedProps;
		        current = finishedWork.stateNode;
		        try {
		          current.nodeValue = flags;
		        } catch (error) {
		          captureCommitPhaseError(finishedWork, finishedWork.return, error);
		        }
		      }
		      break;
		    case 3:
		      tagCaches = null;
		      hoistableRoot = currentHoistableRoot;
		      currentHoistableRoot = getHoistableRoot(root.containerInfo);
		      recursivelyTraverseMutationEffects(root, finishedWork);
		      currentHoistableRoot = hoistableRoot;
		      commitReconciliationEffects(finishedWork);
		      if (flags & 4 && null !== current && current.memoizedState.isDehydrated)
		        try {
		          retryIfBlockedOn(root.containerInfo);
		        } catch (error) {
		          captureCommitPhaseError(finishedWork, finishedWork.return, error);
		        }
		      needsFormReset &&
		        ((needsFormReset = false), recursivelyResetForms(finishedWork));
		      break;
		    case 4:
		      flags = currentHoistableRoot;
		      currentHoistableRoot = getHoistableRoot(
		        finishedWork.stateNode.containerInfo
		      );
		      recursivelyTraverseMutationEffects(root, finishedWork);
		      commitReconciliationEffects(finishedWork);
		      currentHoistableRoot = flags;
		      break;
		    case 12:
		      recursivelyTraverseMutationEffects(root, finishedWork);
		      commitReconciliationEffects(finishedWork);
		      break;
		    case 13:
		      recursivelyTraverseMutationEffects(root, finishedWork);
		      commitReconciliationEffects(finishedWork);
		      finishedWork.child.flags & 8192 &&
		        (null !== finishedWork.memoizedState) !==
		          (null !== current && null !== current.memoizedState) &&
		        (globalMostRecentFallbackTime = now());
		      flags & 4 &&
		        ((flags = finishedWork.updateQueue),
		        null !== flags &&
		          ((finishedWork.updateQueue = null),
		          attachSuspenseRetryListeners(finishedWork, flags)));
		      break;
		    case 22:
		      hoistableRoot = null !== finishedWork.memoizedState;
		      var wasHidden = null !== current && null !== current.memoizedState,
		        prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden,
		        prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
		      offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden || hoistableRoot;
		      offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden || wasHidden;
		      recursivelyTraverseMutationEffects(root, finishedWork);
		      offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
		      offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden;
		      commitReconciliationEffects(finishedWork);
		      if (flags & 8192)
		        a: for (
		          root = finishedWork.stateNode,
		            root._visibility = hoistableRoot
		              ? root._visibility & -2
		              : root._visibility | 1,
		            hoistableRoot &&
		              (null === current ||
		                wasHidden ||
		                offscreenSubtreeIsHidden ||
		                offscreenSubtreeWasHidden ||
		                recursivelyTraverseDisappearLayoutEffects(finishedWork)),
		            current = null,
		            root = finishedWork;
		          ;

		        ) {
		          if (5 === root.tag || 26 === root.tag) {
		            if (null === current) {
		              wasHidden = current = root;
		              try {
		                if (((currentResource = wasHidden.stateNode), hoistableRoot))
		                  (maybeNodes = currentResource.style),
		                    "function" === typeof maybeNodes.setProperty
		                      ? maybeNodes.setProperty("display", "none", "important")
		                      : (maybeNodes.display = "none");
		                else {
		                  i = wasHidden.stateNode;
		                  var styleProp = wasHidden.memoizedProps.style,
		                    display =
		                      void 0 !== styleProp &&
		                      null !== styleProp &&
		                      styleProp.hasOwnProperty("display")
		                        ? styleProp.display
		                        : null;
		                  i.style.display =
		                    null == display || "boolean" === typeof display
		                      ? ""
		                      : ("" + display).trim();
		                }
		              } catch (error) {
		                captureCommitPhaseError(wasHidden, wasHidden.return, error);
		              }
		            }
		          } else if (6 === root.tag) {
		            if (null === current) {
		              wasHidden = root;
		              try {
		                wasHidden.stateNode.nodeValue = hoistableRoot
		                  ? ""
		                  : wasHidden.memoizedProps;
		              } catch (error) {
		                captureCommitPhaseError(wasHidden, wasHidden.return, error);
		              }
		            }
		          } else if (
		            ((22 !== root.tag && 23 !== root.tag) ||
		              null === root.memoizedState ||
		              root === finishedWork) &&
		            null !== root.child
		          ) {
		            root.child.return = root;
		            root = root.child;
		            continue;
		          }
		          if (root === finishedWork) break a;
		          for (; null === root.sibling; ) {
		            if (null === root.return || root.return === finishedWork) break a;
		            current === root && (current = null);
		            root = root.return;
		          }
		          current === root && (current = null);
		          root.sibling.return = root.return;
		          root = root.sibling;
		        }
		      flags & 4 &&
		        ((flags = finishedWork.updateQueue),
		        null !== flags &&
		          ((current = flags.retryQueue),
		          null !== current &&
		            ((flags.retryQueue = null),
		            attachSuspenseRetryListeners(finishedWork, current))));
		      break;
		    case 19:
		      recursivelyTraverseMutationEffects(root, finishedWork);
		      commitReconciliationEffects(finishedWork);
		      flags & 4 &&
		        ((flags = finishedWork.updateQueue),
		        null !== flags &&
		          ((finishedWork.updateQueue = null),
		          attachSuspenseRetryListeners(finishedWork, flags)));
		      break;
		    case 30:
		      break;
		    case 21:
		      break;
		    default:
		      recursivelyTraverseMutationEffects(root, finishedWork),
		        commitReconciliationEffects(finishedWork);
		  }
		}
		function commitReconciliationEffects(finishedWork) {
		  var flags = finishedWork.flags;
		  if (flags & 2) {
		    try {
		      for (
		        var hostParentFiber, parentFiber = finishedWork.return;
		        null !== parentFiber;

		      ) {
		        if (isHostParent(parentFiber)) {
		          hostParentFiber = parentFiber;
		          break;
		        }
		        parentFiber = parentFiber.return;
		      }
		      if (null == hostParentFiber) throw Error(formatProdErrorMessage(160));
		      switch (hostParentFiber.tag) {
		        case 27:
		          var parent = hostParentFiber.stateNode,
		            before = getHostSibling(finishedWork);
		          insertOrAppendPlacementNode(finishedWork, before, parent);
		          break;
		        case 5:
		          var parent$144 = hostParentFiber.stateNode;
		          hostParentFiber.flags & 32 &&
		            (setTextContent(parent$144, ""), (hostParentFiber.flags &= -33));
		          var before$145 = getHostSibling(finishedWork);
		          insertOrAppendPlacementNode(finishedWork, before$145, parent$144);
		          break;
		        case 3:
		        case 4:
		          var parent$146 = hostParentFiber.stateNode.containerInfo,
		            before$147 = getHostSibling(finishedWork);
		          insertOrAppendPlacementNodeIntoContainer(
		            finishedWork,
		            before$147,
		            parent$146
		          );
		          break;
		        default:
		          throw Error(formatProdErrorMessage(161));
		      }
		    } catch (error) {
		      captureCommitPhaseError(finishedWork, finishedWork.return, error);
		    }
		    finishedWork.flags &= -3;
		  }
		  flags & 4096 && (finishedWork.flags &= -4097);
		}
		function recursivelyResetForms(parentFiber) {
		  if (parentFiber.subtreeFlags & 1024)
		    for (parentFiber = parentFiber.child; null !== parentFiber; ) {
		      var fiber = parentFiber;
		      recursivelyResetForms(fiber);
		      5 === fiber.tag && fiber.flags & 1024 && fiber.stateNode.reset();
		      parentFiber = parentFiber.sibling;
		    }
		}
		function recursivelyTraverseLayoutEffects(root, parentFiber) {
		  if (parentFiber.subtreeFlags & 8772)
		    for (parentFiber = parentFiber.child; null !== parentFiber; )
		      commitLayoutEffectOnFiber(root, parentFiber.alternate, parentFiber),
		        (parentFiber = parentFiber.sibling);
		}
		function recursivelyTraverseDisappearLayoutEffects(parentFiber) {
		  for (parentFiber = parentFiber.child; null !== parentFiber; ) {
		    var finishedWork = parentFiber;
		    switch (finishedWork.tag) {
		      case 0:
		      case 11:
		      case 14:
		      case 15:
		        commitHookEffectListUnmount(4, finishedWork, finishedWork.return);
		        recursivelyTraverseDisappearLayoutEffects(finishedWork);
		        break;
		      case 1:
		        safelyDetachRef(finishedWork, finishedWork.return);
		        var instance = finishedWork.stateNode;
		        "function" === typeof instance.componentWillUnmount &&
		          safelyCallComponentWillUnmount(
		            finishedWork,
		            finishedWork.return,
		            instance
		          );
		        recursivelyTraverseDisappearLayoutEffects(finishedWork);
		        break;
		      case 27:
		        releaseSingletonInstance(finishedWork.stateNode);
		      case 26:
		      case 5:
		        safelyDetachRef(finishedWork, finishedWork.return);
		        recursivelyTraverseDisappearLayoutEffects(finishedWork);
		        break;
		      case 22:
		        null === finishedWork.memoizedState &&
		          recursivelyTraverseDisappearLayoutEffects(finishedWork);
		        break;
		      case 30:
		        recursivelyTraverseDisappearLayoutEffects(finishedWork);
		        break;
		      default:
		        recursivelyTraverseDisappearLayoutEffects(finishedWork);
		    }
		    parentFiber = parentFiber.sibling;
		  }
		}
		function recursivelyTraverseReappearLayoutEffects(
		  finishedRoot$jscomp$0,
		  parentFiber,
		  includeWorkInProgressEffects
		) {
		  includeWorkInProgressEffects =
		    includeWorkInProgressEffects && 0 !== (parentFiber.subtreeFlags & 8772);
		  for (parentFiber = parentFiber.child; null !== parentFiber; ) {
		    var current = parentFiber.alternate,
		      finishedRoot = finishedRoot$jscomp$0,
		      finishedWork = parentFiber,
		      flags = finishedWork.flags;
		    switch (finishedWork.tag) {
		      case 0:
		      case 11:
		      case 15:
		        recursivelyTraverseReappearLayoutEffects(
		          finishedRoot,
		          finishedWork,
		          includeWorkInProgressEffects
		        );
		        commitHookEffectListMount(4, finishedWork);
		        break;
		      case 1:
		        recursivelyTraverseReappearLayoutEffects(
		          finishedRoot,
		          finishedWork,
		          includeWorkInProgressEffects
		        );
		        current = finishedWork;
		        finishedRoot = current.stateNode;
		        if ("function" === typeof finishedRoot.componentDidMount)
		          try {
		            finishedRoot.componentDidMount();
		          } catch (error) {
		            captureCommitPhaseError(current, current.return, error);
		          }
		        current = finishedWork;
		        finishedRoot = current.updateQueue;
		        if (null !== finishedRoot) {
		          var instance = current.stateNode;
		          try {
		            var hiddenCallbacks = finishedRoot.shared.hiddenCallbacks;
		            if (null !== hiddenCallbacks)
		              for (
		                finishedRoot.shared.hiddenCallbacks = null, finishedRoot = 0;
		                finishedRoot < hiddenCallbacks.length;
		                finishedRoot++
		              )
		                callCallback(hiddenCallbacks[finishedRoot], instance);
		          } catch (error) {
		            captureCommitPhaseError(current, current.return, error);
		          }
		        }
		        includeWorkInProgressEffects &&
		          flags & 64 &&
		          commitClassCallbacks(finishedWork);
		        safelyAttachRef(finishedWork, finishedWork.return);
		        break;
		      case 27:
		        commitHostSingletonAcquisition(finishedWork);
		      case 26:
		      case 5:
		        recursivelyTraverseReappearLayoutEffects(
		          finishedRoot,
		          finishedWork,
		          includeWorkInProgressEffects
		        );
		        includeWorkInProgressEffects &&
		          null === current &&
		          flags & 4 &&
		          commitHostMount(finishedWork);
		        safelyAttachRef(finishedWork, finishedWork.return);
		        break;
		      case 12:
		        recursivelyTraverseReappearLayoutEffects(
		          finishedRoot,
		          finishedWork,
		          includeWorkInProgressEffects
		        );
		        break;
		      case 13:
		        recursivelyTraverseReappearLayoutEffects(
		          finishedRoot,
		          finishedWork,
		          includeWorkInProgressEffects
		        );
		        includeWorkInProgressEffects &&
		          flags & 4 &&
		          commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
		        break;
		      case 22:
		        null === finishedWork.memoizedState &&
		          recursivelyTraverseReappearLayoutEffects(
		            finishedRoot,
		            finishedWork,
		            includeWorkInProgressEffects
		          );
		        safelyAttachRef(finishedWork, finishedWork.return);
		        break;
		      case 30:
		        break;
		      default:
		        recursivelyTraverseReappearLayoutEffects(
		          finishedRoot,
		          finishedWork,
		          includeWorkInProgressEffects
		        );
		    }
		    parentFiber = parentFiber.sibling;
		  }
		}
		function commitOffscreenPassiveMountEffects(current, finishedWork) {
		  var previousCache = null;
		  null !== current &&
		    null !== current.memoizedState &&
		    null !== current.memoizedState.cachePool &&
		    (previousCache = current.memoizedState.cachePool.pool);
		  current = null;
		  null !== finishedWork.memoizedState &&
		    null !== finishedWork.memoizedState.cachePool &&
		    (current = finishedWork.memoizedState.cachePool.pool);
		  current !== previousCache &&
		    (null != current && current.refCount++,
		    null != previousCache && releaseCache(previousCache));
		}
		function commitCachePassiveMountEffect(current, finishedWork) {
		  current = null;
		  null !== finishedWork.alternate &&
		    (current = finishedWork.alternate.memoizedState.cache);
		  finishedWork = finishedWork.memoizedState.cache;
		  finishedWork !== current &&
		    (finishedWork.refCount++, null != current && releaseCache(current));
		}
		function recursivelyTraversePassiveMountEffects(
		  root,
		  parentFiber,
		  committedLanes,
		  committedTransitions
		) {
		  if (parentFiber.subtreeFlags & 10256)
		    for (parentFiber = parentFiber.child; null !== parentFiber; )
		      commitPassiveMountOnFiber(
		        root,
		        parentFiber,
		        committedLanes,
		        committedTransitions
		      ),
		        (parentFiber = parentFiber.sibling);
		}
		function commitPassiveMountOnFiber(
		  finishedRoot,
		  finishedWork,
		  committedLanes,
		  committedTransitions
		) {
		  var flags = finishedWork.flags;
		  switch (finishedWork.tag) {
		    case 0:
		    case 11:
		    case 15:
		      recursivelyTraversePassiveMountEffects(
		        finishedRoot,
		        finishedWork,
		        committedLanes,
		        committedTransitions
		      );
		      flags & 2048 && commitHookEffectListMount(9, finishedWork);
		      break;
		    case 1:
		      recursivelyTraversePassiveMountEffects(
		        finishedRoot,
		        finishedWork,
		        committedLanes,
		        committedTransitions
		      );
		      break;
		    case 3:
		      recursivelyTraversePassiveMountEffects(
		        finishedRoot,
		        finishedWork,
		        committedLanes,
		        committedTransitions
		      );
		      flags & 2048 &&
		        ((finishedRoot = null),
		        null !== finishedWork.alternate &&
		          (finishedRoot = finishedWork.alternate.memoizedState.cache),
		        (finishedWork = finishedWork.memoizedState.cache),
		        finishedWork !== finishedRoot &&
		          (finishedWork.refCount++,
		          null != finishedRoot && releaseCache(finishedRoot)));
		      break;
		    case 12:
		      if (flags & 2048) {
		        recursivelyTraversePassiveMountEffects(
		          finishedRoot,
		          finishedWork,
		          committedLanes,
		          committedTransitions
		        );
		        finishedRoot = finishedWork.stateNode;
		        try {
		          var _finishedWork$memoize2 = finishedWork.memoizedProps,
		            id = _finishedWork$memoize2.id,
		            onPostCommit = _finishedWork$memoize2.onPostCommit;
		          "function" === typeof onPostCommit &&
		            onPostCommit(
		              id,
		              null === finishedWork.alternate ? "mount" : "update",
		              finishedRoot.passiveEffectDuration,
		              -0
		            );
		        } catch (error) {
		          captureCommitPhaseError(finishedWork, finishedWork.return, error);
		        }
		      } else
		        recursivelyTraversePassiveMountEffects(
		          finishedRoot,
		          finishedWork,
		          committedLanes,
		          committedTransitions
		        );
		      break;
		    case 13:
		      recursivelyTraversePassiveMountEffects(
		        finishedRoot,
		        finishedWork,
		        committedLanes,
		        committedTransitions
		      );
		      break;
		    case 23:
		      break;
		    case 22:
		      _finishedWork$memoize2 = finishedWork.stateNode;
		      id = finishedWork.alternate;
		      null !== finishedWork.memoizedState
		        ? _finishedWork$memoize2._visibility & 2
		          ? recursivelyTraversePassiveMountEffects(
		              finishedRoot,
		              finishedWork,
		              committedLanes,
		              committedTransitions
		            )
		          : recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork)
		        : _finishedWork$memoize2._visibility & 2
		          ? recursivelyTraversePassiveMountEffects(
		              finishedRoot,
		              finishedWork,
		              committedLanes,
		              committedTransitions
		            )
		          : ((_finishedWork$memoize2._visibility |= 2),
		            recursivelyTraverseReconnectPassiveEffects(
		              finishedRoot,
		              finishedWork,
		              committedLanes,
		              committedTransitions,
		              0 !== (finishedWork.subtreeFlags & 10256)
		            ));
		      flags & 2048 && commitOffscreenPassiveMountEffects(id, finishedWork);
		      break;
		    case 24:
		      recursivelyTraversePassiveMountEffects(
		        finishedRoot,
		        finishedWork,
		        committedLanes,
		        committedTransitions
		      );
		      flags & 2048 &&
		        commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
		      break;
		    default:
		      recursivelyTraversePassiveMountEffects(
		        finishedRoot,
		        finishedWork,
		        committedLanes,
		        committedTransitions
		      );
		  }
		}
		function recursivelyTraverseReconnectPassiveEffects(
		  finishedRoot$jscomp$0,
		  parentFiber,
		  committedLanes$jscomp$0,
		  committedTransitions$jscomp$0,
		  includeWorkInProgressEffects
		) {
		  includeWorkInProgressEffects =
		    includeWorkInProgressEffects && 0 !== (parentFiber.subtreeFlags & 10256);
		  for (parentFiber = parentFiber.child; null !== parentFiber; ) {
		    var finishedRoot = finishedRoot$jscomp$0,
		      finishedWork = parentFiber,
		      committedLanes = committedLanes$jscomp$0,
		      committedTransitions = committedTransitions$jscomp$0,
		      flags = finishedWork.flags;
		    switch (finishedWork.tag) {
		      case 0:
		      case 11:
		      case 15:
		        recursivelyTraverseReconnectPassiveEffects(
		          finishedRoot,
		          finishedWork,
		          committedLanes,
		          committedTransitions,
		          includeWorkInProgressEffects
		        );
		        commitHookEffectListMount(8, finishedWork);
		        break;
		      case 23:
		        break;
		      case 22:
		        var instance = finishedWork.stateNode;
		        null !== finishedWork.memoizedState
		          ? instance._visibility & 2
		            ? recursivelyTraverseReconnectPassiveEffects(
		                finishedRoot,
		                finishedWork,
		                committedLanes,
		                committedTransitions,
		                includeWorkInProgressEffects
		              )
		            : recursivelyTraverseAtomicPassiveEffects(
		                finishedRoot,
		                finishedWork
		              )
		          : ((instance._visibility |= 2),
		            recursivelyTraverseReconnectPassiveEffects(
		              finishedRoot,
		              finishedWork,
		              committedLanes,
		              committedTransitions,
		              includeWorkInProgressEffects
		            ));
		        includeWorkInProgressEffects &&
		          flags & 2048 &&
		          commitOffscreenPassiveMountEffects(
		            finishedWork.alternate,
		            finishedWork
		          );
		        break;
		      case 24:
		        recursivelyTraverseReconnectPassiveEffects(
		          finishedRoot,
		          finishedWork,
		          committedLanes,
		          committedTransitions,
		          includeWorkInProgressEffects
		        );
		        includeWorkInProgressEffects &&
		          flags & 2048 &&
		          commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
		        break;
		      default:
		        recursivelyTraverseReconnectPassiveEffects(
		          finishedRoot,
		          finishedWork,
		          committedLanes,
		          committedTransitions,
		          includeWorkInProgressEffects
		        );
		    }
		    parentFiber = parentFiber.sibling;
		  }
		}
		function recursivelyTraverseAtomicPassiveEffects(
		  finishedRoot$jscomp$0,
		  parentFiber
		) {
		  if (parentFiber.subtreeFlags & 10256)
		    for (parentFiber = parentFiber.child; null !== parentFiber; ) {
		      var finishedRoot = finishedRoot$jscomp$0,
		        finishedWork = parentFiber,
		        flags = finishedWork.flags;
		      switch (finishedWork.tag) {
		        case 22:
		          recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);
		          flags & 2048 &&
		            commitOffscreenPassiveMountEffects(
		              finishedWork.alternate,
		              finishedWork
		            );
		          break;
		        case 24:
		          recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);
		          flags & 2048 &&
		            commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
		          break;
		        default:
		          recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);
		      }
		      parentFiber = parentFiber.sibling;
		    }
		}
		var suspenseyCommitFlag = 8192;
		function recursivelyAccumulateSuspenseyCommit(parentFiber) {
		  if (parentFiber.subtreeFlags & suspenseyCommitFlag)
		    for (parentFiber = parentFiber.child; null !== parentFiber; )
		      accumulateSuspenseyCommitOnFiber(parentFiber),
		        (parentFiber = parentFiber.sibling);
		}
		function accumulateSuspenseyCommitOnFiber(fiber) {
		  switch (fiber.tag) {
		    case 26:
		      recursivelyAccumulateSuspenseyCommit(fiber);
		      fiber.flags & suspenseyCommitFlag &&
		        null !== fiber.memoizedState &&
		        suspendResource(
		          currentHoistableRoot,
		          fiber.memoizedState,
		          fiber.memoizedProps
		        );
		      break;
		    case 5:
		      recursivelyAccumulateSuspenseyCommit(fiber);
		      break;
		    case 3:
		    case 4:
		      var previousHoistableRoot = currentHoistableRoot;
		      currentHoistableRoot = getHoistableRoot(fiber.stateNode.containerInfo);
		      recursivelyAccumulateSuspenseyCommit(fiber);
		      currentHoistableRoot = previousHoistableRoot;
		      break;
		    case 22:
		      null === fiber.memoizedState &&
		        ((previousHoistableRoot = fiber.alternate),
		        null !== previousHoistableRoot &&
		        null !== previousHoistableRoot.memoizedState
		          ? ((previousHoistableRoot = suspenseyCommitFlag),
		            (suspenseyCommitFlag = 16777216),
		            recursivelyAccumulateSuspenseyCommit(fiber),
		            (suspenseyCommitFlag = previousHoistableRoot))
		          : recursivelyAccumulateSuspenseyCommit(fiber));
		      break;
		    default:
		      recursivelyAccumulateSuspenseyCommit(fiber);
		  }
		}
		function detachAlternateSiblings(parentFiber) {
		  var previousFiber = parentFiber.alternate;
		  if (
		    null !== previousFiber &&
		    ((parentFiber = previousFiber.child), null !== parentFiber)
		  ) {
		    previousFiber.child = null;
		    do
		      (previousFiber = parentFiber.sibling),
		        (parentFiber.sibling = null),
		        (parentFiber = previousFiber);
		    while (null !== parentFiber);
		  }
		}
		function recursivelyTraversePassiveUnmountEffects(parentFiber) {
		  var deletions = parentFiber.deletions;
		  if (0 !== (parentFiber.flags & 16)) {
		    if (null !== deletions)
		      for (var i = 0; i < deletions.length; i++) {
		        var childToDelete = deletions[i];
		        nextEffect = childToDelete;
		        commitPassiveUnmountEffectsInsideOfDeletedTree_begin(
		          childToDelete,
		          parentFiber
		        );
		      }
		    detachAlternateSiblings(parentFiber);
		  }
		  if (parentFiber.subtreeFlags & 10256)
		    for (parentFiber = parentFiber.child; null !== parentFiber; )
		      commitPassiveUnmountOnFiber(parentFiber),
		        (parentFiber = parentFiber.sibling);
		}
		function commitPassiveUnmountOnFiber(finishedWork) {
		  switch (finishedWork.tag) {
		    case 0:
		    case 11:
		    case 15:
		      recursivelyTraversePassiveUnmountEffects(finishedWork);
		      finishedWork.flags & 2048 &&
		        commitHookEffectListUnmount(9, finishedWork, finishedWork.return);
		      break;
		    case 3:
		      recursivelyTraversePassiveUnmountEffects(finishedWork);
		      break;
		    case 12:
		      recursivelyTraversePassiveUnmountEffects(finishedWork);
		      break;
		    case 22:
		      var instance = finishedWork.stateNode;
		      null !== finishedWork.memoizedState &&
		      instance._visibility & 2 &&
		      (null === finishedWork.return || 13 !== finishedWork.return.tag)
		        ? ((instance._visibility &= -3),
		          recursivelyTraverseDisconnectPassiveEffects(finishedWork))
		        : recursivelyTraversePassiveUnmountEffects(finishedWork);
		      break;
		    default:
		      recursivelyTraversePassiveUnmountEffects(finishedWork);
		  }
		}
		function recursivelyTraverseDisconnectPassiveEffects(parentFiber) {
		  var deletions = parentFiber.deletions;
		  if (0 !== (parentFiber.flags & 16)) {
		    if (null !== deletions)
		      for (var i = 0; i < deletions.length; i++) {
		        var childToDelete = deletions[i];
		        nextEffect = childToDelete;
		        commitPassiveUnmountEffectsInsideOfDeletedTree_begin(
		          childToDelete,
		          parentFiber
		        );
		      }
		    detachAlternateSiblings(parentFiber);
		  }
		  for (parentFiber = parentFiber.child; null !== parentFiber; ) {
		    deletions = parentFiber;
		    switch (deletions.tag) {
		      case 0:
		      case 11:
		      case 15:
		        commitHookEffectListUnmount(8, deletions, deletions.return);
		        recursivelyTraverseDisconnectPassiveEffects(deletions);
		        break;
		      case 22:
		        i = deletions.stateNode;
		        i._visibility & 2 &&
		          ((i._visibility &= -3),
		          recursivelyTraverseDisconnectPassiveEffects(deletions));
		        break;
		      default:
		        recursivelyTraverseDisconnectPassiveEffects(deletions);
		    }
		    parentFiber = parentFiber.sibling;
		  }
		}
		function commitPassiveUnmountEffectsInsideOfDeletedTree_begin(
		  deletedSubtreeRoot,
		  nearestMountedAncestor
		) {
		  for (; null !== nextEffect; ) {
		    var fiber = nextEffect;
		    switch (fiber.tag) {
		      case 0:
		      case 11:
		      case 15:
		        commitHookEffectListUnmount(8, fiber, nearestMountedAncestor);
		        break;
		      case 23:
		      case 22:
		        if (
		          null !== fiber.memoizedState &&
		          null !== fiber.memoizedState.cachePool
		        ) {
		          var cache = fiber.memoizedState.cachePool.pool;
		          null != cache && cache.refCount++;
		        }
		        break;
		      case 24:
		        releaseCache(fiber.memoizedState.cache);
		    }
		    cache = fiber.child;
		    if (null !== cache) (cache.return = fiber), (nextEffect = cache);
		    else
		      a: for (fiber = deletedSubtreeRoot; null !== nextEffect; ) {
		        cache = nextEffect;
		        var sibling = cache.sibling,
		          returnFiber = cache.return;
		        detachFiberAfterEffects(cache);
		        if (cache === fiber) {
		          nextEffect = null;
		          break a;
		        }
		        if (null !== sibling) {
		          sibling.return = returnFiber;
		          nextEffect = sibling;
		          break a;
		        }
		        nextEffect = returnFiber;
		      }
		  }
		}
		var DefaultAsyncDispatcher = {
		    getCacheForType: function (resourceType) {
		      var cache = readContext(CacheContext),
		        cacheForType = cache.data.get(resourceType);
		      void 0 === cacheForType &&
		        ((cacheForType = resourceType()),
		        cache.data.set(resourceType, cacheForType));
		      return cacheForType;
		    }
		  },
		  PossiblyWeakMap = "function" === typeof WeakMap ? WeakMap : Map,
		  executionContext = 0,
		  workInProgressRoot = null,
		  workInProgress = null,
		  workInProgressRootRenderLanes = 0,
		  workInProgressSuspendedReason = 0,
		  workInProgressThrownValue = null,
		  workInProgressRootDidSkipSuspendedSiblings = false,
		  workInProgressRootIsPrerendering = false,
		  workInProgressRootDidAttachPingListener = false,
		  entangledRenderLanes = 0,
		  workInProgressRootExitStatus = 0,
		  workInProgressRootSkippedLanes = 0,
		  workInProgressRootInterleavedUpdatedLanes = 0,
		  workInProgressRootPingedLanes = 0,
		  workInProgressDeferredLane = 0,
		  workInProgressSuspendedRetryLanes = 0,
		  workInProgressRootConcurrentErrors = null,
		  workInProgressRootRecoverableErrors = null,
		  workInProgressRootDidIncludeRecursiveRenderUpdate = false,
		  globalMostRecentFallbackTime = 0,
		  workInProgressRootRenderTargetTime = Infinity,
		  workInProgressTransitions = null,
		  legacyErrorBoundariesThatAlreadyFailed = null,
		  pendingEffectsStatus = 0,
		  pendingEffectsRoot = null,
		  pendingFinishedWork = null,
		  pendingEffectsLanes = 0,
		  pendingEffectsRemainingLanes = 0,
		  pendingPassiveTransitions = null,
		  pendingRecoverableErrors = null,
		  nestedUpdateCount = 0,
		  rootWithNestedUpdates = null;
		function requestUpdateLane() {
		  if (0 !== (executionContext & 2) && 0 !== workInProgressRootRenderLanes)
		    return workInProgressRootRenderLanes & -workInProgressRootRenderLanes;
		  if (null !== ReactSharedInternals.T) {
		    var actionScopeLane = currentEntangledLane;
		    return 0 !== actionScopeLane ? actionScopeLane : requestTransitionLane();
		  }
		  return resolveUpdatePriority();
		}
		function requestDeferredLane() {
		  0 === workInProgressDeferredLane &&
		    (workInProgressDeferredLane =
		      0 === (workInProgressRootRenderLanes & 536870912) || isHydrating
		        ? claimNextTransitionLane()
		        : 536870912);
		  var suspenseHandler = suspenseHandlerStackCursor.current;
		  null !== suspenseHandler && (suspenseHandler.flags |= 32);
		  return workInProgressDeferredLane;
		}
		function scheduleUpdateOnFiber(root, fiber, lane) {
		  if (
		    (root === workInProgressRoot &&
		      (2 === workInProgressSuspendedReason ||
		        9 === workInProgressSuspendedReason)) ||
		    null !== root.cancelPendingCommit
		  )
		    prepareFreshStack(root, 0),
		      markRootSuspended(
		        root,
		        workInProgressRootRenderLanes,
		        workInProgressDeferredLane,
		        false
		      );
		  markRootUpdated$1(root, lane);
		  if (0 === (executionContext & 2) || root !== workInProgressRoot)
		    root === workInProgressRoot &&
		      (0 === (executionContext & 2) &&
		        (workInProgressRootInterleavedUpdatedLanes |= lane),
		      4 === workInProgressRootExitStatus &&
		        markRootSuspended(
		          root,
		          workInProgressRootRenderLanes,
		          workInProgressDeferredLane,
		          false
		        )),
		      ensureRootIsScheduled(root);
		}
		function performWorkOnRoot(root$jscomp$0, lanes, forceSync) {
		  if (0 !== (executionContext & 6)) throw Error(formatProdErrorMessage(327));
		  var shouldTimeSlice =
		      (!forceSync &&
		        0 === (lanes & 124) &&
		        0 === (lanes & root$jscomp$0.expiredLanes)) ||
		      checkIfRootIsPrerendering(root$jscomp$0, lanes),
		    exitStatus = shouldTimeSlice
		      ? renderRootConcurrent(root$jscomp$0, lanes)
		      : renderRootSync(root$jscomp$0, lanes, true),
		    renderWasConcurrent = shouldTimeSlice;
		  do {
		    if (0 === exitStatus) {
		      workInProgressRootIsPrerendering &&
		        !shouldTimeSlice &&
		        markRootSuspended(root$jscomp$0, lanes, 0, false);
		      break;
		    } else {
		      forceSync = root$jscomp$0.current.alternate;
		      if (
		        renderWasConcurrent &&
		        !isRenderConsistentWithExternalStores(forceSync)
		      ) {
		        exitStatus = renderRootSync(root$jscomp$0, lanes, false);
		        renderWasConcurrent = false;
		        continue;
		      }
		      if (2 === exitStatus) {
		        renderWasConcurrent = lanes;
		        if (root$jscomp$0.errorRecoveryDisabledLanes & renderWasConcurrent)
		          var JSCompiler_inline_result = 0;
		        else
		          (JSCompiler_inline_result = root$jscomp$0.pendingLanes & -536870913),
		            (JSCompiler_inline_result =
		              0 !== JSCompiler_inline_result
		                ? JSCompiler_inline_result
		                : JSCompiler_inline_result & 536870912
		                  ? 536870912
		                  : 0);
		        if (0 !== JSCompiler_inline_result) {
		          lanes = JSCompiler_inline_result;
		          a: {
		            var root = root$jscomp$0;
		            exitStatus = workInProgressRootConcurrentErrors;
		            var wasRootDehydrated = root.current.memoizedState.isDehydrated;
		            wasRootDehydrated &&
		              (prepareFreshStack(root, JSCompiler_inline_result).flags |= 256);
		            JSCompiler_inline_result = renderRootSync(
		              root,
		              JSCompiler_inline_result,
		              false
		            );
		            if (2 !== JSCompiler_inline_result) {
		              if (
		                workInProgressRootDidAttachPingListener &&
		                !wasRootDehydrated
		              ) {
		                root.errorRecoveryDisabledLanes |= renderWasConcurrent;
		                workInProgressRootInterleavedUpdatedLanes |=
		                  renderWasConcurrent;
		                exitStatus = 4;
		                break a;
		              }
		              renderWasConcurrent = workInProgressRootRecoverableErrors;
		              workInProgressRootRecoverableErrors = exitStatus;
		              null !== renderWasConcurrent &&
		                (null === workInProgressRootRecoverableErrors
		                  ? (workInProgressRootRecoverableErrors = renderWasConcurrent)
		                  : workInProgressRootRecoverableErrors.push.apply(
		                      workInProgressRootRecoverableErrors,
		                      renderWasConcurrent
		                    ));
		            }
		            exitStatus = JSCompiler_inline_result;
		          }
		          renderWasConcurrent = false;
		          if (2 !== exitStatus) continue;
		        }
		      }
		      if (1 === exitStatus) {
		        prepareFreshStack(root$jscomp$0, 0);
		        markRootSuspended(root$jscomp$0, lanes, 0, true);
		        break;
		      }
		      a: {
		        shouldTimeSlice = root$jscomp$0;
		        renderWasConcurrent = exitStatus;
		        switch (renderWasConcurrent) {
		          case 0:
		          case 1:
		            throw Error(formatProdErrorMessage(345));
		          case 4:
		            if ((lanes & 4194048) !== lanes) break;
		          case 6:
		            markRootSuspended(
		              shouldTimeSlice,
		              lanes,
		              workInProgressDeferredLane,
		              !workInProgressRootDidSkipSuspendedSiblings
		            );
		            break a;
		          case 2:
		            workInProgressRootRecoverableErrors = null;
		            break;
		          case 3:
		          case 5:
		            break;
		          default:
		            throw Error(formatProdErrorMessage(329));
		        }
		        if (
		          (lanes & 62914560) === lanes &&
		          ((exitStatus = globalMostRecentFallbackTime + 300 - now()),
		          10 < exitStatus)
		        ) {
		          markRootSuspended(
		            shouldTimeSlice,
		            lanes,
		            workInProgressDeferredLane,
		            !workInProgressRootDidSkipSuspendedSiblings
		          );
		          if (0 !== getNextLanes(shouldTimeSlice, 0, true)) break a;
		          shouldTimeSlice.timeoutHandle = scheduleTimeout(
		            commitRootWhenReady.bind(
		              null,
		              shouldTimeSlice,
		              forceSync,
		              workInProgressRootRecoverableErrors,
		              workInProgressTransitions,
		              workInProgressRootDidIncludeRecursiveRenderUpdate,
		              lanes,
		              workInProgressDeferredLane,
		              workInProgressRootInterleavedUpdatedLanes,
		              workInProgressSuspendedRetryLanes,
		              workInProgressRootDidSkipSuspendedSiblings,
		              renderWasConcurrent,
		              2,
		              -0,
		              0
		            ),
		            exitStatus
		          );
		          break a;
		        }
		        commitRootWhenReady(
		          shouldTimeSlice,
		          forceSync,
		          workInProgressRootRecoverableErrors,
		          workInProgressTransitions,
		          workInProgressRootDidIncludeRecursiveRenderUpdate,
		          lanes,
		          workInProgressDeferredLane,
		          workInProgressRootInterleavedUpdatedLanes,
		          workInProgressSuspendedRetryLanes,
		          workInProgressRootDidSkipSuspendedSiblings,
		          renderWasConcurrent,
		          0,
		          -0,
		          0
		        );
		      }
		    }
		    break;
		  } while (1);
		  ensureRootIsScheduled(root$jscomp$0);
		}
		function commitRootWhenReady(
		  root,
		  finishedWork,
		  recoverableErrors,
		  transitions,
		  didIncludeRenderPhaseUpdate,
		  lanes,
		  spawnedLane,
		  updatedLanes,
		  suspendedRetryLanes,
		  didSkipSuspendedSiblings,
		  exitStatus,
		  suspendedCommitReason,
		  completedRenderStartTime,
		  completedRenderEndTime
		) {
		  root.timeoutHandle = -1;
		  suspendedCommitReason = finishedWork.subtreeFlags;
		  if (
		    suspendedCommitReason & 8192 ||
		    16785408 === (suspendedCommitReason & 16785408)
		  )
		    if (
		      ((suspendedState = { stylesheets: null, count: 0, unsuspend: noop }),
		      accumulateSuspenseyCommitOnFiber(finishedWork),
		      (suspendedCommitReason = waitForCommitToBeReady()),
		      null !== suspendedCommitReason)
		    ) {
		      root.cancelPendingCommit = suspendedCommitReason(
		        commitRoot.bind(
		          null,
		          root,
		          finishedWork,
		          lanes,
		          recoverableErrors,
		          transitions,
		          didIncludeRenderPhaseUpdate,
		          spawnedLane,
		          updatedLanes,
		          suspendedRetryLanes,
		          exitStatus,
		          1,
		          completedRenderStartTime,
		          completedRenderEndTime
		        )
		      );
		      markRootSuspended(root, lanes, spawnedLane, !didSkipSuspendedSiblings);
		      return;
		    }
		  commitRoot(
		    root,
		    finishedWork,
		    lanes,
		    recoverableErrors,
		    transitions,
		    didIncludeRenderPhaseUpdate,
		    spawnedLane,
		    updatedLanes,
		    suspendedRetryLanes
		  );
		}
		function isRenderConsistentWithExternalStores(finishedWork) {
		  for (var node = finishedWork; ; ) {
		    var tag = node.tag;
		    if (
		      (0 === tag || 11 === tag || 15 === tag) &&
		      node.flags & 16384 &&
		      ((tag = node.updateQueue),
		      null !== tag && ((tag = tag.stores), null !== tag))
		    )
		      for (var i = 0; i < tag.length; i++) {
		        var check = tag[i],
		          getSnapshot = check.getSnapshot;
		        check = check.value;
		        try {
		          if (!objectIs(getSnapshot(), check)) return !1;
		        } catch (error) {
		          return false;
		        }
		      }
		    tag = node.child;
		    if (node.subtreeFlags & 16384 && null !== tag)
		      (tag.return = node), (node = tag);
		    else {
		      if (node === finishedWork) break;
		      for (; null === node.sibling; ) {
		        if (null === node.return || node.return === finishedWork) return true;
		        node = node.return;
		      }
		      node.sibling.return = node.return;
		      node = node.sibling;
		    }
		  }
		  return true;
		}
		function markRootSuspended(
		  root,
		  suspendedLanes,
		  spawnedLane,
		  didAttemptEntireTree
		) {
		  suspendedLanes &= ~workInProgressRootPingedLanes;
		  suspendedLanes &= ~workInProgressRootInterleavedUpdatedLanes;
		  root.suspendedLanes |= suspendedLanes;
		  root.pingedLanes &= ~suspendedLanes;
		  didAttemptEntireTree && (root.warmLanes |= suspendedLanes);
		  didAttemptEntireTree = root.expirationTimes;
		  for (var lanes = suspendedLanes; 0 < lanes; ) {
		    var index$4 = 31 - clz32(lanes),
		      lane = 1 << index$4;
		    didAttemptEntireTree[index$4] = -1;
		    lanes &= ~lane;
		  }
		  0 !== spawnedLane &&
		    markSpawnedDeferredLane(root, spawnedLane, suspendedLanes);
		}
		function flushSyncWork$1() {
		  return 0 === (executionContext & 6)
		    ? (flushSyncWorkAcrossRoots_impl(0), false)
		    : true;
		}
		function resetWorkInProgressStack() {
		  if (null !== workInProgress) {
		    if (0 === workInProgressSuspendedReason)
		      var interruptedWork = workInProgress.return;
		    else
		      (interruptedWork = workInProgress),
		        (lastContextDependency = currentlyRenderingFiber$1 = null),
		        resetHooksOnUnwind(interruptedWork),
		        (thenableState = null),
		        (thenableIndexCounter = 0),
		        (interruptedWork = workInProgress);
		    for (; null !== interruptedWork; )
		      unwindInterruptedWork(interruptedWork.alternate, interruptedWork),
		        (interruptedWork = interruptedWork.return);
		    workInProgress = null;
		  }
		}
		function prepareFreshStack(root, lanes) {
		  var timeoutHandle = root.timeoutHandle;
		  -1 !== timeoutHandle &&
		    ((root.timeoutHandle = -1), cancelTimeout(timeoutHandle));
		  timeoutHandle = root.cancelPendingCommit;
		  null !== timeoutHandle &&
		    ((root.cancelPendingCommit = null), timeoutHandle());
		  resetWorkInProgressStack();
		  workInProgressRoot = root;
		  workInProgress = timeoutHandle = createWorkInProgress(root.current, null);
		  workInProgressRootRenderLanes = lanes;
		  workInProgressSuspendedReason = 0;
		  workInProgressThrownValue = null;
		  workInProgressRootDidSkipSuspendedSiblings = false;
		  workInProgressRootIsPrerendering = checkIfRootIsPrerendering(root, lanes);
		  workInProgressRootDidAttachPingListener = false;
		  workInProgressSuspendedRetryLanes =
		    workInProgressDeferredLane =
		    workInProgressRootPingedLanes =
		    workInProgressRootInterleavedUpdatedLanes =
		    workInProgressRootSkippedLanes =
		    workInProgressRootExitStatus =
		      0;
		  workInProgressRootRecoverableErrors = workInProgressRootConcurrentErrors =
		    null;
		  workInProgressRootDidIncludeRecursiveRenderUpdate = false;
		  0 !== (lanes & 8) && (lanes |= lanes & 32);
		  var allEntangledLanes = root.entangledLanes;
		  if (0 !== allEntangledLanes)
		    for (
		      root = root.entanglements, allEntangledLanes &= lanes;
		      0 < allEntangledLanes;

		    ) {
		      var index$2 = 31 - clz32(allEntangledLanes),
		        lane = 1 << index$2;
		      lanes |= root[index$2];
		      allEntangledLanes &= ~lane;
		    }
		  entangledRenderLanes = lanes;
		  finishQueueingConcurrentUpdates();
		  return timeoutHandle;
		}
		function handleThrow(root, thrownValue) {
		  currentlyRenderingFiber = null;
		  ReactSharedInternals.H = ContextOnlyDispatcher;
		  thrownValue === SuspenseException || thrownValue === SuspenseActionException
		    ? ((thrownValue = getSuspendedThenable()),
		      (workInProgressSuspendedReason = 3))
		    : thrownValue === SuspenseyCommitException
		      ? ((thrownValue = getSuspendedThenable()),
		        (workInProgressSuspendedReason = 4))
		      : (workInProgressSuspendedReason =
		          thrownValue === SelectiveHydrationException
		            ? 8
		            : null !== thrownValue &&
		                "object" === typeof thrownValue &&
		                "function" === typeof thrownValue.then
		              ? 6
		              : 1);
		  workInProgressThrownValue = thrownValue;
		  null === workInProgress &&
		    ((workInProgressRootExitStatus = 1),
		    logUncaughtError(
		      root,
		      createCapturedValueAtFiber(thrownValue, root.current)
		    ));
		}
		function pushDispatcher() {
		  var prevDispatcher = ReactSharedInternals.H;
		  ReactSharedInternals.H = ContextOnlyDispatcher;
		  return null === prevDispatcher ? ContextOnlyDispatcher : prevDispatcher;
		}
		function pushAsyncDispatcher() {
		  var prevAsyncDispatcher = ReactSharedInternals.A;
		  ReactSharedInternals.A = DefaultAsyncDispatcher;
		  return prevAsyncDispatcher;
		}
		function renderDidSuspendDelayIfPossible() {
		  workInProgressRootExitStatus = 4;
		  workInProgressRootDidSkipSuspendedSiblings ||
		    ((workInProgressRootRenderLanes & 4194048) !==
		      workInProgressRootRenderLanes &&
		      null !== suspenseHandlerStackCursor.current) ||
		    (workInProgressRootIsPrerendering = true);
		  (0 === (workInProgressRootSkippedLanes & 134217727) &&
		    0 === (workInProgressRootInterleavedUpdatedLanes & 134217727)) ||
		    null === workInProgressRoot ||
		    markRootSuspended(
		      workInProgressRoot,
		      workInProgressRootRenderLanes,
		      workInProgressDeferredLane,
		      false
		    );
		}
		function renderRootSync(root, lanes, shouldYieldForPrerendering) {
		  var prevExecutionContext = executionContext;
		  executionContext |= 2;
		  var prevDispatcher = pushDispatcher(),
		    prevAsyncDispatcher = pushAsyncDispatcher();
		  if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes)
		    (workInProgressTransitions = null), prepareFreshStack(root, lanes);
		  lanes = false;
		  var exitStatus = workInProgressRootExitStatus;
		  a: do
		    try {
		      if (0 !== workInProgressSuspendedReason && null !== workInProgress) {
		        var unitOfWork = workInProgress,
		          thrownValue = workInProgressThrownValue;
		        switch (workInProgressSuspendedReason) {
		          case 8:
		            resetWorkInProgressStack();
		            exitStatus = 6;
		            break a;
		          case 3:
		          case 2:
		          case 9:
		          case 6:
		            null === suspenseHandlerStackCursor.current && (lanes = !0);
		            var reason = workInProgressSuspendedReason;
		            workInProgressSuspendedReason = 0;
		            workInProgressThrownValue = null;
		            throwAndUnwindWorkLoop(root, unitOfWork, thrownValue, reason);
		            if (
		              shouldYieldForPrerendering &&
		              workInProgressRootIsPrerendering
		            ) {
		              exitStatus = 0;
		              break a;
		            }
		            break;
		          default:
		            (reason = workInProgressSuspendedReason),
		              (workInProgressSuspendedReason = 0),
		              (workInProgressThrownValue = null),
		              throwAndUnwindWorkLoop(root, unitOfWork, thrownValue, reason);
		        }
		      }
		      workLoopSync();
		      exitStatus = workInProgressRootExitStatus;
		      break;
		    } catch (thrownValue$167) {
		      handleThrow(root, thrownValue$167);
		    }
		  while (1);
		  lanes && root.shellSuspendCounter++;
		  lastContextDependency = currentlyRenderingFiber$1 = null;
		  executionContext = prevExecutionContext;
		  ReactSharedInternals.H = prevDispatcher;
		  ReactSharedInternals.A = prevAsyncDispatcher;
		  null === workInProgress &&
		    ((workInProgressRoot = null),
		    (workInProgressRootRenderLanes = 0),
		    finishQueueingConcurrentUpdates());
		  return exitStatus;
		}
		function workLoopSync() {
		  for (; null !== workInProgress; ) performUnitOfWork(workInProgress);
		}
		function renderRootConcurrent(root, lanes) {
		  var prevExecutionContext = executionContext;
		  executionContext |= 2;
		  var prevDispatcher = pushDispatcher(),
		    prevAsyncDispatcher = pushAsyncDispatcher();
		  workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes
		    ? ((workInProgressTransitions = null),
		      (workInProgressRootRenderTargetTime = now() + 500),
		      prepareFreshStack(root, lanes))
		    : (workInProgressRootIsPrerendering = checkIfRootIsPrerendering(
		        root,
		        lanes
		      ));
		  a: do
		    try {
		      if (0 !== workInProgressSuspendedReason && null !== workInProgress) {
		        lanes = workInProgress;
		        var thrownValue = workInProgressThrownValue;
		        b: switch (workInProgressSuspendedReason) {
		          case 1:
		            workInProgressSuspendedReason = 0;
		            workInProgressThrownValue = null;
		            throwAndUnwindWorkLoop(root, lanes, thrownValue, 1);
		            break;
		          case 2:
		          case 9:
		            if (isThenableResolved(thrownValue)) {
		              workInProgressSuspendedReason = 0;
		              workInProgressThrownValue = null;
		              replaySuspendedUnitOfWork(lanes);
		              break;
		            }
		            lanes = function () {
		              (2 !== workInProgressSuspendedReason &&
		                9 !== workInProgressSuspendedReason) ||
		                workInProgressRoot !== root ||
		                (workInProgressSuspendedReason = 7);
		              ensureRootIsScheduled(root);
		            };
		            thrownValue.then(lanes, lanes);
		            break a;
		          case 3:
		            workInProgressSuspendedReason = 7;
		            break a;
		          case 4:
		            workInProgressSuspendedReason = 5;
		            break a;
		          case 7:
		            isThenableResolved(thrownValue)
		              ? ((workInProgressSuspendedReason = 0),
		                (workInProgressThrownValue = null),
		                replaySuspendedUnitOfWork(lanes))
		              : ((workInProgressSuspendedReason = 0),
		                (workInProgressThrownValue = null),
		                throwAndUnwindWorkLoop(root, lanes, thrownValue, 7));
		            break;
		          case 5:
		            var resource = null;
		            switch (workInProgress.tag) {
		              case 26:
		                resource = workInProgress.memoizedState;
		              case 5:
		              case 27:
		                var hostFiber = workInProgress;
		                if (resource ? preloadResource(resource) : 1) {
		                  workInProgressSuspendedReason = 0;
		                  workInProgressThrownValue = null;
		                  var sibling = hostFiber.sibling;
		                  if (null !== sibling) workInProgress = sibling;
		                  else {
		                    var returnFiber = hostFiber.return;
		                    null !== returnFiber
		                      ? ((workInProgress = returnFiber),
		                        completeUnitOfWork(returnFiber))
		                      : (workInProgress = null);
		                  }
		                  break b;
		                }
		            }
		            workInProgressSuspendedReason = 0;
		            workInProgressThrownValue = null;
		            throwAndUnwindWorkLoop(root, lanes, thrownValue, 5);
		            break;
		          case 6:
		            workInProgressSuspendedReason = 0;
		            workInProgressThrownValue = null;
		            throwAndUnwindWorkLoop(root, lanes, thrownValue, 6);
		            break;
		          case 8:
		            resetWorkInProgressStack();
		            workInProgressRootExitStatus = 6;
		            break a;
		          default:
		            throw Error(formatProdErrorMessage(462));
		        }
		      }
		      workLoopConcurrentByScheduler();
		      break;
		    } catch (thrownValue$169) {
		      handleThrow(root, thrownValue$169);
		    }
		  while (1);
		  lastContextDependency = currentlyRenderingFiber$1 = null;
		  ReactSharedInternals.H = prevDispatcher;
		  ReactSharedInternals.A = prevAsyncDispatcher;
		  executionContext = prevExecutionContext;
		  if (null !== workInProgress) return 0;
		  workInProgressRoot = null;
		  workInProgressRootRenderLanes = 0;
		  finishQueueingConcurrentUpdates();
		  return workInProgressRootExitStatus;
		}
		function workLoopConcurrentByScheduler() {
		  for (; null !== workInProgress && !shouldYield(); )
		    performUnitOfWork(workInProgress);
		}
		function performUnitOfWork(unitOfWork) {
		  var next = beginWork(unitOfWork.alternate, unitOfWork, entangledRenderLanes);
		  unitOfWork.memoizedProps = unitOfWork.pendingProps;
		  null === next ? completeUnitOfWork(unitOfWork) : (workInProgress = next);
		}
		function replaySuspendedUnitOfWork(unitOfWork) {
		  var next = unitOfWork;
		  var current = next.alternate;
		  switch (next.tag) {
		    case 15:
		    case 0:
		      next = replayFunctionComponent(
		        current,
		        next,
		        next.pendingProps,
		        next.type,
		        void 0,
		        workInProgressRootRenderLanes
		      );
		      break;
		    case 11:
		      next = replayFunctionComponent(
		        current,
		        next,
		        next.pendingProps,
		        next.type.render,
		        next.ref,
		        workInProgressRootRenderLanes
		      );
		      break;
		    case 5:
		      resetHooksOnUnwind(next);
		    default:
		      unwindInterruptedWork(current, next),
		        (next = workInProgress =
		          resetWorkInProgress(next, entangledRenderLanes)),
		        (next = beginWork(current, next, entangledRenderLanes));
		  }
		  unitOfWork.memoizedProps = unitOfWork.pendingProps;
		  null === next ? completeUnitOfWork(unitOfWork) : (workInProgress = next);
		}
		function throwAndUnwindWorkLoop(
		  root,
		  unitOfWork,
		  thrownValue,
		  suspendedReason
		) {
		  lastContextDependency = currentlyRenderingFiber$1 = null;
		  resetHooksOnUnwind(unitOfWork);
		  thenableState = null;
		  thenableIndexCounter = 0;
		  var returnFiber = unitOfWork.return;
		  try {
		    if (
		      throwException(
		        root,
		        returnFiber,
		        unitOfWork,
		        thrownValue,
		        workInProgressRootRenderLanes
		      )
		    ) {
		      workInProgressRootExitStatus = 1;
		      logUncaughtError(
		        root,
		        createCapturedValueAtFiber(thrownValue, root.current)
		      );
		      workInProgress = null;
		      return;
		    }
		  } catch (error) {
		    if (null !== returnFiber) throw ((workInProgress = returnFiber), error);
		    workInProgressRootExitStatus = 1;
		    logUncaughtError(
		      root,
		      createCapturedValueAtFiber(thrownValue, root.current)
		    );
		    workInProgress = null;
		    return;
		  }
		  if (unitOfWork.flags & 32768) {
		    if (isHydrating || 1 === suspendedReason) root = true;
		    else if (
		      workInProgressRootIsPrerendering ||
		      0 !== (workInProgressRootRenderLanes & 536870912)
		    )
		      root = false;
		    else if (
		      ((workInProgressRootDidSkipSuspendedSiblings = root = true),
		      2 === suspendedReason ||
		        9 === suspendedReason ||
		        3 === suspendedReason ||
		        6 === suspendedReason)
		    )
		      (suspendedReason = suspenseHandlerStackCursor.current),
		        null !== suspendedReason &&
		          13 === suspendedReason.tag &&
		          (suspendedReason.flags |= 16384);
		    unwindUnitOfWork(unitOfWork, root);
		  } else completeUnitOfWork(unitOfWork);
		}
		function completeUnitOfWork(unitOfWork) {
		  var completedWork = unitOfWork;
		  do {
		    if (0 !== (completedWork.flags & 32768)) {
		      unwindUnitOfWork(
		        completedWork,
		        workInProgressRootDidSkipSuspendedSiblings
		      );
		      return;
		    }
		    unitOfWork = completedWork.return;
		    var next = completeWork(
		      completedWork.alternate,
		      completedWork,
		      entangledRenderLanes
		    );
		    if (null !== next) {
		      workInProgress = next;
		      return;
		    }
		    completedWork = completedWork.sibling;
		    if (null !== completedWork) {
		      workInProgress = completedWork;
		      return;
		    }
		    workInProgress = completedWork = unitOfWork;
		  } while (null !== completedWork);
		  0 === workInProgressRootExitStatus && (workInProgressRootExitStatus = 5);
		}
		function unwindUnitOfWork(unitOfWork, skipSiblings) {
		  do {
		    var next = unwindWork(unitOfWork.alternate, unitOfWork);
		    if (null !== next) {
		      next.flags &= 32767;
		      workInProgress = next;
		      return;
		    }
		    next = unitOfWork.return;
		    null !== next &&
		      ((next.flags |= 32768), (next.subtreeFlags = 0), (next.deletions = null));
		    if (
		      !skipSiblings &&
		      ((unitOfWork = unitOfWork.sibling), null !== unitOfWork)
		    ) {
		      workInProgress = unitOfWork;
		      return;
		    }
		    workInProgress = unitOfWork = next;
		  } while (null !== unitOfWork);
		  workInProgressRootExitStatus = 6;
		  workInProgress = null;
		}
		function commitRoot(
		  root,
		  finishedWork,
		  lanes,
		  recoverableErrors,
		  transitions,
		  didIncludeRenderPhaseUpdate,
		  spawnedLane,
		  updatedLanes,
		  suspendedRetryLanes
		) {
		  root.cancelPendingCommit = null;
		  do flushPendingEffects();
		  while (0 !== pendingEffectsStatus);
		  if (0 !== (executionContext & 6)) throw Error(formatProdErrorMessage(327));
		  if (null !== finishedWork) {
		    if (finishedWork === root.current) throw Error(formatProdErrorMessage(177));
		    didIncludeRenderPhaseUpdate = finishedWork.lanes | finishedWork.childLanes;
		    didIncludeRenderPhaseUpdate |= concurrentlyUpdatedLanes;
		    markRootFinished(
		      root,
		      lanes,
		      didIncludeRenderPhaseUpdate,
		      spawnedLane,
		      updatedLanes,
		      suspendedRetryLanes
		    );
		    root === workInProgressRoot &&
		      ((workInProgress = workInProgressRoot = null),
		      (workInProgressRootRenderLanes = 0));
		    pendingFinishedWork = finishedWork;
		    pendingEffectsRoot = root;
		    pendingEffectsLanes = lanes;
		    pendingEffectsRemainingLanes = didIncludeRenderPhaseUpdate;
		    pendingPassiveTransitions = transitions;
		    pendingRecoverableErrors = recoverableErrors;
		    0 !== (finishedWork.subtreeFlags & 10256) ||
		    0 !== (finishedWork.flags & 10256)
		      ? ((root.callbackNode = null),
		        (root.callbackPriority = 0),
		        scheduleCallback$1(NormalPriority$1, function () {
		          flushPassiveEffects();
		          return null;
		        }))
		      : ((root.callbackNode = null), (root.callbackPriority = 0));
		    recoverableErrors = 0 !== (finishedWork.flags & 13878);
		    if (0 !== (finishedWork.subtreeFlags & 13878) || recoverableErrors) {
		      recoverableErrors = ReactSharedInternals.T;
		      ReactSharedInternals.T = null;
		      transitions = ReactDOMSharedInternals.p;
		      ReactDOMSharedInternals.p = 2;
		      spawnedLane = executionContext;
		      executionContext |= 4;
		      try {
		        commitBeforeMutationEffects(root, finishedWork, lanes);
		      } finally {
		        (executionContext = spawnedLane),
		          (ReactDOMSharedInternals.p = transitions),
		          (ReactSharedInternals.T = recoverableErrors);
		      }
		    }
		    pendingEffectsStatus = 1;
		    flushMutationEffects();
		    flushLayoutEffects();
		    flushSpawnedWork();
		  }
		}
		function flushMutationEffects() {
		  if (1 === pendingEffectsStatus) {
		    pendingEffectsStatus = 0;
		    var root = pendingEffectsRoot,
		      finishedWork = pendingFinishedWork,
		      rootMutationHasEffect = 0 !== (finishedWork.flags & 13878);
		    if (0 !== (finishedWork.subtreeFlags & 13878) || rootMutationHasEffect) {
		      rootMutationHasEffect = ReactSharedInternals.T;
		      ReactSharedInternals.T = null;
		      var previousPriority = ReactDOMSharedInternals.p;
		      ReactDOMSharedInternals.p = 2;
		      var prevExecutionContext = executionContext;
		      executionContext |= 4;
		      try {
		        commitMutationEffectsOnFiber(finishedWork, root);
		        var priorSelectionInformation = selectionInformation,
		          curFocusedElem = getActiveElementDeep(root.containerInfo),
		          priorFocusedElem = priorSelectionInformation.focusedElem,
		          priorSelectionRange = priorSelectionInformation.selectionRange;
		        if (
		          curFocusedElem !== priorFocusedElem &&
		          priorFocusedElem &&
		          priorFocusedElem.ownerDocument &&
		          containsNode(
		            priorFocusedElem.ownerDocument.documentElement,
		            priorFocusedElem
		          )
		        ) {
		          if (
		            null !== priorSelectionRange &&
		            hasSelectionCapabilities(priorFocusedElem)
		          ) {
		            var start = priorSelectionRange.start,
		              end = priorSelectionRange.end;
		            void 0 === end && (end = start);
		            if ("selectionStart" in priorFocusedElem)
		              (priorFocusedElem.selectionStart = start),
		                (priorFocusedElem.selectionEnd = Math.min(
		                  end,
		                  priorFocusedElem.value.length
		                ));
		            else {
		              var doc = priorFocusedElem.ownerDocument || document,
		                win = (doc && doc.defaultView) || window;
		              if (win.getSelection) {
		                var selection = win.getSelection(),
		                  length = priorFocusedElem.textContent.length,
		                  start$jscomp$0 = Math.min(priorSelectionRange.start, length),
		                  end$jscomp$0 =
		                    void 0 === priorSelectionRange.end
		                      ? start$jscomp$0
		                      : Math.min(priorSelectionRange.end, length);
		                !selection.extend &&
		                  start$jscomp$0 > end$jscomp$0 &&
		                  ((curFocusedElem = end$jscomp$0),
		                  (end$jscomp$0 = start$jscomp$0),
		                  (start$jscomp$0 = curFocusedElem));
		                var startMarker = getNodeForCharacterOffset(
		                    priorFocusedElem,
		                    start$jscomp$0
		                  ),
		                  endMarker = getNodeForCharacterOffset(
		                    priorFocusedElem,
		                    end$jscomp$0
		                  );
		                if (
		                  startMarker &&
		                  endMarker &&
		                  (1 !== selection.rangeCount ||
		                    selection.anchorNode !== startMarker.node ||
		                    selection.anchorOffset !== startMarker.offset ||
		                    selection.focusNode !== endMarker.node ||
		                    selection.focusOffset !== endMarker.offset)
		                ) {
		                  var range = doc.createRange();
		                  range.setStart(startMarker.node, startMarker.offset);
		                  selection.removeAllRanges();
		                  start$jscomp$0 > end$jscomp$0
		                    ? (selection.addRange(range),
		                      selection.extend(endMarker.node, endMarker.offset))
		                    : (range.setEnd(endMarker.node, endMarker.offset),
		                      selection.addRange(range));
		                }
		              }
		            }
		          }
		          doc = [];
		          for (
		            selection = priorFocusedElem;
		            (selection = selection.parentNode);

		          )
		            1 === selection.nodeType &&
		              doc.push({
		                element: selection,
		                left: selection.scrollLeft,
		                top: selection.scrollTop
		              });
		          "function" === typeof priorFocusedElem.focus &&
		            priorFocusedElem.focus();
		          for (
		            priorFocusedElem = 0;
		            priorFocusedElem < doc.length;
		            priorFocusedElem++
		          ) {
		            var info = doc[priorFocusedElem];
		            info.element.scrollLeft = info.left;
		            info.element.scrollTop = info.top;
		          }
		        }
		        _enabled = !!eventsEnabled;
		        selectionInformation = eventsEnabled = null;
		      } finally {
		        (executionContext = prevExecutionContext),
		          (ReactDOMSharedInternals.p = previousPriority),
		          (ReactSharedInternals.T = rootMutationHasEffect);
		      }
		    }
		    root.current = finishedWork;
		    pendingEffectsStatus = 2;
		  }
		}
		function flushLayoutEffects() {
		  if (2 === pendingEffectsStatus) {
		    pendingEffectsStatus = 0;
		    var root = pendingEffectsRoot,
		      finishedWork = pendingFinishedWork,
		      rootHasLayoutEffect = 0 !== (finishedWork.flags & 8772);
		    if (0 !== (finishedWork.subtreeFlags & 8772) || rootHasLayoutEffect) {
		      rootHasLayoutEffect = ReactSharedInternals.T;
		      ReactSharedInternals.T = null;
		      var previousPriority = ReactDOMSharedInternals.p;
		      ReactDOMSharedInternals.p = 2;
		      var prevExecutionContext = executionContext;
		      executionContext |= 4;
		      try {
		        commitLayoutEffectOnFiber(root, finishedWork.alternate, finishedWork);
		      } finally {
		        (executionContext = prevExecutionContext),
		          (ReactDOMSharedInternals.p = previousPriority),
		          (ReactSharedInternals.T = rootHasLayoutEffect);
		      }
		    }
		    pendingEffectsStatus = 3;
		  }
		}
		function flushSpawnedWork() {
		  if (4 === pendingEffectsStatus || 3 === pendingEffectsStatus) {
		    pendingEffectsStatus = 0;
		    requestPaint();
		    var root = pendingEffectsRoot,
		      finishedWork = pendingFinishedWork,
		      lanes = pendingEffectsLanes,
		      recoverableErrors = pendingRecoverableErrors;
		    0 !== (finishedWork.subtreeFlags & 10256) ||
		    0 !== (finishedWork.flags & 10256)
		      ? (pendingEffectsStatus = 5)
		      : ((pendingEffectsStatus = 0),
		        (pendingFinishedWork = pendingEffectsRoot = null),
		        releaseRootPooledCache(root, root.pendingLanes));
		    var remainingLanes = root.pendingLanes;
		    0 === remainingLanes && (legacyErrorBoundariesThatAlreadyFailed = null);
		    lanesToEventPriority(lanes);
		    finishedWork = finishedWork.stateNode;
		    if (injectedHook && "function" === typeof injectedHook.onCommitFiberRoot)
		      try {
		        injectedHook.onCommitFiberRoot(
		          rendererID,
		          finishedWork,
		          void 0,
		          128 === (finishedWork.current.flags & 128)
		        );
		      } catch (err) {}
		    if (null !== recoverableErrors) {
		      finishedWork = ReactSharedInternals.T;
		      remainingLanes = ReactDOMSharedInternals.p;
		      ReactDOMSharedInternals.p = 2;
		      ReactSharedInternals.T = null;
		      try {
		        for (
		          var onRecoverableError = root.onRecoverableError, i = 0;
		          i < recoverableErrors.length;
		          i++
		        ) {
		          var recoverableError = recoverableErrors[i];
		          onRecoverableError(recoverableError.value, {
		            componentStack: recoverableError.stack
		          });
		        }
		      } finally {
		        (ReactSharedInternals.T = finishedWork),
		          (ReactDOMSharedInternals.p = remainingLanes);
		      }
		    }
		    0 !== (pendingEffectsLanes & 3) && flushPendingEffects();
		    ensureRootIsScheduled(root);
		    remainingLanes = root.pendingLanes;
		    0 !== (lanes & 4194090) && 0 !== (remainingLanes & 42)
		      ? root === rootWithNestedUpdates
		        ? nestedUpdateCount++
		        : ((nestedUpdateCount = 0), (rootWithNestedUpdates = root))
		      : (nestedUpdateCount = 0);
		    flushSyncWorkAcrossRoots_impl(0);
		  }
		}
		function releaseRootPooledCache(root, remainingLanes) {
		  0 === (root.pooledCacheLanes &= remainingLanes) &&
		    ((remainingLanes = root.pooledCache),
		    null != remainingLanes &&
		      ((root.pooledCache = null), releaseCache(remainingLanes)));
		}
		function flushPendingEffects(wasDelayedCommit) {
		  flushMutationEffects();
		  flushLayoutEffects();
		  flushSpawnedWork();
		  return flushPassiveEffects();
		}
		function flushPassiveEffects() {
		  if (5 !== pendingEffectsStatus) return false;
		  var root = pendingEffectsRoot,
		    remainingLanes = pendingEffectsRemainingLanes;
		  pendingEffectsRemainingLanes = 0;
		  var renderPriority = lanesToEventPriority(pendingEffectsLanes),
		    prevTransition = ReactSharedInternals.T,
		    previousPriority = ReactDOMSharedInternals.p;
		  try {
		    ReactDOMSharedInternals.p = 32 > renderPriority ? 32 : renderPriority;
		    ReactSharedInternals.T = null;
		    renderPriority = pendingPassiveTransitions;
		    pendingPassiveTransitions = null;
		    var root$jscomp$0 = pendingEffectsRoot,
		      lanes = pendingEffectsLanes;
		    pendingEffectsStatus = 0;
		    pendingFinishedWork = pendingEffectsRoot = null;
		    pendingEffectsLanes = 0;
		    if (0 !== (executionContext & 6)) throw Error(formatProdErrorMessage(331));
		    var prevExecutionContext = executionContext;
		    executionContext |= 4;
		    commitPassiveUnmountOnFiber(root$jscomp$0.current);
		    commitPassiveMountOnFiber(
		      root$jscomp$0,
		      root$jscomp$0.current,
		      lanes,
		      renderPriority
		    );
		    executionContext = prevExecutionContext;
		    flushSyncWorkAcrossRoots_impl(0, !1);
		    if (
		      injectedHook &&
		      "function" === typeof injectedHook.onPostCommitFiberRoot
		    )
		      try {
		        injectedHook.onPostCommitFiberRoot(rendererID, root$jscomp$0);
		      } catch (err) {}
		    return !0;
		  } finally {
		    (ReactDOMSharedInternals.p = previousPriority),
		      (ReactSharedInternals.T = prevTransition),
		      releaseRootPooledCache(root, remainingLanes);
		  }
		}
		function captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error) {
		  sourceFiber = createCapturedValueAtFiber(error, sourceFiber);
		  sourceFiber = createRootErrorUpdate(rootFiber.stateNode, sourceFiber, 2);
		  rootFiber = enqueueUpdate(rootFiber, sourceFiber, 2);
		  null !== rootFiber &&
		    (markRootUpdated$1(rootFiber, 2), ensureRootIsScheduled(rootFiber));
		}
		function captureCommitPhaseError(sourceFiber, nearestMountedAncestor, error) {
		  if (3 === sourceFiber.tag)
		    captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error);
		  else
		    for (; null !== nearestMountedAncestor; ) {
		      if (3 === nearestMountedAncestor.tag) {
		        captureCommitPhaseErrorOnRoot(
		          nearestMountedAncestor,
		          sourceFiber,
		          error
		        );
		        break;
		      } else if (1 === nearestMountedAncestor.tag) {
		        var instance = nearestMountedAncestor.stateNode;
		        if (
		          "function" ===
		            typeof nearestMountedAncestor.type.getDerivedStateFromError ||
		          ("function" === typeof instance.componentDidCatch &&
		            (null === legacyErrorBoundariesThatAlreadyFailed ||
		              !legacyErrorBoundariesThatAlreadyFailed.has(instance)))
		        ) {
		          sourceFiber = createCapturedValueAtFiber(error, sourceFiber);
		          error = createClassErrorUpdate(2);
		          instance = enqueueUpdate(nearestMountedAncestor, error, 2);
		          null !== instance &&
		            (initializeClassErrorUpdate(
		              error,
		              instance,
		              nearestMountedAncestor,
		              sourceFiber
		            ),
		            markRootUpdated$1(instance, 2),
		            ensureRootIsScheduled(instance));
		          break;
		        }
		      }
		      nearestMountedAncestor = nearestMountedAncestor.return;
		    }
		}
		function attachPingListener(root, wakeable, lanes) {
		  var pingCache = root.pingCache;
		  if (null === pingCache) {
		    pingCache = root.pingCache = new PossiblyWeakMap();
		    var threadIDs = new Set();
		    pingCache.set(wakeable, threadIDs);
		  } else
		    (threadIDs = pingCache.get(wakeable)),
		      void 0 === threadIDs &&
		        ((threadIDs = new Set()), pingCache.set(wakeable, threadIDs));
		  threadIDs.has(lanes) ||
		    ((workInProgressRootDidAttachPingListener = true),
		    threadIDs.add(lanes),
		    (root = pingSuspendedRoot.bind(null, root, wakeable, lanes)),
		    wakeable.then(root, root));
		}
		function pingSuspendedRoot(root, wakeable, pingedLanes) {
		  var pingCache = root.pingCache;
		  null !== pingCache && pingCache.delete(wakeable);
		  root.pingedLanes |= root.suspendedLanes & pingedLanes;
		  root.warmLanes &= ~pingedLanes;
		  workInProgressRoot === root &&
		    (workInProgressRootRenderLanes & pingedLanes) === pingedLanes &&
		    (4 === workInProgressRootExitStatus ||
		    (3 === workInProgressRootExitStatus &&
		      (workInProgressRootRenderLanes & 62914560) ===
		        workInProgressRootRenderLanes &&
		      300 > now() - globalMostRecentFallbackTime)
		      ? 0 === (executionContext & 2) && prepareFreshStack(root, 0)
		      : (workInProgressRootPingedLanes |= pingedLanes),
		    workInProgressSuspendedRetryLanes === workInProgressRootRenderLanes &&
		      (workInProgressSuspendedRetryLanes = 0));
		  ensureRootIsScheduled(root);
		}
		function retryTimedOutBoundary(boundaryFiber, retryLane) {
		  0 === retryLane && (retryLane = claimNextRetryLane());
		  boundaryFiber = enqueueConcurrentRenderForLane(boundaryFiber, retryLane);
		  null !== boundaryFiber &&
		    (markRootUpdated$1(boundaryFiber, retryLane),
		    ensureRootIsScheduled(boundaryFiber));
		}
		function retryDehydratedSuspenseBoundary(boundaryFiber) {
		  var suspenseState = boundaryFiber.memoizedState,
		    retryLane = 0;
		  null !== suspenseState && (retryLane = suspenseState.retryLane);
		  retryTimedOutBoundary(boundaryFiber, retryLane);
		}
		function resolveRetryWakeable(boundaryFiber, wakeable) {
		  var retryLane = 0;
		  switch (boundaryFiber.tag) {
		    case 13:
		      var retryCache = boundaryFiber.stateNode;
		      var suspenseState = boundaryFiber.memoizedState;
		      null !== suspenseState && (retryLane = suspenseState.retryLane);
		      break;
		    case 19:
		      retryCache = boundaryFiber.stateNode;
		      break;
		    case 22:
		      retryCache = boundaryFiber.stateNode._retryCache;
		      break;
		    default:
		      throw Error(formatProdErrorMessage(314));
		  }
		  null !== retryCache && retryCache.delete(wakeable);
		  retryTimedOutBoundary(boundaryFiber, retryLane);
		}
		function scheduleCallback$1(priorityLevel, callback) {
		  return scheduleCallback$3(priorityLevel, callback);
		}
		var firstScheduledRoot = null,
		  lastScheduledRoot = null,
		  didScheduleMicrotask = false,
		  mightHavePendingSyncWork = false,
		  isFlushingWork = false,
		  currentEventTransitionLane = 0;
		function ensureRootIsScheduled(root) {
		  root !== lastScheduledRoot &&
		    null === root.next &&
		    (null === lastScheduledRoot
		      ? (firstScheduledRoot = lastScheduledRoot = root)
		      : (lastScheduledRoot = lastScheduledRoot.next = root));
		  mightHavePendingSyncWork = true;
		  didScheduleMicrotask ||
		    ((didScheduleMicrotask = true), scheduleImmediateRootScheduleTask());
		}
		function flushSyncWorkAcrossRoots_impl(syncTransitionLanes, onlyLegacy) {
		  if (!isFlushingWork && mightHavePendingSyncWork) {
		    isFlushingWork = true;
		    do {
		      var didPerformSomeWork = false;
		      for (var root$174 = firstScheduledRoot; null !== root$174; ) {
		        if (0 !== syncTransitionLanes) {
		            var pendingLanes = root$174.pendingLanes;
		            if (0 === pendingLanes) var JSCompiler_inline_result = 0;
		            else {
		              var suspendedLanes = root$174.suspendedLanes,
		                pingedLanes = root$174.pingedLanes;
		              JSCompiler_inline_result =
		                (1 << (31 - clz32(42 | syncTransitionLanes) + 1)) - 1;
		              JSCompiler_inline_result &=
		                pendingLanes & ~(suspendedLanes & ~pingedLanes);
		              JSCompiler_inline_result =
		                JSCompiler_inline_result & 201326741
		                  ? (JSCompiler_inline_result & 201326741) | 1
		                  : JSCompiler_inline_result
		                    ? JSCompiler_inline_result | 2
		                    : 0;
		            }
		            0 !== JSCompiler_inline_result &&
		              ((didPerformSomeWork = true),
		              performSyncWorkOnRoot(root$174, JSCompiler_inline_result));
		          } else
		            (JSCompiler_inline_result = workInProgressRootRenderLanes),
		              (JSCompiler_inline_result = getNextLanes(
		                root$174,
		                root$174 === workInProgressRoot ? JSCompiler_inline_result : 0,
		                null !== root$174.cancelPendingCommit ||
		                  -1 !== root$174.timeoutHandle
		              )),
		              0 === (JSCompiler_inline_result & 3) ||
		                checkIfRootIsPrerendering(root$174, JSCompiler_inline_result) ||
		                ((didPerformSomeWork = true),
		                performSyncWorkOnRoot(root$174, JSCompiler_inline_result));
		        root$174 = root$174.next;
		      }
		    } while (didPerformSomeWork);
		    isFlushingWork = false;
		  }
		}
		function processRootScheduleInImmediateTask() {
		  processRootScheduleInMicrotask();
		}
		function processRootScheduleInMicrotask() {
		  mightHavePendingSyncWork = didScheduleMicrotask = false;
		  var syncTransitionLanes = 0;
		  0 !== currentEventTransitionLane &&
		    (shouldAttemptEagerTransition() &&
		      (syncTransitionLanes = currentEventTransitionLane),
		    (currentEventTransitionLane = 0));
		  for (
		    var currentTime = now(), prev = null, root = firstScheduledRoot;
		    null !== root;

		  ) {
		    var next = root.next,
		      nextLanes = scheduleTaskForRootDuringMicrotask(root, currentTime);
		    if (0 === nextLanes)
		      (root.next = null),
		        null === prev ? (firstScheduledRoot = next) : (prev.next = next),
		        null === next && (lastScheduledRoot = prev);
		    else if (
		      ((prev = root), 0 !== syncTransitionLanes || 0 !== (nextLanes & 3))
		    )
		      mightHavePendingSyncWork = true;
		    root = next;
		  }
		  flushSyncWorkAcrossRoots_impl(syncTransitionLanes);
		}
		function scheduleTaskForRootDuringMicrotask(root, currentTime) {
		  for (
		    var suspendedLanes = root.suspendedLanes,
		      pingedLanes = root.pingedLanes,
		      expirationTimes = root.expirationTimes,
		      lanes = root.pendingLanes & -62914561;
		    0 < lanes;

		  ) {
		    var index$3 = 31 - clz32(lanes),
		      lane = 1 << index$3,
		      expirationTime = expirationTimes[index$3];
		    if (-1 === expirationTime) {
		      if (0 === (lane & suspendedLanes) || 0 !== (lane & pingedLanes))
		        expirationTimes[index$3] = computeExpirationTime(lane, currentTime);
		    } else expirationTime <= currentTime && (root.expiredLanes |= lane);
		    lanes &= ~lane;
		  }
		  currentTime = workInProgressRoot;
		  suspendedLanes = workInProgressRootRenderLanes;
		  suspendedLanes = getNextLanes(
		    root,
		    root === currentTime ? suspendedLanes : 0,
		    null !== root.cancelPendingCommit || -1 !== root.timeoutHandle
		  );
		  pingedLanes = root.callbackNode;
		  if (
		    0 === suspendedLanes ||
		    (root === currentTime &&
		      (2 === workInProgressSuspendedReason ||
		        9 === workInProgressSuspendedReason)) ||
		    null !== root.cancelPendingCommit
		  )
		    return (
		      null !== pingedLanes &&
		        null !== pingedLanes &&
		        cancelCallback$1(pingedLanes),
		      (root.callbackNode = null),
		      (root.callbackPriority = 0)
		    );
		  if (
		    0 === (suspendedLanes & 3) ||
		    checkIfRootIsPrerendering(root, suspendedLanes)
		  ) {
		    currentTime = suspendedLanes & -suspendedLanes;
		    if (currentTime === root.callbackPriority) return currentTime;
		    null !== pingedLanes && cancelCallback$1(pingedLanes);
		    switch (lanesToEventPriority(suspendedLanes)) {
		      case 2:
		      case 8:
		        suspendedLanes = UserBlockingPriority;
		        break;
		      case 32:
		        suspendedLanes = NormalPriority$1;
		        break;
		      case 268435456:
		        suspendedLanes = IdlePriority;
		        break;
		      default:
		        suspendedLanes = NormalPriority$1;
		    }
		    pingedLanes = performWorkOnRootViaSchedulerTask.bind(null, root);
		    suspendedLanes = scheduleCallback$3(suspendedLanes, pingedLanes);
		    root.callbackPriority = currentTime;
		    root.callbackNode = suspendedLanes;
		    return currentTime;
		  }
		  null !== pingedLanes && null !== pingedLanes && cancelCallback$1(pingedLanes);
		  root.callbackPriority = 2;
		  root.callbackNode = null;
		  return 2;
		}
		function performWorkOnRootViaSchedulerTask(root, didTimeout) {
		  if (0 !== pendingEffectsStatus && 5 !== pendingEffectsStatus)
		    return (root.callbackNode = null), (root.callbackPriority = 0), null;
		  var originalCallbackNode = root.callbackNode;
		  if (flushPendingEffects() && root.callbackNode !== originalCallbackNode)
		    return null;
		  var workInProgressRootRenderLanes$jscomp$0 = workInProgressRootRenderLanes;
		  workInProgressRootRenderLanes$jscomp$0 = getNextLanes(
		    root,
		    root === workInProgressRoot ? workInProgressRootRenderLanes$jscomp$0 : 0,
		    null !== root.cancelPendingCommit || -1 !== root.timeoutHandle
		  );
		  if (0 === workInProgressRootRenderLanes$jscomp$0) return null;
		  performWorkOnRoot(root, workInProgressRootRenderLanes$jscomp$0, didTimeout);
		  scheduleTaskForRootDuringMicrotask(root, now());
		  return null != root.callbackNode && root.callbackNode === originalCallbackNode
		    ? performWorkOnRootViaSchedulerTask.bind(null, root)
		    : null;
		}
		function performSyncWorkOnRoot(root, lanes) {
		  if (flushPendingEffects()) return null;
		  performWorkOnRoot(root, lanes, true);
		}
		function scheduleImmediateRootScheduleTask() {
		  scheduleMicrotask(function () {
		    0 !== (executionContext & 6)
		      ? scheduleCallback$3(
		          ImmediatePriority,
		          processRootScheduleInImmediateTask
		        )
		      : processRootScheduleInMicrotask();
		  });
		}
		function requestTransitionLane() {
		  0 === currentEventTransitionLane &&
		    (currentEventTransitionLane = claimNextTransitionLane());
		  return currentEventTransitionLane;
		}
		function coerceFormActionProp(actionProp) {
		  return null == actionProp ||
		    "symbol" === typeof actionProp ||
		    "boolean" === typeof actionProp
		    ? null
		    : "function" === typeof actionProp
		      ? actionProp
		      : sanitizeURL("" + actionProp);
		}
		function createFormDataWithSubmitter(form, submitter) {
		  var temp = submitter.ownerDocument.createElement("input");
		  temp.name = submitter.name;
		  temp.value = submitter.value;
		  form.id && temp.setAttribute("form", form.id);
		  submitter.parentNode.insertBefore(temp, submitter);
		  form = new FormData(form);
		  temp.parentNode.removeChild(temp);
		  return form;
		}
		function extractEvents$1(
		  dispatchQueue,
		  domEventName,
		  maybeTargetInst,
		  nativeEvent,
		  nativeEventTarget
		) {
		  if (
		    "submit" === domEventName &&
		    maybeTargetInst &&
		    maybeTargetInst.stateNode === nativeEventTarget
		  ) {
		    var action = coerceFormActionProp(
		        (nativeEventTarget[internalPropsKey] || null).action
		      ),
		      submitter = nativeEvent.submitter;
		    submitter &&
		      ((domEventName = (domEventName = submitter[internalPropsKey] || null)
		        ? coerceFormActionProp(domEventName.formAction)
		        : submitter.getAttribute("formAction")),
		      null !== domEventName && ((action = domEventName), (submitter = null)));
		    var event = new SyntheticEvent(
		      "action",
		      "action",
		      null,
		      nativeEvent,
		      nativeEventTarget
		    );
		    dispatchQueue.push({
		      event: event,
		      listeners: [
		        {
		          instance: null,
		          listener: function () {
		            if (nativeEvent.defaultPrevented) {
		              if (0 !== currentEventTransitionLane) {
		                var formData = submitter
		                  ? createFormDataWithSubmitter(nativeEventTarget, submitter)
		                  : new FormData(nativeEventTarget);
		                startHostTransition(
		                  maybeTargetInst,
		                  {
		                    pending: true,
		                    data: formData,
		                    method: nativeEventTarget.method,
		                    action: action
		                  },
		                  null,
		                  formData
		                );
		              }
		            } else
		              "function" === typeof action &&
		                (event.preventDefault(),
		                (formData = submitter
		                  ? createFormDataWithSubmitter(nativeEventTarget, submitter)
		                  : new FormData(nativeEventTarget)),
		                startHostTransition(
		                  maybeTargetInst,
		                  {
		                    pending: true,
		                    data: formData,
		                    method: nativeEventTarget.method,
		                    action: action
		                  },
		                  action,
		                  formData
		                ));
		          },
		          currentTarget: nativeEventTarget
		        }
		      ]
		    });
		  }
		}
		for (
		  var i$jscomp$inline_1528 = 0;
		  i$jscomp$inline_1528 < simpleEventPluginEvents.length;
		  i$jscomp$inline_1528++
		) {
		  var eventName$jscomp$inline_1529 =
		      simpleEventPluginEvents[i$jscomp$inline_1528],
		    domEventName$jscomp$inline_1530 =
		      eventName$jscomp$inline_1529.toLowerCase(),
		    capitalizedEvent$jscomp$inline_1531 =
		      eventName$jscomp$inline_1529[0].toUpperCase() +
		      eventName$jscomp$inline_1529.slice(1);
		  registerSimpleEvent(
		    domEventName$jscomp$inline_1530,
		    "on" + capitalizedEvent$jscomp$inline_1531
		  );
		}
		registerSimpleEvent(ANIMATION_END, "onAnimationEnd");
		registerSimpleEvent(ANIMATION_ITERATION, "onAnimationIteration");
		registerSimpleEvent(ANIMATION_START, "onAnimationStart");
		registerSimpleEvent("dblclick", "onDoubleClick");
		registerSimpleEvent("focusin", "onFocus");
		registerSimpleEvent("focusout", "onBlur");
		registerSimpleEvent(TRANSITION_RUN, "onTransitionRun");
		registerSimpleEvent(TRANSITION_START, "onTransitionStart");
		registerSimpleEvent(TRANSITION_CANCEL, "onTransitionCancel");
		registerSimpleEvent(TRANSITION_END, "onTransitionEnd");
		registerDirectEvent("onMouseEnter", ["mouseout", "mouseover"]);
		registerDirectEvent("onMouseLeave", ["mouseout", "mouseover"]);
		registerDirectEvent("onPointerEnter", ["pointerout", "pointerover"]);
		registerDirectEvent("onPointerLeave", ["pointerout", "pointerover"]);
		registerTwoPhaseEvent(
		  "onChange",
		  "change click focusin focusout input keydown keyup selectionchange".split(" ")
		);
		registerTwoPhaseEvent(
		  "onSelect",
		  "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(
		    " "
		  )
		);
		registerTwoPhaseEvent("onBeforeInput", [
		  "compositionend",
		  "keypress",
		  "textInput",
		  "paste"
		]);
		registerTwoPhaseEvent(
		  "onCompositionEnd",
		  "compositionend focusout keydown keypress keyup mousedown".split(" ")
		);
		registerTwoPhaseEvent(
		  "onCompositionStart",
		  "compositionstart focusout keydown keypress keyup mousedown".split(" ")
		);
		registerTwoPhaseEvent(
		  "onCompositionUpdate",
		  "compositionupdate focusout keydown keypress keyup mousedown".split(" ")
		);
		var mediaEventTypes =
		    "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(
		      " "
		    ),
		  nonDelegatedEvents = new Set(
		    "beforetoggle cancel close invalid load scroll scrollend toggle"
		      .split(" ")
		      .concat(mediaEventTypes)
		  );
		function processDispatchQueue(dispatchQueue, eventSystemFlags) {
		  eventSystemFlags = 0 !== (eventSystemFlags & 4);
		  for (var i = 0; i < dispatchQueue.length; i++) {
		    var _dispatchQueue$i = dispatchQueue[i],
		      event = _dispatchQueue$i.event;
		    _dispatchQueue$i = _dispatchQueue$i.listeners;
		    a: {
		      var previousInstance = void 0;
		      if (eventSystemFlags)
		        for (
		          var i$jscomp$0 = _dispatchQueue$i.length - 1;
		          0 <= i$jscomp$0;
		          i$jscomp$0--
		        ) {
		          var _dispatchListeners$i = _dispatchQueue$i[i$jscomp$0],
		            instance = _dispatchListeners$i.instance,
		            currentTarget = _dispatchListeners$i.currentTarget;
		          _dispatchListeners$i = _dispatchListeners$i.listener;
		          if (instance !== previousInstance && event.isPropagationStopped())
		            break a;
		          previousInstance = _dispatchListeners$i;
		          event.currentTarget = currentTarget;
		          try {
		            previousInstance(event);
		          } catch (error) {
		            reportGlobalError(error);
		          }
		          event.currentTarget = null;
		          previousInstance = instance;
		        }
		      else
		        for (
		          i$jscomp$0 = 0;
		          i$jscomp$0 < _dispatchQueue$i.length;
		          i$jscomp$0++
		        ) {
		          _dispatchListeners$i = _dispatchQueue$i[i$jscomp$0];
		          instance = _dispatchListeners$i.instance;
		          currentTarget = _dispatchListeners$i.currentTarget;
		          _dispatchListeners$i = _dispatchListeners$i.listener;
		          if (instance !== previousInstance && event.isPropagationStopped())
		            break a;
		          previousInstance = _dispatchListeners$i;
		          event.currentTarget = currentTarget;
		          try {
		            previousInstance(event);
		          } catch (error) {
		            reportGlobalError(error);
		          }
		          event.currentTarget = null;
		          previousInstance = instance;
		        }
		    }
		  }
		}
		function listenToNonDelegatedEvent(domEventName, targetElement) {
		  var JSCompiler_inline_result = targetElement[internalEventHandlersKey];
		  void 0 === JSCompiler_inline_result &&
		    (JSCompiler_inline_result = targetElement[internalEventHandlersKey] =
		      new Set());
		  var listenerSetKey = domEventName + "__bubble";
		  JSCompiler_inline_result.has(listenerSetKey) ||
		    (addTrappedEventListener(targetElement, domEventName, 2, false),
		    JSCompiler_inline_result.add(listenerSetKey));
		}
		function listenToNativeEvent(domEventName, isCapturePhaseListener, target) {
		  var eventSystemFlags = 0;
		  isCapturePhaseListener && (eventSystemFlags |= 4);
		  addTrappedEventListener(
		    target,
		    domEventName,
		    eventSystemFlags,
		    isCapturePhaseListener
		  );
		}
		var listeningMarker = "_reactListening" + Math.random().toString(36).slice(2);
		function listenToAllSupportedEvents(rootContainerElement) {
		  if (!rootContainerElement[listeningMarker]) {
		    rootContainerElement[listeningMarker] = true;
		    allNativeEvents.forEach(function (domEventName) {
		      "selectionchange" !== domEventName &&
		        (nonDelegatedEvents.has(domEventName) ||
		          listenToNativeEvent(domEventName, false, rootContainerElement),
		        listenToNativeEvent(domEventName, true, rootContainerElement));
		    });
		    var ownerDocument =
		      9 === rootContainerElement.nodeType
		        ? rootContainerElement
		        : rootContainerElement.ownerDocument;
		    null === ownerDocument ||
		      ownerDocument[listeningMarker] ||
		      ((ownerDocument[listeningMarker] = true),
		      listenToNativeEvent("selectionchange", false, ownerDocument));
		  }
		}
		function addTrappedEventListener(
		  targetContainer,
		  domEventName,
		  eventSystemFlags,
		  isCapturePhaseListener
		) {
		  switch (getEventPriority(domEventName)) {
		    case 2:
		      var listenerWrapper = dispatchDiscreteEvent;
		      break;
		    case 8:
		      listenerWrapper = dispatchContinuousEvent;
		      break;
		    default:
		      listenerWrapper = dispatchEvent;
		  }
		  eventSystemFlags = listenerWrapper.bind(
		    null,
		    domEventName,
		    eventSystemFlags,
		    targetContainer
		  );
		  listenerWrapper = void 0;
		  !passiveBrowserEventsSupported ||
		    ("touchstart" !== domEventName &&
		      "touchmove" !== domEventName &&
		      "wheel" !== domEventName) ||
		    (listenerWrapper = true);
		  isCapturePhaseListener
		    ? void 0 !== listenerWrapper
		      ? targetContainer.addEventListener(domEventName, eventSystemFlags, {
		          capture: true,
		          passive: listenerWrapper
		        })
		      : targetContainer.addEventListener(domEventName, eventSystemFlags, true)
		    : void 0 !== listenerWrapper
		      ? targetContainer.addEventListener(domEventName, eventSystemFlags, {
		          passive: listenerWrapper
		        })
		      : targetContainer.addEventListener(domEventName, eventSystemFlags, false);
		}
		function dispatchEventForPluginEventSystem(
		  domEventName,
		  eventSystemFlags,
		  nativeEvent,
		  targetInst$jscomp$0,
		  targetContainer
		) {
		  var ancestorInst = targetInst$jscomp$0;
		  if (
		    0 === (eventSystemFlags & 1) &&
		    0 === (eventSystemFlags & 2) &&
		    null !== targetInst$jscomp$0
		  )
		    a: for (;;) {
		      if (null === targetInst$jscomp$0) return;
		      var nodeTag = targetInst$jscomp$0.tag;
		      if (3 === nodeTag || 4 === nodeTag) {
		        var container = targetInst$jscomp$0.stateNode.containerInfo;
		        if (container === targetContainer) break;
		        if (4 === nodeTag)
		          for (nodeTag = targetInst$jscomp$0.return; null !== nodeTag; ) {
		            var grandTag = nodeTag.tag;
		            if (
		              (3 === grandTag || 4 === grandTag) &&
		              nodeTag.stateNode.containerInfo === targetContainer
		            )
		              return;
		            nodeTag = nodeTag.return;
		          }
		        for (; null !== container; ) {
		          nodeTag = getClosestInstanceFromNode(container);
		          if (null === nodeTag) return;
		          grandTag = nodeTag.tag;
		          if (
		            5 === grandTag ||
		            6 === grandTag ||
		            26 === grandTag ||
		            27 === grandTag
		          ) {
		            targetInst$jscomp$0 = ancestorInst = nodeTag;
		            continue a;
		          }
		          container = container.parentNode;
		        }
		      }
		      targetInst$jscomp$0 = targetInst$jscomp$0.return;
		    }
		  batchedUpdates$1(function () {
		    var targetInst = ancestorInst,
		      nativeEventTarget = getEventTarget(nativeEvent),
		      dispatchQueue = [];
		    a: {
		      var reactName = topLevelEventsToReactNames.get(domEventName);
		      if (void 0 !== reactName) {
		        var SyntheticEventCtor = SyntheticEvent,
		          reactEventType = domEventName;
		        switch (domEventName) {
		          case "keypress":
		            if (0 === getEventCharCode(nativeEvent)) break a;
		          case "keydown":
		          case "keyup":
		            SyntheticEventCtor = SyntheticKeyboardEvent;
		            break;
		          case "focusin":
		            reactEventType = "focus";
		            SyntheticEventCtor = SyntheticFocusEvent;
		            break;
		          case "focusout":
		            reactEventType = "blur";
		            SyntheticEventCtor = SyntheticFocusEvent;
		            break;
		          case "beforeblur":
		          case "afterblur":
		            SyntheticEventCtor = SyntheticFocusEvent;
		            break;
		          case "click":
		            if (2 === nativeEvent.button) break a;
		          case "auxclick":
		          case "dblclick":
		          case "mousedown":
		          case "mousemove":
		          case "mouseup":
		          case "mouseout":
		          case "mouseover":
		          case "contextmenu":
		            SyntheticEventCtor = SyntheticMouseEvent;
		            break;
		          case "drag":
		          case "dragend":
		          case "dragenter":
		          case "dragexit":
		          case "dragleave":
		          case "dragover":
		          case "dragstart":
		          case "drop":
		            SyntheticEventCtor = SyntheticDragEvent;
		            break;
		          case "touchcancel":
		          case "touchend":
		          case "touchmove":
		          case "touchstart":
		            SyntheticEventCtor = SyntheticTouchEvent;
		            break;
		          case ANIMATION_END:
		          case ANIMATION_ITERATION:
		          case ANIMATION_START:
		            SyntheticEventCtor = SyntheticAnimationEvent;
		            break;
		          case TRANSITION_END:
		            SyntheticEventCtor = SyntheticTransitionEvent;
		            break;
		          case "scroll":
		          case "scrollend":
		            SyntheticEventCtor = SyntheticUIEvent;
		            break;
		          case "wheel":
		            SyntheticEventCtor = SyntheticWheelEvent;
		            break;
		          case "copy":
		          case "cut":
		          case "paste":
		            SyntheticEventCtor = SyntheticClipboardEvent;
		            break;
		          case "gotpointercapture":
		          case "lostpointercapture":
		          case "pointercancel":
		          case "pointerdown":
		          case "pointermove":
		          case "pointerout":
		          case "pointerover":
		          case "pointerup":
		            SyntheticEventCtor = SyntheticPointerEvent;
		            break;
		          case "toggle":
		          case "beforetoggle":
		            SyntheticEventCtor = SyntheticToggleEvent;
		        }
		        var inCapturePhase = 0 !== (eventSystemFlags & 4),
		          accumulateTargetOnly =
		            !inCapturePhase &&
		            ("scroll" === domEventName || "scrollend" === domEventName),
		          reactEventName = inCapturePhase
		            ? null !== reactName
		              ? reactName + "Capture"
		              : null
		            : reactName;
		        inCapturePhase = [];
		        for (
		          var instance = targetInst, lastHostComponent;
		          null !== instance;

		        ) {
		          var _instance = instance;
		          lastHostComponent = _instance.stateNode;
		          _instance = _instance.tag;
		          (5 !== _instance && 26 !== _instance && 27 !== _instance) ||
		            null === lastHostComponent ||
		            null === reactEventName ||
		            ((_instance = getListener(instance, reactEventName)),
		            null != _instance &&
		              inCapturePhase.push(
		                createDispatchListener(instance, _instance, lastHostComponent)
		              ));
		          if (accumulateTargetOnly) break;
		          instance = instance.return;
		        }
		        0 < inCapturePhase.length &&
		          ((reactName = new SyntheticEventCtor(
		            reactName,
		            reactEventType,
		            null,
		            nativeEvent,
		            nativeEventTarget
		          )),
		          dispatchQueue.push({ event: reactName, listeners: inCapturePhase }));
		      }
		    }
		    if (0 === (eventSystemFlags & 7)) {
		      a: {
		        reactName =
		          "mouseover" === domEventName || "pointerover" === domEventName;
		        SyntheticEventCtor =
		          "mouseout" === domEventName || "pointerout" === domEventName;
		        if (
		          reactName &&
		          nativeEvent !== currentReplayingEvent &&
		          (reactEventType =
		            nativeEvent.relatedTarget || nativeEvent.fromElement) &&
		          (getClosestInstanceFromNode(reactEventType) ||
		            reactEventType[internalContainerInstanceKey])
		        )
		          break a;
		        if (SyntheticEventCtor || reactName) {
		          reactName =
		            nativeEventTarget.window === nativeEventTarget
		              ? nativeEventTarget
		              : (reactName = nativeEventTarget.ownerDocument)
		                ? reactName.defaultView || reactName.parentWindow
		                : window;
		          if (SyntheticEventCtor) {
		            if (
		              ((reactEventType =
		                nativeEvent.relatedTarget || nativeEvent.toElement),
		              (SyntheticEventCtor = targetInst),
		              (reactEventType = reactEventType
		                ? getClosestInstanceFromNode(reactEventType)
		                : null),
		              null !== reactEventType &&
		                ((accumulateTargetOnly =
		                  getNearestMountedFiber(reactEventType)),
		                (inCapturePhase = reactEventType.tag),
		                reactEventType !== accumulateTargetOnly ||
		                  (5 !== inCapturePhase &&
		                    27 !== inCapturePhase &&
		                    6 !== inCapturePhase)))
		            )
		              reactEventType = null;
		          } else (SyntheticEventCtor = null), (reactEventType = targetInst);
		          if (SyntheticEventCtor !== reactEventType) {
		            inCapturePhase = SyntheticMouseEvent;
		            _instance = "onMouseLeave";
		            reactEventName = "onMouseEnter";
		            instance = "mouse";
		            if ("pointerout" === domEventName || "pointerover" === domEventName)
		              (inCapturePhase = SyntheticPointerEvent),
		                (_instance = "onPointerLeave"),
		                (reactEventName = "onPointerEnter"),
		                (instance = "pointer");
		            accumulateTargetOnly =
		              null == SyntheticEventCtor
		                ? reactName
		                : getNodeFromInstance(SyntheticEventCtor);
		            lastHostComponent =
		              null == reactEventType
		                ? reactName
		                : getNodeFromInstance(reactEventType);
		            reactName = new inCapturePhase(
		              _instance,
		              instance + "leave",
		              SyntheticEventCtor,
		              nativeEvent,
		              nativeEventTarget
		            );
		            reactName.target = accumulateTargetOnly;
		            reactName.relatedTarget = lastHostComponent;
		            _instance = null;
		            getClosestInstanceFromNode(nativeEventTarget) === targetInst &&
		              ((inCapturePhase = new inCapturePhase(
		                reactEventName,
		                instance + "enter",
		                reactEventType,
		                nativeEvent,
		                nativeEventTarget
		              )),
		              (inCapturePhase.target = lastHostComponent),
		              (inCapturePhase.relatedTarget = accumulateTargetOnly),
		              (_instance = inCapturePhase));
		            accumulateTargetOnly = _instance;
		            if (SyntheticEventCtor && reactEventType)
		              b: {
		                inCapturePhase = SyntheticEventCtor;
		                reactEventName = reactEventType;
		                instance = 0;
		                for (
		                  lastHostComponent = inCapturePhase;
		                  lastHostComponent;
		                  lastHostComponent = getParent(lastHostComponent)
		                )
		                  instance++;
		                lastHostComponent = 0;
		                for (
		                  _instance = reactEventName;
		                  _instance;
		                  _instance = getParent(_instance)
		                )
		                  lastHostComponent++;
		                for (; 0 < instance - lastHostComponent; )
		                  (inCapturePhase = getParent(inCapturePhase)), instance--;
		                for (; 0 < lastHostComponent - instance; )
		                  (reactEventName = getParent(reactEventName)),
		                    lastHostComponent--;
		                for (; instance--; ) {
		                  if (
		                    inCapturePhase === reactEventName ||
		                    (null !== reactEventName &&
		                      inCapturePhase === reactEventName.alternate)
		                  )
		                    break b;
		                  inCapturePhase = getParent(inCapturePhase);
		                  reactEventName = getParent(reactEventName);
		                }
		                inCapturePhase = null;
		              }
		            else inCapturePhase = null;
		            null !== SyntheticEventCtor &&
		              accumulateEnterLeaveListenersForEvent(
		                dispatchQueue,
		                reactName,
		                SyntheticEventCtor,
		                inCapturePhase,
		                !1
		              );
		            null !== reactEventType &&
		              null !== accumulateTargetOnly &&
		              accumulateEnterLeaveListenersForEvent(
		                dispatchQueue,
		                accumulateTargetOnly,
		                reactEventType,
		                inCapturePhase,
		                !0
		              );
		          }
		        }
		      }
		      a: {
		        reactName = targetInst ? getNodeFromInstance(targetInst) : window;
		        SyntheticEventCtor =
		          reactName.nodeName && reactName.nodeName.toLowerCase();
		        if (
		          "select" === SyntheticEventCtor ||
		          ("input" === SyntheticEventCtor && "file" === reactName.type)
		        )
		          var getTargetInstFunc = getTargetInstForChangeEvent;
		        else if (isTextInputElement(reactName))
		          if (isInputEventSupported)
		            getTargetInstFunc = getTargetInstForInputOrChangeEvent;
		          else {
		            getTargetInstFunc = getTargetInstForInputEventPolyfill;
		            var handleEventFunc = handleEventsForInputEventPolyfill;
		          }
		        else
		          (SyntheticEventCtor = reactName.nodeName),
		            !SyntheticEventCtor ||
		            "input" !== SyntheticEventCtor.toLowerCase() ||
		            ("checkbox" !== reactName.type && "radio" !== reactName.type)
		              ? targetInst &&
		                isCustomElement(targetInst.elementType) &&
		                (getTargetInstFunc = getTargetInstForChangeEvent)
		              : (getTargetInstFunc = getTargetInstForClickEvent);
		        if (
		          getTargetInstFunc &&
		          (getTargetInstFunc = getTargetInstFunc(domEventName, targetInst))
		        ) {
		          createAndAccumulateChangeEvent(
		            dispatchQueue,
		            getTargetInstFunc,
		            nativeEvent,
		            nativeEventTarget
		          );
		          break a;
		        }
		        handleEventFunc && handleEventFunc(domEventName, reactName, targetInst);
		        "focusout" === domEventName &&
		          targetInst &&
		          "number" === reactName.type &&
		          null != targetInst.memoizedProps.value &&
		          setDefaultValue(reactName, "number", reactName.value);
		      }
		      handleEventFunc = targetInst ? getNodeFromInstance(targetInst) : window;
		      switch (domEventName) {
		        case "focusin":
		          if (
		            isTextInputElement(handleEventFunc) ||
		            "true" === handleEventFunc.contentEditable
		          )
		            (activeElement = handleEventFunc),
		              (activeElementInst = targetInst),
		              (lastSelection = null);
		          break;
		        case "focusout":
		          lastSelection = activeElementInst = activeElement = null;
		          break;
		        case "mousedown":
		          mouseDown = !0;
		          break;
		        case "contextmenu":
		        case "mouseup":
		        case "dragend":
		          mouseDown = !1;
		          constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);
		          break;
		        case "selectionchange":
		          if (skipSelectionChangeEvent) break;
		        case "keydown":
		        case "keyup":
		          constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);
		      }
		      var fallbackData;
		      if (canUseCompositionEvent)
		        b: {
		          switch (domEventName) {
		            case "compositionstart":
		              var eventType = "onCompositionStart";
		              break b;
		            case "compositionend":
		              eventType = "onCompositionEnd";
		              break b;
		            case "compositionupdate":
		              eventType = "onCompositionUpdate";
		              break b;
		          }
		          eventType = void 0;
		        }
		      else
		        isComposing
		          ? isFallbackCompositionEnd(domEventName, nativeEvent) &&
		            (eventType = "onCompositionEnd")
		          : "keydown" === domEventName &&
		            229 === nativeEvent.keyCode &&
		            (eventType = "onCompositionStart");
		      eventType &&
		        (useFallbackCompositionData &&
		          "ko" !== nativeEvent.locale &&
		          (isComposing || "onCompositionStart" !== eventType
		            ? "onCompositionEnd" === eventType &&
		              isComposing &&
		              (fallbackData = getData())
		            : ((root = nativeEventTarget),
		              (startText = "value" in root ? root.value : root.textContent),
		              (isComposing = !0))),
		        (handleEventFunc = accumulateTwoPhaseListeners(targetInst, eventType)),
		        0 < handleEventFunc.length &&
		          ((eventType = new SyntheticCompositionEvent(
		            eventType,
		            domEventName,
		            null,
		            nativeEvent,
		            nativeEventTarget
		          )),
		          dispatchQueue.push({ event: eventType, listeners: handleEventFunc }),
		          fallbackData
		            ? (eventType.data = fallbackData)
		            : ((fallbackData = getDataFromCustomEvent(nativeEvent)),
		              null !== fallbackData && (eventType.data = fallbackData))));
		      if (
		        (fallbackData = canUseTextInputEvent
		          ? getNativeBeforeInputChars(domEventName, nativeEvent)
		          : getFallbackBeforeInputChars(domEventName, nativeEvent))
		      )
		        (eventType = accumulateTwoPhaseListeners(targetInst, "onBeforeInput")),
		          0 < eventType.length &&
		            ((handleEventFunc = new SyntheticCompositionEvent(
		              "onBeforeInput",
		              "beforeinput",
		              null,
		              nativeEvent,
		              nativeEventTarget
		            )),
		            dispatchQueue.push({
		              event: handleEventFunc,
		              listeners: eventType
		            }),
		            (handleEventFunc.data = fallbackData));
		      extractEvents$1(
		        dispatchQueue,
		        domEventName,
		        targetInst,
		        nativeEvent,
		        nativeEventTarget
		      );
		    }
		    processDispatchQueue(dispatchQueue, eventSystemFlags);
		  });
		}
		function createDispatchListener(instance, listener, currentTarget) {
		  return {
		    instance: instance,
		    listener: listener,
		    currentTarget: currentTarget
		  };
		}
		function accumulateTwoPhaseListeners(targetFiber, reactName) {
		  for (
		    var captureName = reactName + "Capture", listeners = [];
		    null !== targetFiber;

		  ) {
		    var _instance2 = targetFiber,
		      stateNode = _instance2.stateNode;
		    _instance2 = _instance2.tag;
		    (5 !== _instance2 && 26 !== _instance2 && 27 !== _instance2) ||
		      null === stateNode ||
		      ((_instance2 = getListener(targetFiber, captureName)),
		      null != _instance2 &&
		        listeners.unshift(
		          createDispatchListener(targetFiber, _instance2, stateNode)
		        ),
		      (_instance2 = getListener(targetFiber, reactName)),
		      null != _instance2 &&
		        listeners.push(
		          createDispatchListener(targetFiber, _instance2, stateNode)
		        ));
		    if (3 === targetFiber.tag) return listeners;
		    targetFiber = targetFiber.return;
		  }
		  return [];
		}
		function getParent(inst) {
		  if (null === inst) return null;
		  do inst = inst.return;
		  while (inst && 5 !== inst.tag && 27 !== inst.tag);
		  return inst ? inst : null;
		}
		function accumulateEnterLeaveListenersForEvent(
		  dispatchQueue,
		  event,
		  target,
		  common,
		  inCapturePhase
		) {
		  for (
		    var registrationName = event._reactName, listeners = [];
		    null !== target && target !== common;

		  ) {
		    var _instance3 = target,
		      alternate = _instance3.alternate,
		      stateNode = _instance3.stateNode;
		    _instance3 = _instance3.tag;
		    if (null !== alternate && alternate === common) break;
		    (5 !== _instance3 && 26 !== _instance3 && 27 !== _instance3) ||
		      null === stateNode ||
		      ((alternate = stateNode),
		      inCapturePhase
		        ? ((stateNode = getListener(target, registrationName)),
		          null != stateNode &&
		            listeners.unshift(
		              createDispatchListener(target, stateNode, alternate)
		            ))
		        : inCapturePhase ||
		          ((stateNode = getListener(target, registrationName)),
		          null != stateNode &&
		            listeners.push(
		              createDispatchListener(target, stateNode, alternate)
		            )));
		    target = target.return;
		  }
		  0 !== listeners.length &&
		    dispatchQueue.push({ event: event, listeners: listeners });
		}
		var NORMALIZE_NEWLINES_REGEX = /\r\n?/g,
		  NORMALIZE_NULL_AND_REPLACEMENT_REGEX = /\u0000|\uFFFD/g;
		function normalizeMarkupForTextOrAttribute(markup) {
		  return ("string" === typeof markup ? markup : "" + markup)
		    .replace(NORMALIZE_NEWLINES_REGEX, "\n")
		    .replace(NORMALIZE_NULL_AND_REPLACEMENT_REGEX, "");
		}
		function checkForUnmatchedText(serverText, clientText) {
		  clientText = normalizeMarkupForTextOrAttribute(clientText);
		  return normalizeMarkupForTextOrAttribute(serverText) === clientText ? true : false;
		}
		function noop$1() {}
		function setProp(domElement, tag, key, value, props, prevValue) {
		  switch (key) {
		    case "children":
		      "string" === typeof value
		        ? "body" === tag ||
		          ("textarea" === tag && "" === value) ||
		          setTextContent(domElement, value)
		        : ("number" === typeof value || "bigint" === typeof value) &&
		          "body" !== tag &&
		          setTextContent(domElement, "" + value);
		      break;
		    case "className":
		      setValueForKnownAttribute(domElement, "class", value);
		      break;
		    case "tabIndex":
		      setValueForKnownAttribute(domElement, "tabindex", value);
		      break;
		    case "dir":
		    case "role":
		    case "viewBox":
		    case "width":
		    case "height":
		      setValueForKnownAttribute(domElement, key, value);
		      break;
		    case "style":
		      setValueForStyles(domElement, value, prevValue);
		      break;
		    case "data":
		      if ("object" !== tag) {
		        setValueForKnownAttribute(domElement, "data", value);
		        break;
		      }
		    case "src":
		    case "href":
		      if ("" === value && ("a" !== tag || "href" !== key)) {
		        domElement.removeAttribute(key);
		        break;
		      }
		      if (
		        null == value ||
		        "function" === typeof value ||
		        "symbol" === typeof value ||
		        "boolean" === typeof value
		      ) {
		        domElement.removeAttribute(key);
		        break;
		      }
		      value = sanitizeURL("" + value);
		      domElement.setAttribute(key, value);
		      break;
		    case "action":
		    case "formAction":
		      if ("function" === typeof value) {
		        domElement.setAttribute(
		          key,
		          "javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')"
		        );
		        break;
		      } else
		        "function" === typeof prevValue &&
		          ("formAction" === key
		            ? ("input" !== tag &&
		                setProp(domElement, tag, "name", props.name, props, null),
		              setProp(
		                domElement,
		                tag,
		                "formEncType",
		                props.formEncType,
		                props,
		                null
		              ),
		              setProp(
		                domElement,
		                tag,
		                "formMethod",
		                props.formMethod,
		                props,
		                null
		              ),
		              setProp(
		                domElement,
		                tag,
		                "formTarget",
		                props.formTarget,
		                props,
		                null
		              ))
		            : (setProp(domElement, tag, "encType", props.encType, props, null),
		              setProp(domElement, tag, "method", props.method, props, null),
		              setProp(domElement, tag, "target", props.target, props, null)));
		      if (
		        null == value ||
		        "symbol" === typeof value ||
		        "boolean" === typeof value
		      ) {
		        domElement.removeAttribute(key);
		        break;
		      }
		      value = sanitizeURL("" + value);
		      domElement.setAttribute(key, value);
		      break;
		    case "onClick":
		      null != value && (domElement.onclick = noop$1);
		      break;
		    case "onScroll":
		      null != value && listenToNonDelegatedEvent("scroll", domElement);
		      break;
		    case "onScrollEnd":
		      null != value && listenToNonDelegatedEvent("scrollend", domElement);
		      break;
		    case "dangerouslySetInnerHTML":
		      if (null != value) {
		        if ("object" !== typeof value || !("__html" in value))
		          throw Error(formatProdErrorMessage(61));
		        key = value.__html;
		        if (null != key) {
		          if (null != props.children) throw Error(formatProdErrorMessage(60));
		          domElement.innerHTML = key;
		        }
		      }
		      break;
		    case "multiple":
		      domElement.multiple =
		        value && "function" !== typeof value && "symbol" !== typeof value;
		      break;
		    case "muted":
		      domElement.muted =
		        value && "function" !== typeof value && "symbol" !== typeof value;
		      break;
		    case "suppressContentEditableWarning":
		    case "suppressHydrationWarning":
		    case "defaultValue":
		    case "defaultChecked":
		    case "innerHTML":
		    case "ref":
		      break;
		    case "autoFocus":
		      break;
		    case "xlinkHref":
		      if (
		        null == value ||
		        "function" === typeof value ||
		        "boolean" === typeof value ||
		        "symbol" === typeof value
		      ) {
		        domElement.removeAttribute("xlink:href");
		        break;
		      }
		      key = sanitizeURL("" + value);
		      domElement.setAttributeNS(
		        "http://www.w3.org/1999/xlink",
		        "xlink:href",
		        key
		      );
		      break;
		    case "contentEditable":
		    case "spellCheck":
		    case "draggable":
		    case "value":
		    case "autoReverse":
		    case "externalResourcesRequired":
		    case "focusable":
		    case "preserveAlpha":
		      null != value && "function" !== typeof value && "symbol" !== typeof value
		        ? domElement.setAttribute(key, "" + value)
		        : domElement.removeAttribute(key);
		      break;
		    case "inert":
		    case "allowFullScreen":
		    case "async":
		    case "autoPlay":
		    case "controls":
		    case "default":
		    case "defer":
		    case "disabled":
		    case "disablePictureInPicture":
		    case "disableRemotePlayback":
		    case "formNoValidate":
		    case "hidden":
		    case "loop":
		    case "noModule":
		    case "noValidate":
		    case "open":
		    case "playsInline":
		    case "readOnly":
		    case "required":
		    case "reversed":
		    case "scoped":
		    case "seamless":
		    case "itemScope":
		      value && "function" !== typeof value && "symbol" !== typeof value
		        ? domElement.setAttribute(key, "")
		        : domElement.removeAttribute(key);
		      break;
		    case "capture":
		    case "download":
		      true === value
		        ? domElement.setAttribute(key, "")
		        : false !== value &&
		            null != value &&
		            "function" !== typeof value &&
		            "symbol" !== typeof value
		          ? domElement.setAttribute(key, value)
		          : domElement.removeAttribute(key);
		      break;
		    case "cols":
		    case "rows":
		    case "size":
		    case "span":
		      null != value &&
		      "function" !== typeof value &&
		      "symbol" !== typeof value &&
		      !isNaN(value) &&
		      1 <= value
		        ? domElement.setAttribute(key, value)
		        : domElement.removeAttribute(key);
		      break;
		    case "rowSpan":
		    case "start":
		      null == value ||
		      "function" === typeof value ||
		      "symbol" === typeof value ||
		      isNaN(value)
		        ? domElement.removeAttribute(key)
		        : domElement.setAttribute(key, value);
		      break;
		    case "popover":
		      listenToNonDelegatedEvent("beforetoggle", domElement);
		      listenToNonDelegatedEvent("toggle", domElement);
		      setValueForAttribute(domElement, "popover", value);
		      break;
		    case "xlinkActuate":
		      setValueForNamespacedAttribute(
		        domElement,
		        "http://www.w3.org/1999/xlink",
		        "xlink:actuate",
		        value
		      );
		      break;
		    case "xlinkArcrole":
		      setValueForNamespacedAttribute(
		        domElement,
		        "http://www.w3.org/1999/xlink",
		        "xlink:arcrole",
		        value
		      );
		      break;
		    case "xlinkRole":
		      setValueForNamespacedAttribute(
		        domElement,
		        "http://www.w3.org/1999/xlink",
		        "xlink:role",
		        value
		      );
		      break;
		    case "xlinkShow":
		      setValueForNamespacedAttribute(
		        domElement,
		        "http://www.w3.org/1999/xlink",
		        "xlink:show",
		        value
		      );
		      break;
		    case "xlinkTitle":
		      setValueForNamespacedAttribute(
		        domElement,
		        "http://www.w3.org/1999/xlink",
		        "xlink:title",
		        value
		      );
		      break;
		    case "xlinkType":
		      setValueForNamespacedAttribute(
		        domElement,
		        "http://www.w3.org/1999/xlink",
		        "xlink:type",
		        value
		      );
		      break;
		    case "xmlBase":
		      setValueForNamespacedAttribute(
		        domElement,
		        "http://www.w3.org/XML/1998/namespace",
		        "xml:base",
		        value
		      );
		      break;
		    case "xmlLang":
		      setValueForNamespacedAttribute(
		        domElement,
		        "http://www.w3.org/XML/1998/namespace",
		        "xml:lang",
		        value
		      );
		      break;
		    case "xmlSpace":
		      setValueForNamespacedAttribute(
		        domElement,
		        "http://www.w3.org/XML/1998/namespace",
		        "xml:space",
		        value
		      );
		      break;
		    case "is":
		      setValueForAttribute(domElement, "is", value);
		      break;
		    case "innerText":
		    case "textContent":
		      break;
		    default:
		      if (
		        !(2 < key.length) ||
		        ("o" !== key[0] && "O" !== key[0]) ||
		        ("n" !== key[1] && "N" !== key[1])
		      )
		        (key = aliases.get(key) || key),
		          setValueForAttribute(domElement, key, value);
		  }
		}
		function setPropOnCustomElement(domElement, tag, key, value, props, prevValue) {
		  switch (key) {
		    case "style":
		      setValueForStyles(domElement, value, prevValue);
		      break;
		    case "dangerouslySetInnerHTML":
		      if (null != value) {
		        if ("object" !== typeof value || !("__html" in value))
		          throw Error(formatProdErrorMessage(61));
		        key = value.__html;
		        if (null != key) {
		          if (null != props.children) throw Error(formatProdErrorMessage(60));
		          domElement.innerHTML = key;
		        }
		      }
		      break;
		    case "children":
		      "string" === typeof value
		        ? setTextContent(domElement, value)
		        : ("number" === typeof value || "bigint" === typeof value) &&
		          setTextContent(domElement, "" + value);
		      break;
		    case "onScroll":
		      null != value && listenToNonDelegatedEvent("scroll", domElement);
		      break;
		    case "onScrollEnd":
		      null != value && listenToNonDelegatedEvent("scrollend", domElement);
		      break;
		    case "onClick":
		      null != value && (domElement.onclick = noop$1);
		      break;
		    case "suppressContentEditableWarning":
		    case "suppressHydrationWarning":
		    case "innerHTML":
		    case "ref":
		      break;
		    case "innerText":
		    case "textContent":
		      break;
		    default:
		      if (!registrationNameDependencies.hasOwnProperty(key))
		        a: {
		          if (
		            "o" === key[0] &&
		            "n" === key[1] &&
		            ((props = key.endsWith("Capture")),
		            (tag = key.slice(2, props ? key.length - 7 : void 0)),
		            (prevValue = domElement[internalPropsKey] || null),
		            (prevValue = null != prevValue ? prevValue[key] : null),
		            "function" === typeof prevValue &&
		              domElement.removeEventListener(tag, prevValue, props),
		            "function" === typeof value)
		          ) {
		            "function" !== typeof prevValue &&
		              null !== prevValue &&
		              (key in domElement
		                ? (domElement[key] = null)
		                : domElement.hasAttribute(key) &&
		                  domElement.removeAttribute(key));
		            domElement.addEventListener(tag, value, props);
		            break a;
		          }
		          key in domElement
		            ? (domElement[key] = value)
		            : true === value
		              ? domElement.setAttribute(key, "")
		              : setValueForAttribute(domElement, key, value);
		        }
		  }
		}
		function setInitialProperties(domElement, tag, props) {
		  switch (tag) {
		    case "div":
		    case "span":
		    case "svg":
		    case "path":
		    case "a":
		    case "g":
		    case "p":
		    case "li":
		      break;
		    case "img":
		      listenToNonDelegatedEvent("error", domElement);
		      listenToNonDelegatedEvent("load", domElement);
		      var hasSrc = false,
		        hasSrcSet = false,
		        propKey;
		      for (propKey in props)
		        if (props.hasOwnProperty(propKey)) {
		          var propValue = props[propKey];
		          if (null != propValue)
		            switch (propKey) {
		              case "src":
		                hasSrc = true;
		                break;
		              case "srcSet":
		                hasSrcSet = true;
		                break;
		              case "children":
		              case "dangerouslySetInnerHTML":
		                throw Error(formatProdErrorMessage(137, tag));
		              default:
		                setProp(domElement, tag, propKey, propValue, props, null);
		            }
		        }
		      hasSrcSet &&
		        setProp(domElement, tag, "srcSet", props.srcSet, props, null);
		      hasSrc && setProp(domElement, tag, "src", props.src, props, null);
		      return;
		    case "input":
		      listenToNonDelegatedEvent("invalid", domElement);
		      var defaultValue = (propKey = propValue = hasSrcSet = null),
		        checked = null,
		        defaultChecked = null;
		      for (hasSrc in props)
		        if (props.hasOwnProperty(hasSrc)) {
		          var propValue$188 = props[hasSrc];
		          if (null != propValue$188)
		            switch (hasSrc) {
		              case "name":
		                hasSrcSet = propValue$188;
		                break;
		              case "type":
		                propValue = propValue$188;
		                break;
		              case "checked":
		                checked = propValue$188;
		                break;
		              case "defaultChecked":
		                defaultChecked = propValue$188;
		                break;
		              case "value":
		                propKey = propValue$188;
		                break;
		              case "defaultValue":
		                defaultValue = propValue$188;
		                break;
		              case "children":
		              case "dangerouslySetInnerHTML":
		                if (null != propValue$188)
		                  throw Error(formatProdErrorMessage(137, tag));
		                break;
		              default:
		                setProp(domElement, tag, hasSrc, propValue$188, props, null);
		            }
		        }
		      initInput(
		        domElement,
		        propKey,
		        defaultValue,
		        checked,
		        defaultChecked,
		        propValue,
		        hasSrcSet,
		        false
		      );
		      track(domElement);
		      return;
		    case "select":
		      listenToNonDelegatedEvent("invalid", domElement);
		      hasSrc = propValue = propKey = null;
		      for (hasSrcSet in props)
		        if (
		          props.hasOwnProperty(hasSrcSet) &&
		          ((defaultValue = props[hasSrcSet]), null != defaultValue)
		        )
		          switch (hasSrcSet) {
		            case "value":
		              propKey = defaultValue;
		              break;
		            case "defaultValue":
		              propValue = defaultValue;
		              break;
		            case "multiple":
		              hasSrc = defaultValue;
		            default:
		              setProp(domElement, tag, hasSrcSet, defaultValue, props, null);
		          }
		      tag = propKey;
		      props = propValue;
		      domElement.multiple = !!hasSrc;
		      null != tag
		        ? updateOptions(domElement, !!hasSrc, tag, false)
		        : null != props && updateOptions(domElement, !!hasSrc, props, true);
		      return;
		    case "textarea":
		      listenToNonDelegatedEvent("invalid", domElement);
		      propKey = hasSrcSet = hasSrc = null;
		      for (propValue in props)
		        if (
		          props.hasOwnProperty(propValue) &&
		          ((defaultValue = props[propValue]), null != defaultValue)
		        )
		          switch (propValue) {
		            case "value":
		              hasSrc = defaultValue;
		              break;
		            case "defaultValue":
		              hasSrcSet = defaultValue;
		              break;
		            case "children":
		              propKey = defaultValue;
		              break;
		            case "dangerouslySetInnerHTML":
		              if (null != defaultValue) throw Error(formatProdErrorMessage(91));
		              break;
		            default:
		              setProp(domElement, tag, propValue, defaultValue, props, null);
		          }
		      initTextarea(domElement, hasSrc, hasSrcSet, propKey);
		      track(domElement);
		      return;
		    case "option":
		      for (checked in props)
		        if (
		          props.hasOwnProperty(checked) &&
		          ((hasSrc = props[checked]), null != hasSrc)
		        )
		          switch (checked) {
		            case "selected":
		              domElement.selected =
		                hasSrc &&
		                "function" !== typeof hasSrc &&
		                "symbol" !== typeof hasSrc;
		              break;
		            default:
		              setProp(domElement, tag, checked, hasSrc, props, null);
		          }
		      return;
		    case "dialog":
		      listenToNonDelegatedEvent("beforetoggle", domElement);
		      listenToNonDelegatedEvent("toggle", domElement);
		      listenToNonDelegatedEvent("cancel", domElement);
		      listenToNonDelegatedEvent("close", domElement);
		      break;
		    case "iframe":
		    case "object":
		      listenToNonDelegatedEvent("load", domElement);
		      break;
		    case "video":
		    case "audio":
		      for (hasSrc = 0; hasSrc < mediaEventTypes.length; hasSrc++)
		        listenToNonDelegatedEvent(mediaEventTypes[hasSrc], domElement);
		      break;
		    case "image":
		      listenToNonDelegatedEvent("error", domElement);
		      listenToNonDelegatedEvent("load", domElement);
		      break;
		    case "details":
		      listenToNonDelegatedEvent("toggle", domElement);
		      break;
		    case "embed":
		    case "source":
		    case "link":
		      listenToNonDelegatedEvent("error", domElement),
		        listenToNonDelegatedEvent("load", domElement);
		    case "area":
		    case "base":
		    case "br":
		    case "col":
		    case "hr":
		    case "keygen":
		    case "meta":
		    case "param":
		    case "track":
		    case "wbr":
		    case "menuitem":
		      for (defaultChecked in props)
		        if (
		          props.hasOwnProperty(defaultChecked) &&
		          ((hasSrc = props[defaultChecked]), null != hasSrc)
		        )
		          switch (defaultChecked) {
		            case "children":
		            case "dangerouslySetInnerHTML":
		              throw Error(formatProdErrorMessage(137, tag));
		            default:
		              setProp(domElement, tag, defaultChecked, hasSrc, props, null);
		          }
		      return;
		    default:
		      if (isCustomElement(tag)) {
		        for (propValue$188 in props)
		          props.hasOwnProperty(propValue$188) &&
		            ((hasSrc = props[propValue$188]),
		            void 0 !== hasSrc &&
		              setPropOnCustomElement(
		                domElement,
		                tag,
		                propValue$188,
		                hasSrc,
		                props,
		                void 0
		              ));
		        return;
		      }
		  }
		  for (defaultValue in props)
		    props.hasOwnProperty(defaultValue) &&
		      ((hasSrc = props[defaultValue]),
		      null != hasSrc &&
		        setProp(domElement, tag, defaultValue, hasSrc, props, null));
		}
		function updateProperties(domElement, tag, lastProps, nextProps) {
		  switch (tag) {
		    case "div":
		    case "span":
		    case "svg":
		    case "path":
		    case "a":
		    case "g":
		    case "p":
		    case "li":
		      break;
		    case "input":
		      var name = null,
		        type = null,
		        value = null,
		        defaultValue = null,
		        lastDefaultValue = null,
		        checked = null,
		        defaultChecked = null;
		      for (propKey in lastProps) {
		        var lastProp = lastProps[propKey];
		        if (lastProps.hasOwnProperty(propKey) && null != lastProp)
		          switch (propKey) {
		            case "checked":
		              break;
		            case "value":
		              break;
		            case "defaultValue":
		              lastDefaultValue = lastProp;
		            default:
		              nextProps.hasOwnProperty(propKey) ||
		                setProp(domElement, tag, propKey, null, nextProps, lastProp);
		          }
		      }
		      for (var propKey$205 in nextProps) {
		        var propKey = nextProps[propKey$205];
		        lastProp = lastProps[propKey$205];
		        if (
		          nextProps.hasOwnProperty(propKey$205) &&
		          (null != propKey || null != lastProp)
		        )
		          switch (propKey$205) {
		            case "type":
		              type = propKey;
		              break;
		            case "name":
		              name = propKey;
		              break;
		            case "checked":
		              checked = propKey;
		              break;
		            case "defaultChecked":
		              defaultChecked = propKey;
		              break;
		            case "value":
		              value = propKey;
		              break;
		            case "defaultValue":
		              defaultValue = propKey;
		              break;
		            case "children":
		            case "dangerouslySetInnerHTML":
		              if (null != propKey)
		                throw Error(formatProdErrorMessage(137, tag));
		              break;
		            default:
		              propKey !== lastProp &&
		                setProp(
		                  domElement,
		                  tag,
		                  propKey$205,
		                  propKey,
		                  nextProps,
		                  lastProp
		                );
		          }
		      }
		      updateInput(
		        domElement,
		        value,
		        defaultValue,
		        lastDefaultValue,
		        checked,
		        defaultChecked,
		        type,
		        name
		      );
		      return;
		    case "select":
		      propKey = value = defaultValue = propKey$205 = null;
		      for (type in lastProps)
		        if (
		          ((lastDefaultValue = lastProps[type]),
		          lastProps.hasOwnProperty(type) && null != lastDefaultValue)
		        )
		          switch (type) {
		            case "value":
		              break;
		            case "multiple":
		              propKey = lastDefaultValue;
		            default:
		              nextProps.hasOwnProperty(type) ||
		                setProp(
		                  domElement,
		                  tag,
		                  type,
		                  null,
		                  nextProps,
		                  lastDefaultValue
		                );
		          }
		      for (name in nextProps)
		        if (
		          ((type = nextProps[name]),
		          (lastDefaultValue = lastProps[name]),
		          nextProps.hasOwnProperty(name) &&
		            (null != type || null != lastDefaultValue))
		        )
		          switch (name) {
		            case "value":
		              propKey$205 = type;
		              break;
		            case "defaultValue":
		              defaultValue = type;
		              break;
		            case "multiple":
		              value = type;
		            default:
		              type !== lastDefaultValue &&
		                setProp(
		                  domElement,
		                  tag,
		                  name,
		                  type,
		                  nextProps,
		                  lastDefaultValue
		                );
		          }
		      tag = defaultValue;
		      lastProps = value;
		      nextProps = propKey;
		      null != propKey$205
		        ? updateOptions(domElement, !!lastProps, propKey$205, false)
		        : !!nextProps !== !!lastProps &&
		          (null != tag
		            ? updateOptions(domElement, !!lastProps, tag, true)
		            : updateOptions(domElement, !!lastProps, lastProps ? [] : "", false));
		      return;
		    case "textarea":
		      propKey = propKey$205 = null;
		      for (defaultValue in lastProps)
		        if (
		          ((name = lastProps[defaultValue]),
		          lastProps.hasOwnProperty(defaultValue) &&
		            null != name &&
		            !nextProps.hasOwnProperty(defaultValue))
		        )
		          switch (defaultValue) {
		            case "value":
		              break;
		            case "children":
		              break;
		            default:
		              setProp(domElement, tag, defaultValue, null, nextProps, name);
		          }
		      for (value in nextProps)
		        if (
		          ((name = nextProps[value]),
		          (type = lastProps[value]),
		          nextProps.hasOwnProperty(value) && (null != name || null != type))
		        )
		          switch (value) {
		            case "value":
		              propKey$205 = name;
		              break;
		            case "defaultValue":
		              propKey = name;
		              break;
		            case "children":
		              break;
		            case "dangerouslySetInnerHTML":
		              if (null != name) throw Error(formatProdErrorMessage(91));
		              break;
		            default:
		              name !== type &&
		                setProp(domElement, tag, value, name, nextProps, type);
		          }
		      updateTextarea(domElement, propKey$205, propKey);
		      return;
		    case "option":
		      for (var propKey$221 in lastProps)
		        if (
		          ((propKey$205 = lastProps[propKey$221]),
		          lastProps.hasOwnProperty(propKey$221) &&
		            null != propKey$205 &&
		            !nextProps.hasOwnProperty(propKey$221))
		        )
		          switch (propKey$221) {
		            case "selected":
		              domElement.selected = false;
		              break;
		            default:
		              setProp(
		                domElement,
		                tag,
		                propKey$221,
		                null,
		                nextProps,
		                propKey$205
		              );
		          }
		      for (lastDefaultValue in nextProps)
		        if (
		          ((propKey$205 = nextProps[lastDefaultValue]),
		          (propKey = lastProps[lastDefaultValue]),
		          nextProps.hasOwnProperty(lastDefaultValue) &&
		            propKey$205 !== propKey &&
		            (null != propKey$205 || null != propKey))
		        )
		          switch (lastDefaultValue) {
		            case "selected":
		              domElement.selected =
		                propKey$205 &&
		                "function" !== typeof propKey$205 &&
		                "symbol" !== typeof propKey$205;
		              break;
		            default:
		              setProp(
		                domElement,
		                tag,
		                lastDefaultValue,
		                propKey$205,
		                nextProps,
		                propKey
		              );
		          }
		      return;
		    case "img":
		    case "link":
		    case "area":
		    case "base":
		    case "br":
		    case "col":
		    case "embed":
		    case "hr":
		    case "keygen":
		    case "meta":
		    case "param":
		    case "source":
		    case "track":
		    case "wbr":
		    case "menuitem":
		      for (var propKey$226 in lastProps)
		        (propKey$205 = lastProps[propKey$226]),
		          lastProps.hasOwnProperty(propKey$226) &&
		            null != propKey$205 &&
		            !nextProps.hasOwnProperty(propKey$226) &&
		            setProp(domElement, tag, propKey$226, null, nextProps, propKey$205);
		      for (checked in nextProps)
		        if (
		          ((propKey$205 = nextProps[checked]),
		          (propKey = lastProps[checked]),
		          nextProps.hasOwnProperty(checked) &&
		            propKey$205 !== propKey &&
		            (null != propKey$205 || null != propKey))
		        )
		          switch (checked) {
		            case "children":
		            case "dangerouslySetInnerHTML":
		              if (null != propKey$205)
		                throw Error(formatProdErrorMessage(137, tag));
		              break;
		            default:
		              setProp(
		                domElement,
		                tag,
		                checked,
		                propKey$205,
		                nextProps,
		                propKey
		              );
		          }
		      return;
		    default:
		      if (isCustomElement(tag)) {
		        for (var propKey$231 in lastProps)
		          (propKey$205 = lastProps[propKey$231]),
		            lastProps.hasOwnProperty(propKey$231) &&
		              void 0 !== propKey$205 &&
		              !nextProps.hasOwnProperty(propKey$231) &&
		              setPropOnCustomElement(
		                domElement,
		                tag,
		                propKey$231,
		                void 0,
		                nextProps,
		                propKey$205
		              );
		        for (defaultChecked in nextProps)
		          (propKey$205 = nextProps[defaultChecked]),
		            (propKey = lastProps[defaultChecked]),
		            !nextProps.hasOwnProperty(defaultChecked) ||
		              propKey$205 === propKey ||
		              (void 0 === propKey$205 && void 0 === propKey) ||
		              setPropOnCustomElement(
		                domElement,
		                tag,
		                defaultChecked,
		                propKey$205,
		                nextProps,
		                propKey
		              );
		        return;
		      }
		  }
		  for (var propKey$236 in lastProps)
		    (propKey$205 = lastProps[propKey$236]),
		      lastProps.hasOwnProperty(propKey$236) &&
		        null != propKey$205 &&
		        !nextProps.hasOwnProperty(propKey$236) &&
		        setProp(domElement, tag, propKey$236, null, nextProps, propKey$205);
		  for (lastProp in nextProps)
		    (propKey$205 = nextProps[lastProp]),
		      (propKey = lastProps[lastProp]),
		      !nextProps.hasOwnProperty(lastProp) ||
		        propKey$205 === propKey ||
		        (null == propKey$205 && null == propKey) ||
		        setProp(domElement, tag, lastProp, propKey$205, nextProps, propKey);
		}
		var eventsEnabled = null,
		  selectionInformation = null;
		function getOwnerDocumentFromRootContainer(rootContainerElement) {
		  return 9 === rootContainerElement.nodeType
		    ? rootContainerElement
		    : rootContainerElement.ownerDocument;
		}
		function getOwnHostContext(namespaceURI) {
		  switch (namespaceURI) {
		    case "http://www.w3.org/2000/svg":
		      return 1;
		    case "http://www.w3.org/1998/Math/MathML":
		      return 2;
		    default:
		      return 0;
		  }
		}
		function getChildHostContextProd(parentNamespace, type) {
		  if (0 === parentNamespace)
		    switch (type) {
		      case "svg":
		        return 1;
		      case "math":
		        return 2;
		      default:
		        return 0;
		    }
		  return 1 === parentNamespace && "foreignObject" === type
		    ? 0
		    : parentNamespace;
		}
		function shouldSetTextContent(type, props) {
		  return (
		    "textarea" === type ||
		    "noscript" === type ||
		    "string" === typeof props.children ||
		    "number" === typeof props.children ||
		    "bigint" === typeof props.children ||
		    ("object" === typeof props.dangerouslySetInnerHTML &&
		      null !== props.dangerouslySetInnerHTML &&
		      null != props.dangerouslySetInnerHTML.__html)
		  );
		}
		var currentPopstateTransitionEvent = null;
		function shouldAttemptEagerTransition() {
		  var event = window.event;
		  if (event && "popstate" === event.type) {
		    if (event === currentPopstateTransitionEvent) return false;
		    currentPopstateTransitionEvent = event;
		    return true;
		  }
		  currentPopstateTransitionEvent = null;
		  return false;
		}
		var scheduleTimeout = "function" === typeof setTimeout ? setTimeout : void 0,
		  cancelTimeout = "function" === typeof clearTimeout ? clearTimeout : void 0,
		  localPromise = "function" === typeof Promise ? Promise : void 0,
		  scheduleMicrotask =
		    "function" === typeof queueMicrotask
		      ? queueMicrotask
		      : "undefined" !== typeof localPromise
		        ? function (callback) {
		            return localPromise
		              .resolve(null)
		              .then(callback)
		              .catch(handleErrorInNextTick);
		          }
		        : scheduleTimeout;
		function handleErrorInNextTick(error) {
		  setTimeout(function () {
		    throw error;
		  });
		}
		function isSingletonScope(type) {
		  return "head" === type;
		}
		function clearSuspenseBoundary(parentInstance, suspenseInstance) {
		  var node = suspenseInstance,
		    possiblePreambleContribution = 0,
		    depth = 0;
		  do {
		    var nextNode = node.nextSibling;
		    parentInstance.removeChild(node);
		    if (nextNode && 8 === nextNode.nodeType)
		      if (((node = nextNode.data), "/$" === node)) {
		        if (
		          0 < possiblePreambleContribution &&
		          8 > possiblePreambleContribution
		        ) {
		          node = possiblePreambleContribution;
		          var ownerDocument = parentInstance.ownerDocument;
		          node & 1 && releaseSingletonInstance(ownerDocument.documentElement);
		          node & 2 && releaseSingletonInstance(ownerDocument.body);
		          if (node & 4)
		            for (
		              node = ownerDocument.head,
		                releaseSingletonInstance(node),
		                ownerDocument = node.firstChild;
		              ownerDocument;

		            ) {
		              var nextNode$jscomp$0 = ownerDocument.nextSibling,
		                nodeName = ownerDocument.nodeName;
		              ownerDocument[internalHoistableMarker] ||
		                "SCRIPT" === nodeName ||
		                "STYLE" === nodeName ||
		                ("LINK" === nodeName &&
		                  "stylesheet" === ownerDocument.rel.toLowerCase()) ||
		                node.removeChild(ownerDocument);
		              ownerDocument = nextNode$jscomp$0;
		            }
		        }
		        if (0 === depth) {
		          parentInstance.removeChild(nextNode);
		          retryIfBlockedOn(suspenseInstance);
		          return;
		        }
		        depth--;
		      } else
		        "$" === node || "$?" === node || "$!" === node
		          ? depth++
		          : (possiblePreambleContribution = node.charCodeAt(0) - 48);
		    else possiblePreambleContribution = 0;
		    node = nextNode;
		  } while (node);
		  retryIfBlockedOn(suspenseInstance);
		}
		function clearContainerSparingly(container) {
		  var nextNode = container.firstChild;
		  nextNode && 10 === nextNode.nodeType && (nextNode = nextNode.nextSibling);
		  for (; nextNode; ) {
		    var node = nextNode;
		    nextNode = nextNode.nextSibling;
		    switch (node.nodeName) {
		      case "HTML":
		      case "HEAD":
		      case "BODY":
		        clearContainerSparingly(node);
		        detachDeletedInstance(node);
		        continue;
		      case "SCRIPT":
		      case "STYLE":
		        continue;
		      case "LINK":
		        if ("stylesheet" === node.rel.toLowerCase()) continue;
		    }
		    container.removeChild(node);
		  }
		}
		function canHydrateInstance(instance, type, props, inRootOrSingleton) {
		  for (; 1 === instance.nodeType; ) {
		    var anyProps = props;
		    if (instance.nodeName.toLowerCase() !== type.toLowerCase()) {
		      if (
		        !inRootOrSingleton &&
		        ("INPUT" !== instance.nodeName || "hidden" !== instance.type)
		      )
		        break;
		    } else if (!inRootOrSingleton)
		      if ("input" === type && "hidden" === instance.type) {
		        var name = null == anyProps.name ? null : "" + anyProps.name;
		        if (
		          "hidden" === anyProps.type &&
		          instance.getAttribute("name") === name
		        )
		          return instance;
		      } else return instance;
		    else if (!instance[internalHoistableMarker])
		      switch (type) {
		        case "meta":
		          if (!instance.hasAttribute("itemprop")) break;
		          return instance;
		        case "link":
		          name = instance.getAttribute("rel");
		          if ("stylesheet" === name && instance.hasAttribute("data-precedence"))
		            break;
		          else if (
		            name !== anyProps.rel ||
		            instance.getAttribute("href") !==
		              (null == anyProps.href || "" === anyProps.href
		                ? null
		                : anyProps.href) ||
		            instance.getAttribute("crossorigin") !==
		              (null == anyProps.crossOrigin ? null : anyProps.crossOrigin) ||
		            instance.getAttribute("title") !==
		              (null == anyProps.title ? null : anyProps.title)
		          )
		            break;
		          return instance;
		        case "style":
		          if (instance.hasAttribute("data-precedence")) break;
		          return instance;
		        case "script":
		          name = instance.getAttribute("src");
		          if (
		            (name !== (null == anyProps.src ? null : anyProps.src) ||
		              instance.getAttribute("type") !==
		                (null == anyProps.type ? null : anyProps.type) ||
		              instance.getAttribute("crossorigin") !==
		                (null == anyProps.crossOrigin ? null : anyProps.crossOrigin)) &&
		            name &&
		            instance.hasAttribute("async") &&
		            !instance.hasAttribute("itemprop")
		          )
		            break;
		          return instance;
		        default:
		          return instance;
		      }
		    instance = getNextHydratable(instance.nextSibling);
		    if (null === instance) break;
		  }
		  return null;
		}
		function canHydrateTextInstance(instance, text, inRootOrSingleton) {
		  if ("" === text) return null;
		  for (; 3 !== instance.nodeType; ) {
		    if (
		      (1 !== instance.nodeType ||
		        "INPUT" !== instance.nodeName ||
		        "hidden" !== instance.type) &&
		      !inRootOrSingleton
		    )
		      return null;
		    instance = getNextHydratable(instance.nextSibling);
		    if (null === instance) return null;
		  }
		  return instance;
		}
		function isSuspenseInstanceFallback(instance) {
		  return (
		    "$!" === instance.data ||
		    ("$?" === instance.data && "complete" === instance.ownerDocument.readyState)
		  );
		}
		function registerSuspenseInstanceRetry(instance, callback) {
		  var ownerDocument = instance.ownerDocument;
		  if ("$?" !== instance.data || "complete" === ownerDocument.readyState)
		    callback();
		  else {
		    var listener = function () {
		      callback();
		      ownerDocument.removeEventListener("DOMContentLoaded", listener);
		    };
		    ownerDocument.addEventListener("DOMContentLoaded", listener);
		    instance._reactRetry = listener;
		  }
		}
		function getNextHydratable(node) {
		  for (; null != node; node = node.nextSibling) {
		    var nodeType = node.nodeType;
		    if (1 === nodeType || 3 === nodeType) break;
		    if (8 === nodeType) {
		      nodeType = node.data;
		      if (
		        "$" === nodeType ||
		        "$!" === nodeType ||
		        "$?" === nodeType ||
		        "F!" === nodeType ||
		        "F" === nodeType
		      )
		        break;
		      if ("/$" === nodeType) return null;
		    }
		  }
		  return node;
		}
		var previousHydratableOnEnteringScopedSingleton = null;
		function getParentSuspenseInstance(targetInstance) {
		  targetInstance = targetInstance.previousSibling;
		  for (var depth = 0; targetInstance; ) {
		    if (8 === targetInstance.nodeType) {
		      var data = targetInstance.data;
		      if ("$" === data || "$!" === data || "$?" === data) {
		        if (0 === depth) return targetInstance;
		        depth--;
		      } else "/$" === data && depth++;
		    }
		    targetInstance = targetInstance.previousSibling;
		  }
		  return null;
		}
		function resolveSingletonInstance(type, props, rootContainerInstance) {
		  props = getOwnerDocumentFromRootContainer(rootContainerInstance);
		  switch (type) {
		    case "html":
		      type = props.documentElement;
		      if (!type) throw Error(formatProdErrorMessage(452));
		      return type;
		    case "head":
		      type = props.head;
		      if (!type) throw Error(formatProdErrorMessage(453));
		      return type;
		    case "body":
		      type = props.body;
		      if (!type) throw Error(formatProdErrorMessage(454));
		      return type;
		    default:
		      throw Error(formatProdErrorMessage(451));
		  }
		}
		function releaseSingletonInstance(instance) {
		  for (var attributes = instance.attributes; attributes.length; )
		    instance.removeAttributeNode(attributes[0]);
		  detachDeletedInstance(instance);
		}
		var preloadPropsMap = new Map(),
		  preconnectsSet = new Set();
		function getHoistableRoot(container) {
		  return "function" === typeof container.getRootNode
		    ? container.getRootNode()
		    : 9 === container.nodeType
		      ? container
		      : container.ownerDocument;
		}
		var previousDispatcher = ReactDOMSharedInternals.d;
		ReactDOMSharedInternals.d = {
		  f: flushSyncWork,
		  r: requestFormReset,
		  D: prefetchDNS,
		  C: preconnect,
		  L: preload,
		  m: preloadModule,
		  X: preinitScript,
		  S: preinitStyle,
		  M: preinitModuleScript
		};
		function flushSyncWork() {
		  var previousWasRendering = previousDispatcher.f(),
		    wasRendering = flushSyncWork$1();
		  return previousWasRendering || wasRendering;
		}
		function requestFormReset(form) {
		  var formInst = getInstanceFromNode(form);
		  null !== formInst && 5 === formInst.tag && "form" === formInst.type
		    ? requestFormReset$1(formInst)
		    : previousDispatcher.r(form);
		}
		var globalDocument = "undefined" === typeof document ? null : document;
		function preconnectAs(rel, href, crossOrigin) {
		  var ownerDocument = globalDocument;
		  if (ownerDocument && "string" === typeof href && href) {
		    var limitedEscapedHref =
		      escapeSelectorAttributeValueInsideDoubleQuotes(href);
		    limitedEscapedHref =
		      'link[rel="' + rel + '"][href="' + limitedEscapedHref + '"]';
		    "string" === typeof crossOrigin &&
		      (limitedEscapedHref += '[crossorigin="' + crossOrigin + '"]');
		    preconnectsSet.has(limitedEscapedHref) ||
		      (preconnectsSet.add(limitedEscapedHref),
		      (rel = { rel: rel, crossOrigin: crossOrigin, href: href }),
		      null === ownerDocument.querySelector(limitedEscapedHref) &&
		        ((href = ownerDocument.createElement("link")),
		        setInitialProperties(href, "link", rel),
		        markNodeAsHoistable(href),
		        ownerDocument.head.appendChild(href)));
		  }
		}
		function prefetchDNS(href) {
		  previousDispatcher.D(href);
		  preconnectAs("dns-prefetch", href, null);
		}
		function preconnect(href, crossOrigin) {
		  previousDispatcher.C(href, crossOrigin);
		  preconnectAs("preconnect", href, crossOrigin);
		}
		function preload(href, as, options) {
		  previousDispatcher.L(href, as, options);
		  var ownerDocument = globalDocument;
		  if (ownerDocument && href && as) {
		    var preloadSelector =
		      'link[rel="preload"][as="' +
		      escapeSelectorAttributeValueInsideDoubleQuotes(as) +
		      '"]';
		    "image" === as
		      ? options && options.imageSrcSet
		        ? ((preloadSelector +=
		            '[imagesrcset="' +
		            escapeSelectorAttributeValueInsideDoubleQuotes(
		              options.imageSrcSet
		            ) +
		            '"]'),
		          "string" === typeof options.imageSizes &&
		            (preloadSelector +=
		              '[imagesizes="' +
		              escapeSelectorAttributeValueInsideDoubleQuotes(
		                options.imageSizes
		              ) +
		              '"]'))
		        : (preloadSelector +=
		            '[href="' +
		            escapeSelectorAttributeValueInsideDoubleQuotes(href) +
		            '"]')
		      : (preloadSelector +=
		          '[href="' +
		          escapeSelectorAttributeValueInsideDoubleQuotes(href) +
		          '"]');
		    var key = preloadSelector;
		    switch (as) {
		      case "style":
		        key = getStyleKey(href);
		        break;
		      case "script":
		        key = getScriptKey(href);
		    }
		    preloadPropsMap.has(key) ||
		      ((href = assign(
		        {
		          rel: "preload",
		          href:
		            "image" === as && options && options.imageSrcSet ? void 0 : href,
		          as: as
		        },
		        options
		      )),
		      preloadPropsMap.set(key, href),
		      null !== ownerDocument.querySelector(preloadSelector) ||
		        ("style" === as &&
		          ownerDocument.querySelector(getStylesheetSelectorFromKey(key))) ||
		        ("script" === as &&
		          ownerDocument.querySelector(getScriptSelectorFromKey(key))) ||
		        ((as = ownerDocument.createElement("link")),
		        setInitialProperties(as, "link", href),
		        markNodeAsHoistable(as),
		        ownerDocument.head.appendChild(as)));
		  }
		}
		function preloadModule(href, options) {
		  previousDispatcher.m(href, options);
		  var ownerDocument = globalDocument;
		  if (ownerDocument && href) {
		    var as = options && "string" === typeof options.as ? options.as : "script",
		      preloadSelector =
		        'link[rel="modulepreload"][as="' +
		        escapeSelectorAttributeValueInsideDoubleQuotes(as) +
		        '"][href="' +
		        escapeSelectorAttributeValueInsideDoubleQuotes(href) +
		        '"]',
		      key = preloadSelector;
		    switch (as) {
		      case "audioworklet":
		      case "paintworklet":
		      case "serviceworker":
		      case "sharedworker":
		      case "worker":
		      case "script":
		        key = getScriptKey(href);
		    }
		    if (
		      !preloadPropsMap.has(key) &&
		      ((href = assign({ rel: "modulepreload", href: href }, options)),
		      preloadPropsMap.set(key, href),
		      null === ownerDocument.querySelector(preloadSelector))
		    ) {
		      switch (as) {
		        case "audioworklet":
		        case "paintworklet":
		        case "serviceworker":
		        case "sharedworker":
		        case "worker":
		        case "script":
		          if (ownerDocument.querySelector(getScriptSelectorFromKey(key)))
		            return;
		      }
		      as = ownerDocument.createElement("link");
		      setInitialProperties(as, "link", href);
		      markNodeAsHoistable(as);
		      ownerDocument.head.appendChild(as);
		    }
		  }
		}
		function preinitStyle(href, precedence, options) {
		  previousDispatcher.S(href, precedence, options);
		  var ownerDocument = globalDocument;
		  if (ownerDocument && href) {
		    var styles = getResourcesFromRoot(ownerDocument).hoistableStyles,
		      key = getStyleKey(href);
		    precedence = precedence || "default";
		    var resource = styles.get(key);
		    if (!resource) {
		      var state = { loading: 0, preload: null };
		      if (
		        (resource = ownerDocument.querySelector(
		          getStylesheetSelectorFromKey(key)
		        ))
		      )
		        state.loading = 5;
		      else {
		        href = assign(
		          { rel: "stylesheet", href: href, "data-precedence": precedence },
		          options
		        );
		        (options = preloadPropsMap.get(key)) &&
		          adoptPreloadPropsForStylesheet(href, options);
		        var link = (resource = ownerDocument.createElement("link"));
		        markNodeAsHoistable(link);
		        setInitialProperties(link, "link", href);
		        link._p = new Promise(function (resolve, reject) {
		          link.onload = resolve;
		          link.onerror = reject;
		        });
		        link.addEventListener("load", function () {
		          state.loading |= 1;
		        });
		        link.addEventListener("error", function () {
		          state.loading |= 2;
		        });
		        state.loading |= 4;
		        insertStylesheet(resource, precedence, ownerDocument);
		      }
		      resource = {
		        type: "stylesheet",
		        instance: resource,
		        count: 1,
		        state: state
		      };
		      styles.set(key, resource);
		    }
		  }
		}
		function preinitScript(src, options) {
		  previousDispatcher.X(src, options);
		  var ownerDocument = globalDocument;
		  if (ownerDocument && src) {
		    var scripts = getResourcesFromRoot(ownerDocument).hoistableScripts,
		      key = getScriptKey(src),
		      resource = scripts.get(key);
		    resource ||
		      ((resource = ownerDocument.querySelector(getScriptSelectorFromKey(key))),
		      resource ||
		        ((src = assign({ src: src, async: true }, options)),
		        (options = preloadPropsMap.get(key)) &&
		          adoptPreloadPropsForScript(src, options),
		        (resource = ownerDocument.createElement("script")),
		        markNodeAsHoistable(resource),
		        setInitialProperties(resource, "link", src),
		        ownerDocument.head.appendChild(resource)),
		      (resource = {
		        type: "script",
		        instance: resource,
		        count: 1,
		        state: null
		      }),
		      scripts.set(key, resource));
		  }
		}
		function preinitModuleScript(src, options) {
		  previousDispatcher.M(src, options);
		  var ownerDocument = globalDocument;
		  if (ownerDocument && src) {
		    var scripts = getResourcesFromRoot(ownerDocument).hoistableScripts,
		      key = getScriptKey(src),
		      resource = scripts.get(key);
		    resource ||
		      ((resource = ownerDocument.querySelector(getScriptSelectorFromKey(key))),
		      resource ||
		        ((src = assign({ src: src, async: true, type: "module" }, options)),
		        (options = preloadPropsMap.get(key)) &&
		          adoptPreloadPropsForScript(src, options),
		        (resource = ownerDocument.createElement("script")),
		        markNodeAsHoistable(resource),
		        setInitialProperties(resource, "link", src),
		        ownerDocument.head.appendChild(resource)),
		      (resource = {
		        type: "script",
		        instance: resource,
		        count: 1,
		        state: null
		      }),
		      scripts.set(key, resource));
		  }
		}
		function getResource(type, currentProps, pendingProps, currentResource) {
		  var JSCompiler_inline_result = (JSCompiler_inline_result =
		    rootInstanceStackCursor.current)
		    ? getHoistableRoot(JSCompiler_inline_result)
		    : null;
		  if (!JSCompiler_inline_result) throw Error(formatProdErrorMessage(446));
		  switch (type) {
		    case "meta":
		    case "title":
		      return null;
		    case "style":
		      return "string" === typeof pendingProps.precedence &&
		        "string" === typeof pendingProps.href
		        ? ((currentProps = getStyleKey(pendingProps.href)),
		          (pendingProps = getResourcesFromRoot(
		            JSCompiler_inline_result
		          ).hoistableStyles),
		          (currentResource = pendingProps.get(currentProps)),
		          currentResource ||
		            ((currentResource = {
		              type: "style",
		              instance: null,
		              count: 0,
		              state: null
		            }),
		            pendingProps.set(currentProps, currentResource)),
		          currentResource)
		        : { type: "void", instance: null, count: 0, state: null };
		    case "link":
		      if (
		        "stylesheet" === pendingProps.rel &&
		        "string" === typeof pendingProps.href &&
		        "string" === typeof pendingProps.precedence
		      ) {
		        type = getStyleKey(pendingProps.href);
		        var styles$244 = getResourcesFromRoot(
		            JSCompiler_inline_result
		          ).hoistableStyles,
		          resource$245 = styles$244.get(type);
		        resource$245 ||
		          ((JSCompiler_inline_result =
		            JSCompiler_inline_result.ownerDocument || JSCompiler_inline_result),
		          (resource$245 = {
		            type: "stylesheet",
		            instance: null,
		            count: 0,
		            state: { loading: 0, preload: null }
		          }),
		          styles$244.set(type, resource$245),
		          (styles$244 = JSCompiler_inline_result.querySelector(
		            getStylesheetSelectorFromKey(type)
		          )) &&
		            !styles$244._p &&
		            ((resource$245.instance = styles$244),
		            (resource$245.state.loading = 5)),
		          preloadPropsMap.has(type) ||
		            ((pendingProps = {
		              rel: "preload",
		              as: "style",
		              href: pendingProps.href,
		              crossOrigin: pendingProps.crossOrigin,
		              integrity: pendingProps.integrity,
		              media: pendingProps.media,
		              hrefLang: pendingProps.hrefLang,
		              referrerPolicy: pendingProps.referrerPolicy
		            }),
		            preloadPropsMap.set(type, pendingProps),
		            styles$244 ||
		              preloadStylesheet(
		                JSCompiler_inline_result,
		                type,
		                pendingProps,
		                resource$245.state
		              )));
		        if (currentProps && null === currentResource)
		          throw Error(formatProdErrorMessage(528, ""));
		        return resource$245;
		      }
		      if (currentProps && null !== currentResource)
		        throw Error(formatProdErrorMessage(529, ""));
		      return null;
		    case "script":
		      return (
		        (currentProps = pendingProps.async),
		        (pendingProps = pendingProps.src),
		        "string" === typeof pendingProps &&
		        currentProps &&
		        "function" !== typeof currentProps &&
		        "symbol" !== typeof currentProps
		          ? ((currentProps = getScriptKey(pendingProps)),
		            (pendingProps = getResourcesFromRoot(
		              JSCompiler_inline_result
		            ).hoistableScripts),
		            (currentResource = pendingProps.get(currentProps)),
		            currentResource ||
		              ((currentResource = {
		                type: "script",
		                instance: null,
		                count: 0,
		                state: null
		              }),
		              pendingProps.set(currentProps, currentResource)),
		            currentResource)
		          : { type: "void", instance: null, count: 0, state: null }
		      );
		    default:
		      throw Error(formatProdErrorMessage(444, type));
		  }
		}
		function getStyleKey(href) {
		  return 'href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"';
		}
		function getStylesheetSelectorFromKey(key) {
		  return 'link[rel="stylesheet"][' + key + "]";
		}
		function stylesheetPropsFromRawProps(rawProps) {
		  return assign({}, rawProps, {
		    "data-precedence": rawProps.precedence,
		    precedence: null
		  });
		}
		function preloadStylesheet(ownerDocument, key, preloadProps, state) {
		  ownerDocument.querySelector('link[rel="preload"][as="style"][' + key + "]")
		    ? (state.loading = 1)
		    : ((key = ownerDocument.createElement("link")),
		      (state.preload = key),
		      key.addEventListener("load", function () {
		        return (state.loading |= 1);
		      }),
		      key.addEventListener("error", function () {
		        return (state.loading |= 2);
		      }),
		      setInitialProperties(key, "link", preloadProps),
		      markNodeAsHoistable(key),
		      ownerDocument.head.appendChild(key));
		}
		function getScriptKey(src) {
		  return '[src="' + escapeSelectorAttributeValueInsideDoubleQuotes(src) + '"]';
		}
		function getScriptSelectorFromKey(key) {
		  return "script[async]" + key;
		}
		function acquireResource(hoistableRoot, resource, props) {
		  resource.count++;
		  if (null === resource.instance)
		    switch (resource.type) {
		      case "style":
		        var instance = hoistableRoot.querySelector(
		          'style[data-href~="' +
		            escapeSelectorAttributeValueInsideDoubleQuotes(props.href) +
		            '"]'
		        );
		        if (instance)
		          return (
		            (resource.instance = instance),
		            markNodeAsHoistable(instance),
		            instance
		          );
		        var styleProps = assign({}, props, {
		          "data-href": props.href,
		          "data-precedence": props.precedence,
		          href: null,
		          precedence: null
		        });
		        instance = (hoistableRoot.ownerDocument || hoistableRoot).createElement(
		          "style"
		        );
		        markNodeAsHoistable(instance);
		        setInitialProperties(instance, "style", styleProps);
		        insertStylesheet(instance, props.precedence, hoistableRoot);
		        return (resource.instance = instance);
		      case "stylesheet":
		        styleProps = getStyleKey(props.href);
		        var instance$250 = hoistableRoot.querySelector(
		          getStylesheetSelectorFromKey(styleProps)
		        );
		        if (instance$250)
		          return (
		            (resource.state.loading |= 4),
		            (resource.instance = instance$250),
		            markNodeAsHoistable(instance$250),
		            instance$250
		          );
		        instance = stylesheetPropsFromRawProps(props);
		        (styleProps = preloadPropsMap.get(styleProps)) &&
		          adoptPreloadPropsForStylesheet(instance, styleProps);
		        instance$250 = (
		          hoistableRoot.ownerDocument || hoistableRoot
		        ).createElement("link");
		        markNodeAsHoistable(instance$250);
		        var linkInstance = instance$250;
		        linkInstance._p = new Promise(function (resolve, reject) {
		          linkInstance.onload = resolve;
		          linkInstance.onerror = reject;
		        });
		        setInitialProperties(instance$250, "link", instance);
		        resource.state.loading |= 4;
		        insertStylesheet(instance$250, props.precedence, hoistableRoot);
		        return (resource.instance = instance$250);
		      case "script":
		        instance$250 = getScriptKey(props.src);
		        if (
		          (styleProps = hoistableRoot.querySelector(
		            getScriptSelectorFromKey(instance$250)
		          ))
		        )
		          return (
		            (resource.instance = styleProps),
		            markNodeAsHoistable(styleProps),
		            styleProps
		          );
		        instance = props;
		        if ((styleProps = preloadPropsMap.get(instance$250)))
		          (instance = assign({}, props)),
		            adoptPreloadPropsForScript(instance, styleProps);
		        hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
		        styleProps = hoistableRoot.createElement("script");
		        markNodeAsHoistable(styleProps);
		        setInitialProperties(styleProps, "link", instance);
		        hoistableRoot.head.appendChild(styleProps);
		        return (resource.instance = styleProps);
		      case "void":
		        return null;
		      default:
		        throw Error(formatProdErrorMessage(443, resource.type));
		    }
		  else
		    "stylesheet" === resource.type &&
		      0 === (resource.state.loading & 4) &&
		      ((instance = resource.instance),
		      (resource.state.loading |= 4),
		      insertStylesheet(instance, props.precedence, hoistableRoot));
		  return resource.instance;
		}
		function insertStylesheet(instance, precedence, root) {
		  for (
		    var nodes = root.querySelectorAll(
		        'link[rel="stylesheet"][data-precedence],style[data-precedence]'
		      ),
		      last = nodes.length ? nodes[nodes.length - 1] : null,
		      prior = last,
		      i = 0;
		    i < nodes.length;
		    i++
		  ) {
		    var node = nodes[i];
		    if (node.dataset.precedence === precedence) prior = node;
		    else if (prior !== last) break;
		  }
		  prior
		    ? prior.parentNode.insertBefore(instance, prior.nextSibling)
		    : ((precedence = 9 === root.nodeType ? root.head : root),
		      precedence.insertBefore(instance, precedence.firstChild));
		}
		function adoptPreloadPropsForStylesheet(stylesheetProps, preloadProps) {
		  null == stylesheetProps.crossOrigin &&
		    (stylesheetProps.crossOrigin = preloadProps.crossOrigin);
		  null == stylesheetProps.referrerPolicy &&
		    (stylesheetProps.referrerPolicy = preloadProps.referrerPolicy);
		  null == stylesheetProps.title && (stylesheetProps.title = preloadProps.title);
		}
		function adoptPreloadPropsForScript(scriptProps, preloadProps) {
		  null == scriptProps.crossOrigin &&
		    (scriptProps.crossOrigin = preloadProps.crossOrigin);
		  null == scriptProps.referrerPolicy &&
		    (scriptProps.referrerPolicy = preloadProps.referrerPolicy);
		  null == scriptProps.integrity &&
		    (scriptProps.integrity = preloadProps.integrity);
		}
		var tagCaches = null;
		function getHydratableHoistableCache(type, keyAttribute, ownerDocument) {
		  if (null === tagCaches) {
		    var cache = new Map();
		    var caches = (tagCaches = new Map());
		    caches.set(ownerDocument, cache);
		  } else
		    (caches = tagCaches),
		      (cache = caches.get(ownerDocument)),
		      cache || ((cache = new Map()), caches.set(ownerDocument, cache));
		  if (cache.has(type)) return cache;
		  cache.set(type, null);
		  ownerDocument = ownerDocument.getElementsByTagName(type);
		  for (caches = 0; caches < ownerDocument.length; caches++) {
		    var node = ownerDocument[caches];
		    if (
		      !(
		        node[internalHoistableMarker] ||
		        node[internalInstanceKey] ||
		        ("link" === type && "stylesheet" === node.getAttribute("rel"))
		      ) &&
		      "http://www.w3.org/2000/svg" !== node.namespaceURI
		    ) {
		      var nodeKey = node.getAttribute(keyAttribute) || "";
		      nodeKey = type + nodeKey;
		      var existing = cache.get(nodeKey);
		      existing ? existing.push(node) : cache.set(nodeKey, [node]);
		    }
		  }
		  return cache;
		}
		function mountHoistable(hoistableRoot, type, instance) {
		  hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
		  hoistableRoot.head.insertBefore(
		    instance,
		    "title" === type ? hoistableRoot.querySelector("head > title") : null
		  );
		}
		function isHostHoistableType(type, props, hostContext) {
		  if (1 === hostContext || null != props.itemProp) return false;
		  switch (type) {
		    case "meta":
		    case "title":
		      return true;
		    case "style":
		      if (
		        "string" !== typeof props.precedence ||
		        "string" !== typeof props.href ||
		        "" === props.href
		      )
		        break;
		      return true;
		    case "link":
		      if (
		        "string" !== typeof props.rel ||
		        "string" !== typeof props.href ||
		        "" === props.href ||
		        props.onLoad ||
		        props.onError
		      )
		        break;
		      switch (props.rel) {
		        case "stylesheet":
		          return (
		            (type = props.disabled),
		            "string" === typeof props.precedence && null == type
		          );
		        default:
		          return true;
		      }
		    case "script":
		      if (
		        props.async &&
		        "function" !== typeof props.async &&
		        "symbol" !== typeof props.async &&
		        !props.onLoad &&
		        !props.onError &&
		        props.src &&
		        "string" === typeof props.src
		      )
		        return true;
		  }
		  return false;
		}
		function preloadResource(resource) {
		  return "stylesheet" === resource.type && 0 === (resource.state.loading & 3)
		    ? false
		    : true;
		}
		var suspendedState = null;
		function noop() {}
		function suspendResource(hoistableRoot, resource, props) {
		  if (null === suspendedState) throw Error(formatProdErrorMessage(475));
		  var state = suspendedState;
		  if (
		    "stylesheet" === resource.type &&
		    ("string" !== typeof props.media ||
		      false !== matchMedia(props.media).matches) &&
		    0 === (resource.state.loading & 4)
		  ) {
		    if (null === resource.instance) {
		      var key = getStyleKey(props.href),
		        instance = hoistableRoot.querySelector(
		          getStylesheetSelectorFromKey(key)
		        );
		      if (instance) {
		        hoistableRoot = instance._p;
		        null !== hoistableRoot &&
		          "object" === typeof hoistableRoot &&
		          "function" === typeof hoistableRoot.then &&
		          (state.count++,
		          (state = onUnsuspend.bind(state)),
		          hoistableRoot.then(state, state));
		        resource.state.loading |= 4;
		        resource.instance = instance;
		        markNodeAsHoistable(instance);
		        return;
		      }
		      instance = hoistableRoot.ownerDocument || hoistableRoot;
		      props = stylesheetPropsFromRawProps(props);
		      (key = preloadPropsMap.get(key)) &&
		        adoptPreloadPropsForStylesheet(props, key);
		      instance = instance.createElement("link");
		      markNodeAsHoistable(instance);
		      var linkInstance = instance;
		      linkInstance._p = new Promise(function (resolve, reject) {
		        linkInstance.onload = resolve;
		        linkInstance.onerror = reject;
		      });
		      setInitialProperties(instance, "link", props);
		      resource.instance = instance;
		    }
		    null === state.stylesheets && (state.stylesheets = new Map());
		    state.stylesheets.set(resource, hoistableRoot);
		    (hoistableRoot = resource.state.preload) &&
		      0 === (resource.state.loading & 3) &&
		      (state.count++,
		      (resource = onUnsuspend.bind(state)),
		      hoistableRoot.addEventListener("load", resource),
		      hoistableRoot.addEventListener("error", resource));
		  }
		}
		function waitForCommitToBeReady() {
		  if (null === suspendedState) throw Error(formatProdErrorMessage(475));
		  var state = suspendedState;
		  state.stylesheets &&
		    0 === state.count &&
		    insertSuspendedStylesheets(state, state.stylesheets);
		  return 0 < state.count
		    ? function (commit) {
		        var stylesheetTimer = setTimeout(function () {
		          state.stylesheets &&
		            insertSuspendedStylesheets(state, state.stylesheets);
		          if (state.unsuspend) {
		            var unsuspend = state.unsuspend;
		            state.unsuspend = null;
		            unsuspend();
		          }
		        }, 6e4);
		        state.unsuspend = commit;
		        return function () {
		          state.unsuspend = null;
		          clearTimeout(stylesheetTimer);
		        };
		      }
		    : null;
		}
		function onUnsuspend() {
		  this.count--;
		  if (0 === this.count)
		    if (this.stylesheets) insertSuspendedStylesheets(this, this.stylesheets);
		    else if (this.unsuspend) {
		      var unsuspend = this.unsuspend;
		      this.unsuspend = null;
		      unsuspend();
		    }
		}
		var precedencesByRoot = null;
		function insertSuspendedStylesheets(state, resources) {
		  state.stylesheets = null;
		  null !== state.unsuspend &&
		    (state.count++,
		    (precedencesByRoot = new Map()),
		    resources.forEach(insertStylesheetIntoRoot, state),
		    (precedencesByRoot = null),
		    onUnsuspend.call(state));
		}
		function insertStylesheetIntoRoot(root, resource) {
		  if (!(resource.state.loading & 4)) {
		    var precedences = precedencesByRoot.get(root);
		    if (precedences) var last = precedences.get(null);
		    else {
		      precedences = new Map();
		      precedencesByRoot.set(root, precedences);
		      for (
		        var nodes = root.querySelectorAll(
		            "link[data-precedence],style[data-precedence]"
		          ),
		          i = 0;
		        i < nodes.length;
		        i++
		      ) {
		        var node = nodes[i];
		        if (
		          "LINK" === node.nodeName ||
		          "not all" !== node.getAttribute("media")
		        )
		          precedences.set(node.dataset.precedence, node), (last = node);
		      }
		      last && precedences.set(null, last);
		    }
		    nodes = resource.instance;
		    node = nodes.getAttribute("data-precedence");
		    i = precedences.get(node) || last;
		    i === last && precedences.set(null, nodes);
		    precedences.set(node, nodes);
		    this.count++;
		    last = onUnsuspend.bind(this);
		    nodes.addEventListener("load", last);
		    nodes.addEventListener("error", last);
		    i
		      ? i.parentNode.insertBefore(nodes, i.nextSibling)
		      : ((root = 9 === root.nodeType ? root.head : root),
		        root.insertBefore(nodes, root.firstChild));
		    resource.state.loading |= 4;
		  }
		}
		var HostTransitionContext = {
		  $$typeof: REACT_CONTEXT_TYPE,
		  Provider: null,
		  Consumer: null,
		  _currentValue: sharedNotPendingObject,
		  _currentValue2: sharedNotPendingObject,
		  _threadCount: 0
		};
		function FiberRootNode(
		  containerInfo,
		  tag,
		  hydrate,
		  identifierPrefix,
		  onUncaughtError,
		  onCaughtError,
		  onRecoverableError,
		  formState
		) {
		  this.tag = 1;
		  this.containerInfo = containerInfo;
		  this.pingCache = this.current = this.pendingChildren = null;
		  this.timeoutHandle = -1;
		  this.callbackNode =
		    this.next =
		    this.pendingContext =
		    this.context =
		    this.cancelPendingCommit =
		      null;
		  this.callbackPriority = 0;
		  this.expirationTimes = createLaneMap(-1);
		  this.entangledLanes =
		    this.shellSuspendCounter =
		    this.errorRecoveryDisabledLanes =
		    this.expiredLanes =
		    this.warmLanes =
		    this.pingedLanes =
		    this.suspendedLanes =
		    this.pendingLanes =
		      0;
		  this.entanglements = createLaneMap(0);
		  this.hiddenUpdates = createLaneMap(null);
		  this.identifierPrefix = identifierPrefix;
		  this.onUncaughtError = onUncaughtError;
		  this.onCaughtError = onCaughtError;
		  this.onRecoverableError = onRecoverableError;
		  this.pooledCache = null;
		  this.pooledCacheLanes = 0;
		  this.formState = formState;
		  this.incompleteTransitions = new Map();
		}
		function createFiberRoot(
		  containerInfo,
		  tag,
		  hydrate,
		  initialChildren,
		  hydrationCallbacks,
		  isStrictMode,
		  identifierPrefix,
		  onUncaughtError,
		  onCaughtError,
		  onRecoverableError,
		  transitionCallbacks,
		  formState
		) {
		  containerInfo = new FiberRootNode(
		    containerInfo,
		    tag,
		    hydrate,
		    identifierPrefix,
		    onUncaughtError,
		    onCaughtError,
		    onRecoverableError,
		    formState
		  );
		  tag = 1;
		  true === isStrictMode && (tag |= 24);
		  isStrictMode = createFiberImplClass(3, null, null, tag);
		  containerInfo.current = isStrictMode;
		  isStrictMode.stateNode = containerInfo;
		  tag = createCache();
		  tag.refCount++;
		  containerInfo.pooledCache = tag;
		  tag.refCount++;
		  isStrictMode.memoizedState = {
		    element: initialChildren,
		    isDehydrated: hydrate,
		    cache: tag
		  };
		  initializeUpdateQueue(isStrictMode);
		  return containerInfo;
		}
		function getContextForSubtree(parentComponent) {
		  if (!parentComponent) return emptyContextObject;
		  parentComponent = emptyContextObject;
		  return parentComponent;
		}
		function updateContainerImpl(
		  rootFiber,
		  lane,
		  element,
		  container,
		  parentComponent,
		  callback
		) {
		  parentComponent = getContextForSubtree(parentComponent);
		  null === container.context
		    ? (container.context = parentComponent)
		    : (container.pendingContext = parentComponent);
		  container = createUpdate(lane);
		  container.payload = { element: element };
		  callback = void 0 === callback ? null : callback;
		  null !== callback && (container.callback = callback);
		  element = enqueueUpdate(rootFiber, container, lane);
		  null !== element &&
		    (scheduleUpdateOnFiber(element, rootFiber, lane),
		    entangleTransitions(element, rootFiber, lane));
		}
		function markRetryLaneImpl(fiber, retryLane) {
		  fiber = fiber.memoizedState;
		  if (null !== fiber && null !== fiber.dehydrated) {
		    var a = fiber.retryLane;
		    fiber.retryLane = 0 !== a && a < retryLane ? a : retryLane;
		  }
		}
		function markRetryLaneIfNotHydrated(fiber, retryLane) {
		  markRetryLaneImpl(fiber, retryLane);
		  (fiber = fiber.alternate) && markRetryLaneImpl(fiber, retryLane);
		}
		function attemptContinuousHydration(fiber) {
		  if (13 === fiber.tag) {
		    var root = enqueueConcurrentRenderForLane(fiber, 67108864);
		    null !== root && scheduleUpdateOnFiber(root, fiber, 67108864);
		    markRetryLaneIfNotHydrated(fiber, 67108864);
		  }
		}
		var _enabled = true;
		function dispatchDiscreteEvent(
		  domEventName,
		  eventSystemFlags,
		  container,
		  nativeEvent
		) {
		  var prevTransition = ReactSharedInternals.T;
		  ReactSharedInternals.T = null;
		  var previousPriority = ReactDOMSharedInternals.p;
		  try {
		    (ReactDOMSharedInternals.p = 2),
		      dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);
		  } finally {
		    (ReactDOMSharedInternals.p = previousPriority),
		      (ReactSharedInternals.T = prevTransition);
		  }
		}
		function dispatchContinuousEvent(
		  domEventName,
		  eventSystemFlags,
		  container,
		  nativeEvent
		) {
		  var prevTransition = ReactSharedInternals.T;
		  ReactSharedInternals.T = null;
		  var previousPriority = ReactDOMSharedInternals.p;
		  try {
		    (ReactDOMSharedInternals.p = 8),
		      dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);
		  } finally {
		    (ReactDOMSharedInternals.p = previousPriority),
		      (ReactSharedInternals.T = prevTransition);
		  }
		}
		function dispatchEvent(
		  domEventName,
		  eventSystemFlags,
		  targetContainer,
		  nativeEvent
		) {
		  if (_enabled) {
		    var blockedOn = findInstanceBlockingEvent(nativeEvent);
		    if (null === blockedOn)
		      dispatchEventForPluginEventSystem(
		        domEventName,
		        eventSystemFlags,
		        nativeEvent,
		        return_targetInst,
		        targetContainer
		      ),
		        clearIfContinuousEvent(domEventName, nativeEvent);
		    else if (
		      queueIfContinuousEvent(
		        blockedOn,
		        domEventName,
		        eventSystemFlags,
		        targetContainer,
		        nativeEvent
		      )
		    )
		      nativeEvent.stopPropagation();
		    else if (
		      (clearIfContinuousEvent(domEventName, nativeEvent),
		      eventSystemFlags & 4 &&
		        -1 < discreteReplayableEvents.indexOf(domEventName))
		    ) {
		      for (; null !== blockedOn; ) {
		        var fiber = getInstanceFromNode(blockedOn);
		        if (null !== fiber)
		          switch (fiber.tag) {
		            case 3:
		              fiber = fiber.stateNode;
		              if (fiber.current.memoizedState.isDehydrated) {
		                var lanes = getHighestPriorityLanes(fiber.pendingLanes);
		                if (0 !== lanes) {
		                  var root = fiber;
		                  root.pendingLanes |= 2;
		                  for (root.entangledLanes |= 2; lanes; ) {
		                    var lane = 1 << (31 - clz32(lanes));
		                    root.entanglements[1] |= lane;
		                    lanes &= ~lane;
		                  }
		                  ensureRootIsScheduled(fiber);
		                  0 === (executionContext & 6) &&
		                    ((workInProgressRootRenderTargetTime = now() + 500),
		                    flushSyncWorkAcrossRoots_impl(0));
		                }
		              }
		              break;
		            case 13:
		              (root = enqueueConcurrentRenderForLane(fiber, 2)),
		                null !== root && scheduleUpdateOnFiber(root, fiber, 2),
		                flushSyncWork$1(),
		                markRetryLaneIfNotHydrated(fiber, 2);
		          }
		        fiber = findInstanceBlockingEvent(nativeEvent);
		        null === fiber &&
		          dispatchEventForPluginEventSystem(
		            domEventName,
		            eventSystemFlags,
		            nativeEvent,
		            return_targetInst,
		            targetContainer
		          );
		        if (fiber === blockedOn) break;
		        blockedOn = fiber;
		      }
		      null !== blockedOn && nativeEvent.stopPropagation();
		    } else
		      dispatchEventForPluginEventSystem(
		        domEventName,
		        eventSystemFlags,
		        nativeEvent,
		        null,
		        targetContainer
		      );
		  }
		}
		function findInstanceBlockingEvent(nativeEvent) {
		  nativeEvent = getEventTarget(nativeEvent);
		  return findInstanceBlockingTarget(nativeEvent);
		}
		var return_targetInst = null;
		function findInstanceBlockingTarget(targetNode) {
		  return_targetInst = null;
		  targetNode = getClosestInstanceFromNode(targetNode);
		  if (null !== targetNode) {
		    var nearestMounted = getNearestMountedFiber(targetNode);
		    if (null === nearestMounted) targetNode = null;
		    else {
		      var tag = nearestMounted.tag;
		      if (13 === tag) {
		        targetNode = getSuspenseInstanceFromFiber(nearestMounted);
		        if (null !== targetNode) return targetNode;
		        targetNode = null;
		      } else if (3 === tag) {
		        if (nearestMounted.stateNode.current.memoizedState.isDehydrated)
		          return 3 === nearestMounted.tag
		            ? nearestMounted.stateNode.containerInfo
		            : null;
		        targetNode = null;
		      } else nearestMounted !== targetNode && (targetNode = null);
		    }
		  }
		  return_targetInst = targetNode;
		  return null;
		}
		function getEventPriority(domEventName) {
		  switch (domEventName) {
		    case "beforetoggle":
		    case "cancel":
		    case "click":
		    case "close":
		    case "contextmenu":
		    case "copy":
		    case "cut":
		    case "auxclick":
		    case "dblclick":
		    case "dragend":
		    case "dragstart":
		    case "drop":
		    case "focusin":
		    case "focusout":
		    case "input":
		    case "invalid":
		    case "keydown":
		    case "keypress":
		    case "keyup":
		    case "mousedown":
		    case "mouseup":
		    case "paste":
		    case "pause":
		    case "play":
		    case "pointercancel":
		    case "pointerdown":
		    case "pointerup":
		    case "ratechange":
		    case "reset":
		    case "resize":
		    case "seeked":
		    case "submit":
		    case "toggle":
		    case "touchcancel":
		    case "touchend":
		    case "touchstart":
		    case "volumechange":
		    case "change":
		    case "selectionchange":
		    case "textInput":
		    case "compositionstart":
		    case "compositionend":
		    case "compositionupdate":
		    case "beforeblur":
		    case "afterblur":
		    case "beforeinput":
		    case "blur":
		    case "fullscreenchange":
		    case "focus":
		    case "hashchange":
		    case "popstate":
		    case "select":
		    case "selectstart":
		      return 2;
		    case "drag":
		    case "dragenter":
		    case "dragexit":
		    case "dragleave":
		    case "dragover":
		    case "mousemove":
		    case "mouseout":
		    case "mouseover":
		    case "pointermove":
		    case "pointerout":
		    case "pointerover":
		    case "scroll":
		    case "touchmove":
		    case "wheel":
		    case "mouseenter":
		    case "mouseleave":
		    case "pointerenter":
		    case "pointerleave":
		      return 8;
		    case "message":
		      switch (getCurrentPriorityLevel()) {
		        case ImmediatePriority:
		          return 2;
		        case UserBlockingPriority:
		          return 8;
		        case NormalPriority$1:
		        case LowPriority:
		          return 32;
		        case IdlePriority:
		          return 268435456;
		        default:
		          return 32;
		      }
		    default:
		      return 32;
		  }
		}
		var hasScheduledReplayAttempt = false,
		  queuedFocus = null,
		  queuedDrag = null,
		  queuedMouse = null,
		  queuedPointers = new Map(),
		  queuedPointerCaptures = new Map(),
		  queuedExplicitHydrationTargets = [],
		  discreteReplayableEvents =
		    "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(
		      " "
		    );
		function clearIfContinuousEvent(domEventName, nativeEvent) {
		  switch (domEventName) {
		    case "focusin":
		    case "focusout":
		      queuedFocus = null;
		      break;
		    case "dragenter":
		    case "dragleave":
		      queuedDrag = null;
		      break;
		    case "mouseover":
		    case "mouseout":
		      queuedMouse = null;
		      break;
		    case "pointerover":
		    case "pointerout":
		      queuedPointers.delete(nativeEvent.pointerId);
		      break;
		    case "gotpointercapture":
		    case "lostpointercapture":
		      queuedPointerCaptures.delete(nativeEvent.pointerId);
		  }
		}
		function accumulateOrCreateContinuousQueuedReplayableEvent(
		  existingQueuedEvent,
		  blockedOn,
		  domEventName,
		  eventSystemFlags,
		  targetContainer,
		  nativeEvent
		) {
		  if (
		    null === existingQueuedEvent ||
		    existingQueuedEvent.nativeEvent !== nativeEvent
		  )
		    return (
		      (existingQueuedEvent = {
		        blockedOn: blockedOn,
		        domEventName: domEventName,
		        eventSystemFlags: eventSystemFlags,
		        nativeEvent: nativeEvent,
		        targetContainers: [targetContainer]
		      }),
		      null !== blockedOn &&
		        ((blockedOn = getInstanceFromNode(blockedOn)),
		        null !== blockedOn && attemptContinuousHydration(blockedOn)),
		      existingQueuedEvent
		    );
		  existingQueuedEvent.eventSystemFlags |= eventSystemFlags;
		  blockedOn = existingQueuedEvent.targetContainers;
		  null !== targetContainer &&
		    -1 === blockedOn.indexOf(targetContainer) &&
		    blockedOn.push(targetContainer);
		  return existingQueuedEvent;
		}
		function queueIfContinuousEvent(
		  blockedOn,
		  domEventName,
		  eventSystemFlags,
		  targetContainer,
		  nativeEvent
		) {
		  switch (domEventName) {
		    case "focusin":
		      return (
		        (queuedFocus = accumulateOrCreateContinuousQueuedReplayableEvent(
		          queuedFocus,
		          blockedOn,
		          domEventName,
		          eventSystemFlags,
		          targetContainer,
		          nativeEvent
		        )),
		        true
		      );
		    case "dragenter":
		      return (
		        (queuedDrag = accumulateOrCreateContinuousQueuedReplayableEvent(
		          queuedDrag,
		          blockedOn,
		          domEventName,
		          eventSystemFlags,
		          targetContainer,
		          nativeEvent
		        )),
		        true
		      );
		    case "mouseover":
		      return (
		        (queuedMouse = accumulateOrCreateContinuousQueuedReplayableEvent(
		          queuedMouse,
		          blockedOn,
		          domEventName,
		          eventSystemFlags,
		          targetContainer,
		          nativeEvent
		        )),
		        true
		      );
		    case "pointerover":
		      var pointerId = nativeEvent.pointerId;
		      queuedPointers.set(
		        pointerId,
		        accumulateOrCreateContinuousQueuedReplayableEvent(
		          queuedPointers.get(pointerId) || null,
		          blockedOn,
		          domEventName,
		          eventSystemFlags,
		          targetContainer,
		          nativeEvent
		        )
		      );
		      return true;
		    case "gotpointercapture":
		      return (
		        (pointerId = nativeEvent.pointerId),
		        queuedPointerCaptures.set(
		          pointerId,
		          accumulateOrCreateContinuousQueuedReplayableEvent(
		            queuedPointerCaptures.get(pointerId) || null,
		            blockedOn,
		            domEventName,
		            eventSystemFlags,
		            targetContainer,
		            nativeEvent
		          )
		        ),
		        true
		      );
		  }
		  return false;
		}
		function attemptExplicitHydrationTarget(queuedTarget) {
		  var targetInst = getClosestInstanceFromNode(queuedTarget.target);
		  if (null !== targetInst) {
		    var nearestMounted = getNearestMountedFiber(targetInst);
		    if (null !== nearestMounted)
		      if (((targetInst = nearestMounted.tag), 13 === targetInst)) {
		        if (
		          ((targetInst = getSuspenseInstanceFromFiber(nearestMounted)),
		          null !== targetInst)
		        ) {
		          queuedTarget.blockedOn = targetInst;
		          runWithPriority(queuedTarget.priority, function () {
		            if (13 === nearestMounted.tag) {
		              var lane = requestUpdateLane();
		              lane = getBumpedLaneForHydrationByLane(lane);
		              var root = enqueueConcurrentRenderForLane(nearestMounted, lane);
		              null !== root &&
		                scheduleUpdateOnFiber(root, nearestMounted, lane);
		              markRetryLaneIfNotHydrated(nearestMounted, lane);
		            }
		          });
		          return;
		        }
		      } else if (
		        3 === targetInst &&
		        nearestMounted.stateNode.current.memoizedState.isDehydrated
		      ) {
		        queuedTarget.blockedOn =
		          3 === nearestMounted.tag
		            ? nearestMounted.stateNode.containerInfo
		            : null;
		        return;
		      }
		  }
		  queuedTarget.blockedOn = null;
		}
		function attemptReplayContinuousQueuedEvent(queuedEvent) {
		  if (null !== queuedEvent.blockedOn) return false;
		  for (
		    var targetContainers = queuedEvent.targetContainers;
		    0 < targetContainers.length;

		  ) {
		    var nextBlockedOn = findInstanceBlockingEvent(queuedEvent.nativeEvent);
		    if (null === nextBlockedOn) {
		      nextBlockedOn = queuedEvent.nativeEvent;
		      var nativeEventClone = new nextBlockedOn.constructor(
		        nextBlockedOn.type,
		        nextBlockedOn
		      );
		      currentReplayingEvent = nativeEventClone;
		      nextBlockedOn.target.dispatchEvent(nativeEventClone);
		      currentReplayingEvent = null;
		    } else
		      return (
		        (targetContainers = getInstanceFromNode(nextBlockedOn)),
		        null !== targetContainers &&
		          attemptContinuousHydration(targetContainers),
		        (queuedEvent.blockedOn = nextBlockedOn),
		        false
		      );
		    targetContainers.shift();
		  }
		  return true;
		}
		function attemptReplayContinuousQueuedEventInMap(queuedEvent, key, map) {
		  attemptReplayContinuousQueuedEvent(queuedEvent) && map.delete(key);
		}
		function replayUnblockedEvents() {
		  hasScheduledReplayAttempt = false;
		  null !== queuedFocus &&
		    attemptReplayContinuousQueuedEvent(queuedFocus) &&
		    (queuedFocus = null);
		  null !== queuedDrag &&
		    attemptReplayContinuousQueuedEvent(queuedDrag) &&
		    (queuedDrag = null);
		  null !== queuedMouse &&
		    attemptReplayContinuousQueuedEvent(queuedMouse) &&
		    (queuedMouse = null);
		  queuedPointers.forEach(attemptReplayContinuousQueuedEventInMap);
		  queuedPointerCaptures.forEach(attemptReplayContinuousQueuedEventInMap);
		}
		function scheduleCallbackIfUnblocked(queuedEvent, unblocked) {
		  queuedEvent.blockedOn === unblocked &&
		    ((queuedEvent.blockedOn = null),
		    hasScheduledReplayAttempt ||
		      ((hasScheduledReplayAttempt = true),
		      Scheduler.unstable_scheduleCallback(
		        Scheduler.unstable_NormalPriority,
		        replayUnblockedEvents
		      )));
		}
		var lastScheduledReplayQueue = null;
		function scheduleReplayQueueIfNeeded(formReplayingQueue) {
		  lastScheduledReplayQueue !== formReplayingQueue &&
		    ((lastScheduledReplayQueue = formReplayingQueue),
		    Scheduler.unstable_scheduleCallback(
		      Scheduler.unstable_NormalPriority,
		      function () {
		        lastScheduledReplayQueue === formReplayingQueue &&
		          (lastScheduledReplayQueue = null);
		        for (var i = 0; i < formReplayingQueue.length; i += 3) {
		          var form = formReplayingQueue[i],
		            submitterOrAction = formReplayingQueue[i + 1],
		            formData = formReplayingQueue[i + 2];
		          if ("function" !== typeof submitterOrAction)
		            if (null === findInstanceBlockingTarget(submitterOrAction || form))
		              continue;
		            else break;
		          var formInst = getInstanceFromNode(form);
		          null !== formInst &&
		            (formReplayingQueue.splice(i, 3),
		            (i -= 3),
		            startHostTransition(
		              formInst,
		              {
		                pending: true,
		                data: formData,
		                method: form.method,
		                action: submitterOrAction
		              },
		              submitterOrAction,
		              formData
		            ));
		        }
		      }
		    ));
		}
		function retryIfBlockedOn(unblocked) {
		  function unblock(queuedEvent) {
		    return scheduleCallbackIfUnblocked(queuedEvent, unblocked);
		  }
		  null !== queuedFocus && scheduleCallbackIfUnblocked(queuedFocus, unblocked);
		  null !== queuedDrag && scheduleCallbackIfUnblocked(queuedDrag, unblocked);
		  null !== queuedMouse && scheduleCallbackIfUnblocked(queuedMouse, unblocked);
		  queuedPointers.forEach(unblock);
		  queuedPointerCaptures.forEach(unblock);
		  for (var i = 0; i < queuedExplicitHydrationTargets.length; i++) {
		    var queuedTarget = queuedExplicitHydrationTargets[i];
		    queuedTarget.blockedOn === unblocked && (queuedTarget.blockedOn = null);
		  }
		  for (
		    ;
		    0 < queuedExplicitHydrationTargets.length &&
		    ((i = queuedExplicitHydrationTargets[0]), null === i.blockedOn);

		  )
		    attemptExplicitHydrationTarget(i),
		      null === i.blockedOn && queuedExplicitHydrationTargets.shift();
		  i = (unblocked.ownerDocument || unblocked).$$reactFormReplay;
		  if (null != i)
		    for (queuedTarget = 0; queuedTarget < i.length; queuedTarget += 3) {
		      var form = i[queuedTarget],
		        submitterOrAction = i[queuedTarget + 1],
		        formProps = form[internalPropsKey] || null;
		      if ("function" === typeof submitterOrAction)
		        formProps || scheduleReplayQueueIfNeeded(i);
		      else if (formProps) {
		        var action = null;
		        if (submitterOrAction && submitterOrAction.hasAttribute("formAction"))
		          if (
		            ((form = submitterOrAction),
		            (formProps = submitterOrAction[internalPropsKey] || null))
		          )
		            action = formProps.formAction;
		          else {
		            if (null !== findInstanceBlockingTarget(form)) continue;
		          }
		        else action = formProps.action;
		        "function" === typeof action
		          ? (i[queuedTarget + 1] = action)
		          : (i.splice(queuedTarget, 3), (queuedTarget -= 3));
		        scheduleReplayQueueIfNeeded(i);
		      }
		    }
		}
		function ReactDOMRoot(internalRoot) {
		  this._internalRoot = internalRoot;
		}
		ReactDOMHydrationRoot.prototype.render = ReactDOMRoot.prototype.render =
		  function (children) {
		    var root = this._internalRoot;
		    if (null === root) throw Error(formatProdErrorMessage(409));
		    var current = root.current,
		      lane = requestUpdateLane();
		    updateContainerImpl(current, lane, children, root, null, null);
		  };
		ReactDOMHydrationRoot.prototype.unmount = ReactDOMRoot.prototype.unmount =
		  function () {
		    var root = this._internalRoot;
		    if (null !== root) {
		      this._internalRoot = null;
		      var container = root.containerInfo;
		      updateContainerImpl(root.current, 2, null, root, null, null);
		      flushSyncWork$1();
		      container[internalContainerInstanceKey] = null;
		    }
		  };
		function ReactDOMHydrationRoot(internalRoot) {
		  this._internalRoot = internalRoot;
		}
		ReactDOMHydrationRoot.prototype.unstable_scheduleHydration = function (target) {
		  if (target) {
		    var updatePriority = resolveUpdatePriority();
		    target = { blockedOn: null, target: target, priority: updatePriority };
		    for (
		      var i = 0;
		      i < queuedExplicitHydrationTargets.length &&
		      0 !== updatePriority &&
		      updatePriority < queuedExplicitHydrationTargets[i].priority;
		      i++
		    );
		    queuedExplicitHydrationTargets.splice(i, 0, target);
		    0 === i && attemptExplicitHydrationTarget(target);
		  }
		};
		var isomorphicReactPackageVersion$jscomp$inline_1785 = React.version;
		if (
		  "19.1.0" !==
		  isomorphicReactPackageVersion$jscomp$inline_1785
		)
		  throw Error(
		    formatProdErrorMessage(
		      527,
		      isomorphicReactPackageVersion$jscomp$inline_1785,
		      "19.1.0"
		    )
		  );
		ReactDOMSharedInternals.findDOMNode = function (componentOrElement) {
		  var fiber = componentOrElement._reactInternals;
		  if (void 0 === fiber) {
		    if ("function" === typeof componentOrElement.render)
		      throw Error(formatProdErrorMessage(188));
		    componentOrElement = Object.keys(componentOrElement).join(",");
		    throw Error(formatProdErrorMessage(268, componentOrElement));
		  }
		  componentOrElement = findCurrentFiberUsingSlowPath(fiber);
		  componentOrElement =
		    null !== componentOrElement
		      ? findCurrentHostFiberImpl(componentOrElement)
		      : null;
		  componentOrElement =
		    null === componentOrElement ? null : componentOrElement.stateNode;
		  return componentOrElement;
		};
		var internals$jscomp$inline_2256 = {
		  bundleType: 0,
		  version: "19.1.0",
		  rendererPackageName: "react-dom",
		  currentDispatcherRef: ReactSharedInternals,
		  reconcilerVersion: "19.1.0"
		};
		if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
		  var hook$jscomp$inline_2257 = __REACT_DEVTOOLS_GLOBAL_HOOK__;
		  if (
		    !hook$jscomp$inline_2257.isDisabled &&
		    hook$jscomp$inline_2257.supportsFiber
		  )
		    try {
		      (rendererID = hook$jscomp$inline_2257.inject(
		        internals$jscomp$inline_2256
		      )),
		        (injectedHook = hook$jscomp$inline_2257);
		    } catch (err) {}
		}
		reactDomClient_production.createRoot = function (container, options) {
		  if (!isValidContainer(container)) throw Error(formatProdErrorMessage(299));
		  var isStrictMode = false,
		    identifierPrefix = "",
		    onUncaughtError = defaultOnUncaughtError,
		    onCaughtError = defaultOnCaughtError,
		    onRecoverableError = defaultOnRecoverableError,
		    transitionCallbacks = null;
		  null !== options &&
		    void 0 !== options &&
		    (true === options.unstable_strictMode && (isStrictMode = true),
		    void 0 !== options.identifierPrefix &&
		      (identifierPrefix = options.identifierPrefix),
		    void 0 !== options.onUncaughtError &&
		      (onUncaughtError = options.onUncaughtError),
		    void 0 !== options.onCaughtError && (onCaughtError = options.onCaughtError),
		    void 0 !== options.onRecoverableError &&
		      (onRecoverableError = options.onRecoverableError),
		    void 0 !== options.unstable_transitionCallbacks &&
		      (transitionCallbacks = options.unstable_transitionCallbacks));
		  options = createFiberRoot(
		    container,
		    1,
		    false,
		    null,
		    null,
		    isStrictMode,
		    identifierPrefix,
		    onUncaughtError,
		    onCaughtError,
		    onRecoverableError,
		    transitionCallbacks,
		    null
		  );
		  container[internalContainerInstanceKey] = options.current;
		  listenToAllSupportedEvents(container);
		  return new ReactDOMRoot(options);
		};
		reactDomClient_production.hydrateRoot = function (container, initialChildren, options) {
		  if (!isValidContainer(container)) throw Error(formatProdErrorMessage(299));
		  var isStrictMode = false,
		    identifierPrefix = "",
		    onUncaughtError = defaultOnUncaughtError,
		    onCaughtError = defaultOnCaughtError,
		    onRecoverableError = defaultOnRecoverableError,
		    transitionCallbacks = null,
		    formState = null;
		  null !== options &&
		    void 0 !== options &&
		    (true === options.unstable_strictMode && (isStrictMode = true),
		    void 0 !== options.identifierPrefix &&
		      (identifierPrefix = options.identifierPrefix),
		    void 0 !== options.onUncaughtError &&
		      (onUncaughtError = options.onUncaughtError),
		    void 0 !== options.onCaughtError && (onCaughtError = options.onCaughtError),
		    void 0 !== options.onRecoverableError &&
		      (onRecoverableError = options.onRecoverableError),
		    void 0 !== options.unstable_transitionCallbacks &&
		      (transitionCallbacks = options.unstable_transitionCallbacks),
		    void 0 !== options.formState && (formState = options.formState));
		  initialChildren = createFiberRoot(
		    container,
		    1,
		    true,
		    initialChildren,
		    null != options ? options : null,
		    isStrictMode,
		    identifierPrefix,
		    onUncaughtError,
		    onCaughtError,
		    onRecoverableError,
		    transitionCallbacks,
		    formState
		  );
		  initialChildren.context = getContextForSubtree(null);
		  options = initialChildren.current;
		  isStrictMode = requestUpdateLane();
		  isStrictMode = getBumpedLaneForHydrationByLane(isStrictMode);
		  identifierPrefix = createUpdate(isStrictMode);
		  identifierPrefix.callback = null;
		  enqueueUpdate(options, identifierPrefix, isStrictMode);
		  options = isStrictMode;
		  initialChildren.current.lanes = options;
		  markRootUpdated$1(initialChildren, options);
		  ensureRootIsScheduled(initialChildren);
		  container[internalContainerInstanceKey] = initialChildren.current;
		  listenToAllSupportedEvents(container);
		  return new ReactDOMHydrationRoot(initialChildren);
		};
		reactDomClient_production.version = "19.1.0";
		return reactDomClient_production;
	}

	var hasRequiredClient;

	function requireClient () {
		if (hasRequiredClient) return client.exports;
		hasRequiredClient = 1;

		function checkDCE() {
		  /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */
		  if (
		    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined' ||
		    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== 'function'
		  ) {
		    return;
		  }
		  try {
		    // Verify that the code above has been dead code eliminated (DCE'd).
		    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
		  } catch (err) {
		    // DevTools shouldn't crash React, no matter what.
		    // We should still report in case we break this code.
		    console.error(err);
		  }
		}

		{
		  // DCE check should happen before ReactDOM bundle executes so that
		  // DevTools can report bad minification during injection.
		  checkDCE();
		  client.exports = requireReactDomClient_production();
		}
		return client.exports;
	}

	var clientExports = requireClient();

	var reactDomExports = requireReactDom();

	var isCheckBoxInput = (element) => element.type === 'checkbox';

	var isDateObject = (value) => value instanceof Date;

	var isNullOrUndefined = (value) => value == null;

	const isObjectType = (value) => typeof value === 'object';
	var isObject$2 = (value) => !isNullOrUndefined(value) &&
	    !Array.isArray(value) &&
	    isObjectType(value) &&
	    !isDateObject(value);

	var getEventValue = (event) => isObject$2(event) && event.target
	    ? isCheckBoxInput(event.target)
	        ? event.target.checked
	        : event.target.value
	    : event;

	var getNodeParentName = (name) => name.substring(0, name.search(/\.\d+(\.|$)/)) || name;

	var isNameInFieldArray = (names, name) => names.has(getNodeParentName(name));

	var isPlainObject = (tempObject) => {
	    const prototypeCopy = tempObject.constructor && tempObject.constructor.prototype;
	    return (isObject$2(prototypeCopy) && prototypeCopy.hasOwnProperty('isPrototypeOf'));
	};

	var isWeb = typeof window !== 'undefined' &&
	    typeof window.HTMLElement !== 'undefined' &&
	    typeof document !== 'undefined';

	function cloneObject(data) {
	    let copy;
	    const isArray = Array.isArray(data);
	    const isFileListInstance = typeof FileList !== 'undefined' ? data instanceof FileList : false;
	    if (data instanceof Date) {
	        copy = new Date(data);
	    }
	    else if (!(isWeb && (data instanceof Blob || isFileListInstance)) &&
	        (isArray || isObject$2(data))) {
	        copy = isArray ? [] : Object.create(Object.getPrototypeOf(data));
	        if (!isArray && !isPlainObject(data)) {
	            copy = data;
	        }
	        else {
	            for (const key in data) {
	                if (data.hasOwnProperty(key)) {
	                    copy[key] = cloneObject(data[key]);
	                }
	            }
	        }
	    }
	    else {
	        return data;
	    }
	    return copy;
	}

	var isKey = (value) => /^\w*$/.test(value);

	var isUndefined = (val) => val === undefined;

	var compact = (value) => Array.isArray(value) ? value.filter(Boolean) : [];

	var stringToPath = (input) => compact(input.replace(/["|']|\]/g, '').split(/\.|\[/));

	var get = (object, path, defaultValue) => {
	    if (!path || !isObject$2(object)) {
	        return defaultValue;
	    }
	    const result = (isKey(path) ? [path] : stringToPath(path)).reduce((result, key) => isNullOrUndefined(result) ? result : result[key], object);
	    return isUndefined(result) || result === object
	        ? isUndefined(object[path])
	            ? defaultValue
	            : object[path]
	        : result;
	};

	var isBoolean = (value) => typeof value === 'boolean';

	var set = (object, path, value) => {
	    let index = -1;
	    const tempPath = isKey(path) ? [path] : stringToPath(path);
	    const length = tempPath.length;
	    const lastIndex = length - 1;
	    while (++index < length) {
	        const key = tempPath[index];
	        let newValue = value;
	        if (index !== lastIndex) {
	            const objValue = object[key];
	            newValue =
	                isObject$2(objValue) || Array.isArray(objValue)
	                    ? objValue
	                    : !isNaN(+tempPath[index + 1])
	                        ? []
	                        : {};
	        }
	        if (key === '__proto__' || key === 'constructor' || key === 'prototype') {
	            return;
	        }
	        object[key] = newValue;
	        object = object[key];
	    }
	};

	const EVENTS = {
	    BLUR: 'blur',
	    FOCUS_OUT: 'focusout',
	    CHANGE: 'change',
	};
	const VALIDATION_MODE = {
	    onBlur: 'onBlur',
	    onChange: 'onChange',
	    onSubmit: 'onSubmit',
	    onTouched: 'onTouched',
	    all: 'all',
	};
	const INPUT_VALIDATION_RULES = {
	    max: 'max',
	    min: 'min',
	    maxLength: 'maxLength',
	    minLength: 'minLength',
	    pattern: 'pattern',
	    required: 'required',
	    validate: 'validate',
	};

	const HookFormContext = React.createContext(null);
	HookFormContext.displayName = 'HookFormContext';
	/**
	 * This custom hook allows you to access the form context. useFormContext is intended to be used in deeply nested structures, where it would become inconvenient to pass the context as a prop. To be used with {@link FormProvider}.
	 *
	 * @remarks
	 * [API](https://react-hook-form.com/docs/useformcontext)  [Demo](https://codesandbox.io/s/react-hook-form-v7-form-context-ytudi)
	 *
	 * @returns return all useForm methods
	 *
	 * @example
	 * ```tsx
	 * function App() {
	 *   const methods = useForm();
	 *   const onSubmit = data => console.log(data);
	 *
	 *   return (
	 *     <FormProvider {...methods} >
	 *       <form onSubmit={methods.handleSubmit(onSubmit)}>
	 *         <NestedInput />
	 *         <input type="submit" />
	 *       </form>
	 *     </FormProvider>
	 *   );
	 * }
	 *
	 *  function NestedInput() {
	 *   const { register } = useFormContext(); // retrieve all hook methods
	 *   return <input {...register("test")} />;
	 * }
	 * ```
	 */
	const useFormContext = () => React.useContext(HookFormContext);

	var getProxyFormState = (formState, control, localProxyFormState, isRoot = true) => {
	    const result = {
	        defaultValues: control._defaultValues,
	    };
	    for (const key in formState) {
	        Object.defineProperty(result, key, {
	            get: () => {
	                const _key = key;
	                if (control._proxyFormState[_key] !== VALIDATION_MODE.all) {
	                    control._proxyFormState[_key] = !isRoot || VALIDATION_MODE.all;
	                }
	                localProxyFormState && (localProxyFormState[_key] = true);
	                return formState[_key];
	            },
	        });
	    }
	    return result;
	};

	const useIsomorphicLayoutEffect = typeof window !== 'undefined' ? React.useLayoutEffect : React.useEffect;

	/**
	 * This custom hook allows you to subscribe to each form state, and isolate the re-render at the custom hook level. It has its scope in terms of form state subscription, so it would not affect other useFormState and useForm. Using this hook can reduce the re-render impact on large and complex form application.
	 *
	 * @remarks
	 * [API](https://react-hook-form.com/docs/useformstate)  [Demo](https://codesandbox.io/s/useformstate-75xly)
	 *
	 * @param props - include options on specify fields to subscribe. {@link UseFormStateReturn}
	 *
	 * @example
	 * ```tsx
	 * function App() {
	 *   const { register, handleSubmit, control } = useForm({
	 *     defaultValues: {
	 *     firstName: "firstName"
	 *   }});
	 *   const { dirtyFields } = useFormState({
	 *     control
	 *   });
	 *   const onSubmit = (data) => console.log(data);
	 *
	 *   return (
	 *     <form onSubmit={handleSubmit(onSubmit)}>
	 *       <input {...register("firstName")} placeholder="First Name" />
	 *       {dirtyFields.firstName && <p>Field is dirty.</p>}
	 *       <input type="submit" />
	 *     </form>
	 *   );
	 * }
	 * ```
	 */
	function useFormState(props) {
	    const methods = useFormContext();
	    const { control = methods.control, disabled, name, exact } = props || {};
	    const [formState, updateFormState] = React.useState(control._formState);
	    const _localProxyFormState = React.useRef({
	        isDirty: false,
	        isLoading: false,
	        dirtyFields: false,
	        touchedFields: false,
	        validatingFields: false,
	        isValidating: false,
	        isValid: false,
	        errors: false,
	    });
	    useIsomorphicLayoutEffect(() => control._subscribe({
	        name,
	        formState: _localProxyFormState.current,
	        exact,
	        callback: (formState) => {
	            !disabled &&
	                updateFormState({
	                    ...control._formState,
	                    ...formState,
	                });
	        },
	    }), [name, disabled, exact]);
	    React.useEffect(() => {
	        _localProxyFormState.current.isValid && control._setValid(true);
	    }, [control]);
	    return React.useMemo(() => getProxyFormState(formState, control, _localProxyFormState.current, false), [formState, control]);
	}

	var isString = (value) => typeof value === 'string';

	var generateWatchOutput = (names, _names, formValues, isGlobal, defaultValue) => {
	    if (isString(names)) {
	        isGlobal && _names.watch.add(names);
	        return get(formValues, names, defaultValue);
	    }
	    if (Array.isArray(names)) {
	        return names.map((fieldName) => (isGlobal && _names.watch.add(fieldName),
	            get(formValues, fieldName)));
	    }
	    isGlobal && (_names.watchAll = true);
	    return formValues;
	};

	var isPrimitive = (value) => isNullOrUndefined(value) || !isObjectType(value);

	function deepEqual(object1, object2, _internal_visited = new WeakSet()) {
	    if (isPrimitive(object1) || isPrimitive(object2)) {
	        return object1 === object2;
	    }
	    if (isDateObject(object1) && isDateObject(object2)) {
	        return object1.getTime() === object2.getTime();
	    }
	    const keys1 = Object.keys(object1);
	    const keys2 = Object.keys(object2);
	    if (keys1.length !== keys2.length) {
	        return false;
	    }
	    if (_internal_visited.has(object1) || _internal_visited.has(object2)) {
	        return true;
	    }
	    _internal_visited.add(object1);
	    _internal_visited.add(object2);
	    for (const key of keys1) {
	        const val1 = object1[key];
	        if (!keys2.includes(key)) {
	            return false;
	        }
	        if (key !== 'ref') {
	            const val2 = object2[key];
	            if ((isDateObject(val1) && isDateObject(val2)) ||
	                (isObject$2(val1) && isObject$2(val2)) ||
	                (Array.isArray(val1) && Array.isArray(val2))
	                ? !deepEqual(val1, val2, _internal_visited)
	                : val1 !== val2) {
	                return false;
	            }
	        }
	    }
	    return true;
	}

	/**
	 * Custom hook to subscribe to field change and isolate re-rendering at the component level.
	 *
	 * @remarks
	 *
	 * [API](https://react-hook-form.com/docs/usewatch)  [Demo](https://codesandbox.io/s/react-hook-form-v7-ts-usewatch-h9i5e)
	 *
	 * @example
	 * ```tsx
	 * const { control } = useForm();
	 * const values = useWatch({
	 *   name: "fieldName"
	 *   control,
	 * })
	 * ```
	 */
	function useWatch(props) {
	    const methods = useFormContext();
	    const { control = methods.control, name, defaultValue, disabled, exact, compute, } = props || {};
	    const _defaultValue = React.useRef(defaultValue);
	    const _compute = React.useRef(compute);
	    const _computeFormValues = React.useRef(undefined);
	    _compute.current = compute;
	    const defaultValueMemo = React.useMemo(() => control._getWatch(name, _defaultValue.current), [control, name]);
	    const [value, updateValue] = React.useState(_compute.current ? _compute.current(defaultValueMemo) : defaultValueMemo);
	    useIsomorphicLayoutEffect(() => control._subscribe({
	        name,
	        formState: {
	            values: true,
	        },
	        exact,
	        callback: (formState) => {
	            if (!disabled) {
	                const formValues = generateWatchOutput(name, control._names, formState.values || control._formValues, false, _defaultValue.current);
	                if (_compute.current) {
	                    const computedFormValues = _compute.current(formValues);
	                    if (!deepEqual(computedFormValues, _computeFormValues.current)) {
	                        updateValue(computedFormValues);
	                        _computeFormValues.current = computedFormValues;
	                    }
	                }
	                else {
	                    updateValue(formValues);
	                }
	            }
	        },
	    }), [control, disabled, name, exact]);
	    React.useEffect(() => control._removeUnmounted());
	    return value;
	}

	/**
	 * Custom hook to work with controlled component, this function provide you with both form and field level state. Re-render is isolated at the hook level.
	 *
	 * @remarks
	 * [API](https://react-hook-form.com/docs/usecontroller)  [Demo](https://codesandbox.io/s/usecontroller-0o8px)
	 *
	 * @param props - the path name to the form field value, and validation rules.
	 *
	 * @returns field properties, field and form state. {@link UseControllerReturn}
	 *
	 * @example
	 * ```tsx
	 * function Input(props) {
	 *   const { field, fieldState, formState } = useController(props);
	 *   return (
	 *     <div>
	 *       <input {...field} placeholder={props.name} />
	 *       <p>{fieldState.isTouched && "Touched"}</p>
	 *       <p>{formState.isSubmitted ? "submitted" : ""}</p>
	 *     </div>
	 *   );
	 * }
	 * ```
	 */
	function useController(props) {
	    const methods = useFormContext();
	    const { name, disabled, control = methods.control, shouldUnregister, defaultValue, } = props;
	    const isArrayField = isNameInFieldArray(control._names.array, name);
	    const defaultValueMemo = React.useMemo(() => get(control._formValues, name, get(control._defaultValues, name, defaultValue)), [control, name, defaultValue]);
	    const value = useWatch({
	        control,
	        name,
	        defaultValue: defaultValueMemo,
	        exact: true,
	    });
	    const formState = useFormState({
	        control,
	        name,
	        exact: true,
	    });
	    const _props = React.useRef(props);
	    const _previousNameRef = React.useRef(undefined);
	    const _registerProps = React.useRef(control.register(name, {
	        ...props.rules,
	        value,
	        ...(isBoolean(props.disabled) ? { disabled: props.disabled } : {}),
	    }));
	    _props.current = props;
	    const fieldState = React.useMemo(() => Object.defineProperties({}, {
	        invalid: {
	            enumerable: true,
	            get: () => !!get(formState.errors, name),
	        },
	        isDirty: {
	            enumerable: true,
	            get: () => !!get(formState.dirtyFields, name),
	        },
	        isTouched: {
	            enumerable: true,
	            get: () => !!get(formState.touchedFields, name),
	        },
	        isValidating: {
	            enumerable: true,
	            get: () => !!get(formState.validatingFields, name),
	        },
	        error: {
	            enumerable: true,
	            get: () => get(formState.errors, name),
	        },
	    }), [formState, name]);
	    const onChange = React.useCallback((event) => _registerProps.current.onChange({
	        target: {
	            value: getEventValue(event),
	            name: name,
	        },
	        type: EVENTS.CHANGE,
	    }), [name]);
	    const onBlur = React.useCallback(() => _registerProps.current.onBlur({
	        target: {
	            value: get(control._formValues, name),
	            name: name,
	        },
	        type: EVENTS.BLUR,
	    }), [name, control._formValues]);
	    const ref = React.useCallback((elm) => {
	        const field = get(control._fields, name);
	        if (field && elm) {
	            field._f.ref = {
	                focus: () => elm.focus && elm.focus(),
	                select: () => elm.select && elm.select(),
	                setCustomValidity: (message) => elm.setCustomValidity(message),
	                reportValidity: () => elm.reportValidity(),
	            };
	        }
	    }, [control._fields, name]);
	    const field = React.useMemo(() => ({
	        name,
	        value,
	        ...(isBoolean(disabled) || formState.disabled
	            ? { disabled: formState.disabled || disabled }
	            : {}),
	        onChange,
	        onBlur,
	        ref,
	    }), [name, disabled, formState.disabled, onChange, onBlur, ref, value]);
	    React.useEffect(() => {
	        const _shouldUnregisterField = control._options.shouldUnregister || shouldUnregister;
	        const previousName = _previousNameRef.current;
	        if (previousName && previousName !== name && !isArrayField) {
	            control.unregister(previousName);
	        }
	        control.register(name, {
	            ..._props.current.rules,
	            ...(isBoolean(_props.current.disabled)
	                ? { disabled: _props.current.disabled }
	                : {}),
	        });
	        const updateMounted = (name, value) => {
	            const field = get(control._fields, name);
	            if (field && field._f) {
	                field._f.mount = value;
	            }
	        };
	        updateMounted(name, true);
	        if (_shouldUnregisterField) {
	            const value = cloneObject(get(control._options.defaultValues, name, _props.current.defaultValue));
	            set(control._defaultValues, name, value);
	            if (isUndefined(get(control._formValues, name))) {
	                set(control._formValues, name, value);
	            }
	        }
	        !isArrayField && control.register(name);
	        _previousNameRef.current = name;
	        return () => {
	            (isArrayField
	                ? _shouldUnregisterField && !control._state.action
	                : _shouldUnregisterField)
	                ? control.unregister(name)
	                : updateMounted(name, false);
	        };
	    }, [name, control, isArrayField, shouldUnregister]);
	    React.useEffect(() => {
	        control._setDisabledField({
	            disabled,
	            name,
	        });
	    }, [disabled, name, control]);
	    return React.useMemo(() => ({
	        field,
	        formState,
	        fieldState,
	    }), [field, formState, fieldState]);
	}

	/**
	 * Component based on `useController` hook to work with controlled component.
	 *
	 * @remarks
	 * [API](https://react-hook-form.com/docs/usecontroller/controller)  [Demo](https://codesandbox.io/s/react-hook-form-v6-controller-ts-jwyzw)  [Video](https://www.youtube.com/watch?v=N2UNk_UCVyA)
	 *
	 * @param props - the path name to the form field value, and validation rules.
	 *
	 * @returns provide field handler functions, field and form state.
	 *
	 * @example
	 * ```tsx
	 * function App() {
	 *   const { control } = useForm<FormValues>({
	 *     defaultValues: {
	 *       test: ""
	 *     }
	 *   });
	 *
	 *   return (
	 *     <form>
	 *       <Controller
	 *         control={control}
	 *         name="test"
	 *         render={({ field: { onChange, onBlur, value, ref }, formState, fieldState }) => (
	 *           <>
	 *             <input
	 *               onChange={onChange} // send value to hook form
	 *               onBlur={onBlur} // notify when input is touched
	 *               value={value} // return updated value
	 *               ref={ref} // set ref for focus management
	 *             />
	 *             <p>{formState.isSubmitted ? "submitted" : ""}</p>
	 *             <p>{fieldState.isTouched ? "touched" : ""}</p>
	 *           </>
	 *         )}
	 *       />
	 *     </form>
	 *   );
	 * }
	 * ```
	 */
	const Controller = (props) => props.render(useController(props));

	var appendErrors = (name, validateAllFieldCriteria, errors, type, message) => validateAllFieldCriteria
	    ? {
	        ...errors[name],
	        types: {
	            ...(errors[name] && errors[name].types ? errors[name].types : {}),
	            [type]: message || true,
	        },
	    }
	    : {};

	var convertToArrayPayload = (value) => (Array.isArray(value) ? value : [value]);

	var createSubject = () => {
	    let _observers = [];
	    const next = (value) => {
	        for (const observer of _observers) {
	            observer.next && observer.next(value);
	        }
	    };
	    const subscribe = (observer) => {
	        _observers.push(observer);
	        return {
	            unsubscribe: () => {
	                _observers = _observers.filter((o) => o !== observer);
	            },
	        };
	    };
	    const unsubscribe = () => {
	        _observers = [];
	    };
	    return {
	        get observers() {
	            return _observers;
	        },
	        next,
	        subscribe,
	        unsubscribe,
	    };
	};

	function extractFormValues(fieldsState, formValues) {
	    const values = {};
	    for (const key in fieldsState) {
	        if (fieldsState.hasOwnProperty(key)) {
	            const fieldState = fieldsState[key];
	            const fieldValue = formValues[key];
	            if (fieldState && isObject$2(fieldState) && fieldValue) {
	                const nestedFieldsState = extractFormValues(fieldState, fieldValue);
	                if (isObject$2(nestedFieldsState)) {
	                    values[key] = nestedFieldsState;
	                }
	            }
	            else if (fieldsState[key]) {
	                values[key] = fieldValue;
	            }
	        }
	    }
	    return values;
	}

	var isEmptyObject = (value) => isObject$2(value) && !Object.keys(value).length;

	var isFileInput = (element) => element.type === 'file';

	var isFunction = (value) => typeof value === 'function';

	var isHTMLElement = (value) => {
	    if (!isWeb) {
	        return false;
	    }
	    const owner = value ? value.ownerDocument : 0;
	    return (value instanceof
	        (owner && owner.defaultView ? owner.defaultView.HTMLElement : HTMLElement));
	};

	var isMultipleSelect = (element) => element.type === `select-multiple`;

	var isRadioInput = (element) => element.type === 'radio';

	var isRadioOrCheckbox = (ref) => isRadioInput(ref) || isCheckBoxInput(ref);

	var live = (ref) => isHTMLElement(ref) && ref.isConnected;

	function baseGet(object, updatePath) {
	    const length = updatePath.slice(0, -1).length;
	    let index = 0;
	    while (index < length) {
	        object = isUndefined(object) ? index++ : object[updatePath[index++]];
	    }
	    return object;
	}
	function isEmptyArray(obj) {
	    for (const key in obj) {
	        if (obj.hasOwnProperty(key) && !isUndefined(obj[key])) {
	            return false;
	        }
	    }
	    return true;
	}
	function unset(object, path) {
	    const paths = Array.isArray(path)
	        ? path
	        : isKey(path)
	            ? [path]
	            : stringToPath(path);
	    const childObject = paths.length === 1 ? object : baseGet(object, paths);
	    const index = paths.length - 1;
	    const key = paths[index];
	    if (childObject) {
	        delete childObject[key];
	    }
	    if (index !== 0 &&
	        ((isObject$2(childObject) && isEmptyObject(childObject)) ||
	            (Array.isArray(childObject) && isEmptyArray(childObject)))) {
	        unset(object, paths.slice(0, -1));
	    }
	    return object;
	}

	var objectHasFunction = (data) => {
	    for (const key in data) {
	        if (isFunction(data[key])) {
	            return true;
	        }
	    }
	    return false;
	};

	function isTraversable(value) {
	    return Array.isArray(value) || (isObject$2(value) && !objectHasFunction(value));
	}
	function markFieldsDirty(data, fields = {}) {
	    for (const key in data) {
	        if (isTraversable(data[key])) {
	            fields[key] = Array.isArray(data[key]) ? [] : {};
	            markFieldsDirty(data[key], fields[key]);
	        }
	        else if (!isUndefined(data[key])) {
	            fields[key] = true;
	        }
	    }
	    return fields;
	}
	function getDirtyFields(data, formValues, dirtyFieldsFromValues) {
	    if (!dirtyFieldsFromValues) {
	        dirtyFieldsFromValues = markFieldsDirty(formValues);
	    }
	    for (const key in data) {
	        if (isTraversable(data[key])) {
	            if (isUndefined(formValues) || isPrimitive(dirtyFieldsFromValues[key])) {
	                dirtyFieldsFromValues[key] = markFieldsDirty(data[key], Array.isArray(data[key]) ? [] : {});
	            }
	            else {
	                getDirtyFields(data[key], isNullOrUndefined(formValues) ? {} : formValues[key], dirtyFieldsFromValues[key]);
	            }
	        }
	        else {
	            dirtyFieldsFromValues[key] = !deepEqual(data[key], formValues[key]);
	        }
	    }
	    return dirtyFieldsFromValues;
	}

	const defaultResult = {
	    value: false,
	    isValid: false,
	};
	const validResult = { value: true, isValid: true };
	var getCheckboxValue = (options) => {
	    if (Array.isArray(options)) {
	        if (options.length > 1) {
	            const values = options
	                .filter((option) => option && option.checked && !option.disabled)
	                .map((option) => option.value);
	            return { value: values, isValid: !!values.length };
	        }
	        return options[0].checked && !options[0].disabled
	            ? // @ts-expect-error expected to work in the browser
	                options[0].attributes && !isUndefined(options[0].attributes.value)
	                    ? isUndefined(options[0].value) || options[0].value === ''
	                        ? validResult
	                        : { value: options[0].value, isValid: true }
	                    : validResult
	            : defaultResult;
	    }
	    return defaultResult;
	};

	var getFieldValueAs = (value, { valueAsNumber, valueAsDate, setValueAs }) => isUndefined(value)
	    ? value
	    : valueAsNumber
	        ? value === ''
	            ? NaN
	            : value
	                ? +value
	                : value
	        : valueAsDate && isString(value)
	            ? new Date(value)
	            : setValueAs
	                ? setValueAs(value)
	                : value;

	const defaultReturn = {
	    isValid: false,
	    value: null,
	};
	var getRadioValue = (options) => Array.isArray(options)
	    ? options.reduce((previous, option) => option && option.checked && !option.disabled
	        ? {
	            isValid: true,
	            value: option.value,
	        }
	        : previous, defaultReturn)
	    : defaultReturn;

	function getFieldValue(_f) {
	    const ref = _f.ref;
	    if (isFileInput(ref)) {
	        return ref.files;
	    }
	    if (isRadioInput(ref)) {
	        return getRadioValue(_f.refs).value;
	    }
	    if (isMultipleSelect(ref)) {
	        return [...ref.selectedOptions].map(({ value }) => value);
	    }
	    if (isCheckBoxInput(ref)) {
	        return getCheckboxValue(_f.refs).value;
	    }
	    return getFieldValueAs(isUndefined(ref.value) ? _f.ref.value : ref.value, _f);
	}

	var getResolverOptions = (fieldsNames, _fields, criteriaMode, shouldUseNativeValidation) => {
	    const fields = {};
	    for (const name of fieldsNames) {
	        const field = get(_fields, name);
	        field && set(fields, name, field._f);
	    }
	    return {
	        criteriaMode,
	        names: [...fieldsNames],
	        fields,
	        shouldUseNativeValidation,
	    };
	};

	var isRegex = (value) => value instanceof RegExp;

	var getRuleValue = (rule) => isUndefined(rule)
	    ? rule
	    : isRegex(rule)
	        ? rule.source
	        : isObject$2(rule)
	            ? isRegex(rule.value)
	                ? rule.value.source
	                : rule.value
	            : rule;

	var getValidationModes = (mode) => ({
	    isOnSubmit: !mode || mode === VALIDATION_MODE.onSubmit,
	    isOnBlur: mode === VALIDATION_MODE.onBlur,
	    isOnChange: mode === VALIDATION_MODE.onChange,
	    isOnAll: mode === VALIDATION_MODE.all,
	    isOnTouch: mode === VALIDATION_MODE.onTouched,
	});

	const ASYNC_FUNCTION = 'AsyncFunction';
	var hasPromiseValidation = (fieldReference) => !!fieldReference &&
	    !!fieldReference.validate &&
	    !!((isFunction(fieldReference.validate) &&
	        fieldReference.validate.constructor.name === ASYNC_FUNCTION) ||
	        (isObject$2(fieldReference.validate) &&
	            Object.values(fieldReference.validate).find((validateFunction) => validateFunction.constructor.name === ASYNC_FUNCTION)));

	var hasValidation = (options) => options.mount &&
	    (options.required ||
	        options.min ||
	        options.max ||
	        options.maxLength ||
	        options.minLength ||
	        options.pattern ||
	        options.validate);

	var isWatched = (name, _names, isBlurEvent) => !isBlurEvent &&
	    (_names.watchAll ||
	        _names.watch.has(name) ||
	        [..._names.watch].some((watchName) => name.startsWith(watchName) &&
	            /^\.\w+/.test(name.slice(watchName.length))));

	const iterateFieldsByAction = (fields, action, fieldsNames, abortEarly) => {
	    for (const key of fieldsNames || Object.keys(fields)) {
	        const field = get(fields, key);
	        if (field) {
	            const { _f, ...currentField } = field;
	            if (_f) {
	                if (_f.refs && _f.refs[0] && action(_f.refs[0], key) && !abortEarly) {
	                    return true;
	                }
	                else if (_f.ref && action(_f.ref, _f.name) && !abortEarly) {
	                    return true;
	                }
	                else {
	                    if (iterateFieldsByAction(currentField, action)) {
	                        break;
	                    }
	                }
	            }
	            else if (isObject$2(currentField)) {
	                if (iterateFieldsByAction(currentField, action)) {
	                    break;
	                }
	            }
	        }
	    }
	    return;
	};

	function schemaErrorLookup(errors, _fields, name) {
	    const error = get(errors, name);
	    if (error || isKey(name)) {
	        return {
	            error,
	            name,
	        };
	    }
	    const names = name.split('.');
	    while (names.length) {
	        const fieldName = names.join('.');
	        const field = get(_fields, fieldName);
	        const foundError = get(errors, fieldName);
	        if (field && !Array.isArray(field) && name !== fieldName) {
	            return { name };
	        }
	        if (foundError && foundError.type) {
	            return {
	                name: fieldName,
	                error: foundError,
	            };
	        }
	        if (foundError && foundError.root && foundError.root.type) {
	            return {
	                name: `${fieldName}.root`,
	                error: foundError.root,
	            };
	        }
	        names.pop();
	    }
	    return {
	        name,
	    };
	}

	var shouldRenderFormState = (formStateData, _proxyFormState, updateFormState, isRoot) => {
	    updateFormState(formStateData);
	    const { name, ...formState } = formStateData;
	    return (isEmptyObject(formState) ||
	        Object.keys(formState).length >= Object.keys(_proxyFormState).length ||
	        Object.keys(formState).find((key) => _proxyFormState[key] ===
	            (!isRoot || VALIDATION_MODE.all)));
	};

	var shouldSubscribeByName = (name, signalName, exact) => !name ||
	    !signalName ||
	    name === signalName ||
	    convertToArrayPayload(name).some((currentName) => currentName &&
	        (exact
	            ? currentName === signalName
	            : currentName.startsWith(signalName) ||
	                signalName.startsWith(currentName)));

	var skipValidation = (isBlurEvent, isTouched, isSubmitted, reValidateMode, mode) => {
	    if (mode.isOnAll) {
	        return false;
	    }
	    else if (!isSubmitted && mode.isOnTouch) {
	        return !(isTouched || isBlurEvent);
	    }
	    else if (isSubmitted ? reValidateMode.isOnBlur : mode.isOnBlur) {
	        return !isBlurEvent;
	    }
	    else if (isSubmitted ? reValidateMode.isOnChange : mode.isOnChange) {
	        return isBlurEvent;
	    }
	    return true;
	};

	var unsetEmptyArray = (ref, name) => !compact(get(ref, name)).length && unset(ref, name);

	var updateFieldArrayRootError = (errors, error, name) => {
	    const fieldArrayErrors = convertToArrayPayload(get(errors, name));
	    set(fieldArrayErrors, 'root', error[name]);
	    set(errors, name, fieldArrayErrors);
	    return errors;
	};

	function getValidateError(result, ref, type = 'validate') {
	    if (isString(result) ||
	        (Array.isArray(result) && result.every(isString)) ||
	        (isBoolean(result) && !result)) {
	        return {
	            type,
	            message: isString(result) ? result : '',
	            ref,
	        };
	    }
	}

	var getValueAndMessage = (validationData) => isObject$2(validationData) && !isRegex(validationData)
	    ? validationData
	    : {
	        value: validationData,
	        message: '',
	    };

	var validateField = async (field, disabledFieldNames, formValues, validateAllFieldCriteria, shouldUseNativeValidation, isFieldArray) => {
	    const { ref, refs, required, maxLength, minLength, min, max, pattern, validate, name, valueAsNumber, mount, } = field._f;
	    const inputValue = get(formValues, name);
	    if (!mount || disabledFieldNames.has(name)) {
	        return {};
	    }
	    const inputRef = refs ? refs[0] : ref;
	    const setCustomValidity = (message) => {
	        if (shouldUseNativeValidation && inputRef.reportValidity) {
	            inputRef.setCustomValidity(isBoolean(message) ? '' : message || '');
	            inputRef.reportValidity();
	        }
	    };
	    const error = {};
	    const isRadio = isRadioInput(ref);
	    const isCheckBox = isCheckBoxInput(ref);
	    const isRadioOrCheckbox = isRadio || isCheckBox;
	    const isEmpty = ((valueAsNumber || isFileInput(ref)) &&
	        isUndefined(ref.value) &&
	        isUndefined(inputValue)) ||
	        (isHTMLElement(ref) && ref.value === '') ||
	        inputValue === '' ||
	        (Array.isArray(inputValue) && !inputValue.length);
	    const appendErrorsCurry = appendErrors.bind(null, name, validateAllFieldCriteria, error);
	    const getMinMaxMessage = (exceedMax, maxLengthMessage, minLengthMessage, maxType = INPUT_VALIDATION_RULES.maxLength, minType = INPUT_VALIDATION_RULES.minLength) => {
	        const message = exceedMax ? maxLengthMessage : minLengthMessage;
	        error[name] = {
	            type: exceedMax ? maxType : minType,
	            message,
	            ref,
	            ...appendErrorsCurry(exceedMax ? maxType : minType, message),
	        };
	    };
	    if (isFieldArray
	        ? !Array.isArray(inputValue) || !inputValue.length
	        : required &&
	            ((!isRadioOrCheckbox && (isEmpty || isNullOrUndefined(inputValue))) ||
	                (isBoolean(inputValue) && !inputValue) ||
	                (isCheckBox && !getCheckboxValue(refs).isValid) ||
	                (isRadio && !getRadioValue(refs).isValid))) {
	        const { value, message } = isString(required)
	            ? { value: !!required, message: required }
	            : getValueAndMessage(required);
	        if (value) {
	            error[name] = {
	                type: INPUT_VALIDATION_RULES.required,
	                message,
	                ref: inputRef,
	                ...appendErrorsCurry(INPUT_VALIDATION_RULES.required, message),
	            };
	            if (!validateAllFieldCriteria) {
	                setCustomValidity(message);
	                return error;
	            }
	        }
	    }
	    if (!isEmpty && (!isNullOrUndefined(min) || !isNullOrUndefined(max))) {
	        let exceedMax;
	        let exceedMin;
	        const maxOutput = getValueAndMessage(max);
	        const minOutput = getValueAndMessage(min);
	        if (!isNullOrUndefined(inputValue) && !isNaN(inputValue)) {
	            const valueNumber = ref.valueAsNumber ||
	                (inputValue ? +inputValue : inputValue);
	            if (!isNullOrUndefined(maxOutput.value)) {
	                exceedMax = valueNumber > maxOutput.value;
	            }
	            if (!isNullOrUndefined(minOutput.value)) {
	                exceedMin = valueNumber < minOutput.value;
	            }
	        }
	        else {
	            const valueDate = ref.valueAsDate || new Date(inputValue);
	            const convertTimeToDate = (time) => new Date(new Date().toDateString() + ' ' + time);
	            const isTime = ref.type == 'time';
	            const isWeek = ref.type == 'week';
	            if (isString(maxOutput.value) && inputValue) {
	                exceedMax = isTime
	                    ? convertTimeToDate(inputValue) > convertTimeToDate(maxOutput.value)
	                    : isWeek
	                        ? inputValue > maxOutput.value
	                        : valueDate > new Date(maxOutput.value);
	            }
	            if (isString(minOutput.value) && inputValue) {
	                exceedMin = isTime
	                    ? convertTimeToDate(inputValue) < convertTimeToDate(minOutput.value)
	                    : isWeek
	                        ? inputValue < minOutput.value
	                        : valueDate < new Date(minOutput.value);
	            }
	        }
	        if (exceedMax || exceedMin) {
	            getMinMaxMessage(!!exceedMax, maxOutput.message, minOutput.message, INPUT_VALIDATION_RULES.max, INPUT_VALIDATION_RULES.min);
	            if (!validateAllFieldCriteria) {
	                setCustomValidity(error[name].message);
	                return error;
	            }
	        }
	    }
	    if ((maxLength || minLength) &&
	        !isEmpty &&
	        (isString(inputValue) || (isFieldArray && Array.isArray(inputValue)))) {
	        const maxLengthOutput = getValueAndMessage(maxLength);
	        const minLengthOutput = getValueAndMessage(minLength);
	        const exceedMax = !isNullOrUndefined(maxLengthOutput.value) &&
	            inputValue.length > +maxLengthOutput.value;
	        const exceedMin = !isNullOrUndefined(minLengthOutput.value) &&
	            inputValue.length < +minLengthOutput.value;
	        if (exceedMax || exceedMin) {
	            getMinMaxMessage(exceedMax, maxLengthOutput.message, minLengthOutput.message);
	            if (!validateAllFieldCriteria) {
	                setCustomValidity(error[name].message);
	                return error;
	            }
	        }
	    }
	    if (pattern && !isEmpty && isString(inputValue)) {
	        const { value: patternValue, message } = getValueAndMessage(pattern);
	        if (isRegex(patternValue) && !inputValue.match(patternValue)) {
	            error[name] = {
	                type: INPUT_VALIDATION_RULES.pattern,
	                message,
	                ref,
	                ...appendErrorsCurry(INPUT_VALIDATION_RULES.pattern, message),
	            };
	            if (!validateAllFieldCriteria) {
	                setCustomValidity(message);
	                return error;
	            }
	        }
	    }
	    if (validate) {
	        if (isFunction(validate)) {
	            const result = await validate(inputValue, formValues);
	            const validateError = getValidateError(result, inputRef);
	            if (validateError) {
	                error[name] = {
	                    ...validateError,
	                    ...appendErrorsCurry(INPUT_VALIDATION_RULES.validate, validateError.message),
	                };
	                if (!validateAllFieldCriteria) {
	                    setCustomValidity(validateError.message);
	                    return error;
	                }
	            }
	        }
	        else if (isObject$2(validate)) {
	            let validationResult = {};
	            for (const key in validate) {
	                if (!isEmptyObject(validationResult) && !validateAllFieldCriteria) {
	                    break;
	                }
	                const validateError = getValidateError(await validate[key](inputValue, formValues), inputRef, key);
	                if (validateError) {
	                    validationResult = {
	                        ...validateError,
	                        ...appendErrorsCurry(key, validateError.message),
	                    };
	                    setCustomValidity(validateError.message);
	                    if (validateAllFieldCriteria) {
	                        error[name] = validationResult;
	                    }
	                }
	            }
	            if (!isEmptyObject(validationResult)) {
	                error[name] = {
	                    ref: inputRef,
	                    ...validationResult,
	                };
	                if (!validateAllFieldCriteria) {
	                    return error;
	                }
	            }
	        }
	    }
	    setCustomValidity(true);
	    return error;
	};

	const defaultOptions$1 = {
	    mode: VALIDATION_MODE.onSubmit,
	    reValidateMode: VALIDATION_MODE.onChange,
	    shouldFocusError: true,
	};
	function createFormControl(props = {}) {
	    let _options = {
	        ...defaultOptions$1,
	        ...props,
	    };
	    let _formState = {
	        submitCount: 0,
	        isDirty: false,
	        isReady: false,
	        isLoading: isFunction(_options.defaultValues),
	        isValidating: false,
	        isSubmitted: false,
	        isSubmitting: false,
	        isSubmitSuccessful: false,
	        isValid: false,
	        touchedFields: {},
	        dirtyFields: {},
	        validatingFields: {},
	        errors: _options.errors || {},
	        disabled: _options.disabled || false,
	    };
	    let _fields = {};
	    let _defaultValues = isObject$2(_options.defaultValues) || isObject$2(_options.values)
	        ? cloneObject(_options.defaultValues || _options.values) || {}
	        : {};
	    let _formValues = _options.shouldUnregister
	        ? {}
	        : cloneObject(_defaultValues);
	    let _state = {
	        action: false,
	        mount: false,
	        watch: false,
	    };
	    let _names = {
	        mount: new Set(),
	        disabled: new Set(),
	        unMount: new Set(),
	        array: new Set(),
	        watch: new Set(),
	    };
	    let delayErrorCallback;
	    let timer = 0;
	    const _proxyFormState = {
	        isDirty: false,
	        dirtyFields: false,
	        validatingFields: false,
	        touchedFields: false,
	        isValidating: false,
	        isValid: false,
	        errors: false,
	    };
	    let _proxySubscribeFormState = {
	        ..._proxyFormState,
	    };
	    const _subjects = {
	        array: createSubject(),
	        state: createSubject(),
	    };
	    const shouldDisplayAllAssociatedErrors = _options.criteriaMode === VALIDATION_MODE.all;
	    const debounce = (callback) => (wait) => {
	        clearTimeout(timer);
	        timer = setTimeout(callback, wait);
	    };
	    const _setValid = async (shouldUpdateValid) => {
	        if (!_options.disabled &&
	            (_proxyFormState.isValid ||
	                _proxySubscribeFormState.isValid ||
	                shouldUpdateValid)) {
	            const isValid = _options.resolver
	                ? isEmptyObject((await _runSchema()).errors)
	                : await executeBuiltInValidation(_fields, true);
	            if (isValid !== _formState.isValid) {
	                _subjects.state.next({
	                    isValid,
	                });
	            }
	        }
	    };
	    const _updateIsValidating = (names, isValidating) => {
	        if (!_options.disabled &&
	            (_proxyFormState.isValidating ||
	                _proxyFormState.validatingFields ||
	                _proxySubscribeFormState.isValidating ||
	                _proxySubscribeFormState.validatingFields)) {
	            (names || Array.from(_names.mount)).forEach((name) => {
	                if (name) {
	                    isValidating
	                        ? set(_formState.validatingFields, name, isValidating)
	                        : unset(_formState.validatingFields, name);
	                }
	            });
	            _subjects.state.next({
	                validatingFields: _formState.validatingFields,
	                isValidating: !isEmptyObject(_formState.validatingFields),
	            });
	        }
	    };
	    const _setFieldArray = (name, values = [], method, args, shouldSetValues = true, shouldUpdateFieldsAndState = true) => {
	        if (args && method && !_options.disabled) {
	            _state.action = true;
	            if (shouldUpdateFieldsAndState && Array.isArray(get(_fields, name))) {
	                const fieldValues = method(get(_fields, name), args.argA, args.argB);
	                shouldSetValues && set(_fields, name, fieldValues);
	            }
	            if (shouldUpdateFieldsAndState &&
	                Array.isArray(get(_formState.errors, name))) {
	                const errors = method(get(_formState.errors, name), args.argA, args.argB);
	                shouldSetValues && set(_formState.errors, name, errors);
	                unsetEmptyArray(_formState.errors, name);
	            }
	            if ((_proxyFormState.touchedFields ||
	                _proxySubscribeFormState.touchedFields) &&
	                shouldUpdateFieldsAndState &&
	                Array.isArray(get(_formState.touchedFields, name))) {
	                const touchedFields = method(get(_formState.touchedFields, name), args.argA, args.argB);
	                shouldSetValues && set(_formState.touchedFields, name, touchedFields);
	            }
	            if (_proxyFormState.dirtyFields || _proxySubscribeFormState.dirtyFields) {
	                _formState.dirtyFields = getDirtyFields(_defaultValues, _formValues);
	            }
	            _subjects.state.next({
	                name,
	                isDirty: _getDirty(name, values),
	                dirtyFields: _formState.dirtyFields,
	                errors: _formState.errors,
	                isValid: _formState.isValid,
	            });
	        }
	        else {
	            set(_formValues, name, values);
	        }
	    };
	    const updateErrors = (name, error) => {
	        set(_formState.errors, name, error);
	        _subjects.state.next({
	            errors: _formState.errors,
	        });
	    };
	    const _setErrors = (errors) => {
	        _formState.errors = errors;
	        _subjects.state.next({
	            errors: _formState.errors,
	            isValid: false,
	        });
	    };
	    const updateValidAndValue = (name, shouldSkipSetValueAs, value, ref) => {
	        const field = get(_fields, name);
	        if (field) {
	            const defaultValue = get(_formValues, name, isUndefined(value) ? get(_defaultValues, name) : value);
	            isUndefined(defaultValue) ||
	                (ref && ref.defaultChecked) ||
	                shouldSkipSetValueAs
	                ? set(_formValues, name, shouldSkipSetValueAs ? defaultValue : getFieldValue(field._f))
	                : setFieldValue(name, defaultValue);
	            _state.mount && _setValid();
	        }
	    };
	    const updateTouchAndDirty = (name, fieldValue, isBlurEvent, shouldDirty, shouldRender) => {
	        let shouldUpdateField = false;
	        let isPreviousDirty = false;
	        const output = {
	            name,
	        };
	        if (!_options.disabled) {
	            if (!isBlurEvent || shouldDirty) {
	                if (_proxyFormState.isDirty || _proxySubscribeFormState.isDirty) {
	                    isPreviousDirty = _formState.isDirty;
	                    _formState.isDirty = output.isDirty = _getDirty();
	                    shouldUpdateField = isPreviousDirty !== output.isDirty;
	                }
	                const isCurrentFieldPristine = deepEqual(get(_defaultValues, name), fieldValue);
	                isPreviousDirty = !!get(_formState.dirtyFields, name);
	                isCurrentFieldPristine
	                    ? unset(_formState.dirtyFields, name)
	                    : set(_formState.dirtyFields, name, true);
	                output.dirtyFields = _formState.dirtyFields;
	                shouldUpdateField =
	                    shouldUpdateField ||
	                        ((_proxyFormState.dirtyFields ||
	                            _proxySubscribeFormState.dirtyFields) &&
	                            isPreviousDirty !== !isCurrentFieldPristine);
	            }
	            if (isBlurEvent) {
	                const isPreviousFieldTouched = get(_formState.touchedFields, name);
	                if (!isPreviousFieldTouched) {
	                    set(_formState.touchedFields, name, isBlurEvent);
	                    output.touchedFields = _formState.touchedFields;
	                    shouldUpdateField =
	                        shouldUpdateField ||
	                            ((_proxyFormState.touchedFields ||
	                                _proxySubscribeFormState.touchedFields) &&
	                                isPreviousFieldTouched !== isBlurEvent);
	                }
	            }
	            shouldUpdateField && shouldRender && _subjects.state.next(output);
	        }
	        return shouldUpdateField ? output : {};
	    };
	    const shouldRenderByError = (name, isValid, error, fieldState) => {
	        const previousFieldError = get(_formState.errors, name);
	        const shouldUpdateValid = (_proxyFormState.isValid || _proxySubscribeFormState.isValid) &&
	            isBoolean(isValid) &&
	            _formState.isValid !== isValid;
	        if (_options.delayError && error) {
	            delayErrorCallback = debounce(() => updateErrors(name, error));
	            delayErrorCallback(_options.delayError);
	        }
	        else {
	            clearTimeout(timer);
	            delayErrorCallback = null;
	            error
	                ? set(_formState.errors, name, error)
	                : unset(_formState.errors, name);
	        }
	        if ((error ? !deepEqual(previousFieldError, error) : previousFieldError) ||
	            !isEmptyObject(fieldState) ||
	            shouldUpdateValid) {
	            const updatedFormState = {
	                ...fieldState,
	                ...(shouldUpdateValid && isBoolean(isValid) ? { isValid } : {}),
	                errors: _formState.errors,
	                name,
	            };
	            _formState = {
	                ..._formState,
	                ...updatedFormState,
	            };
	            _subjects.state.next(updatedFormState);
	        }
	    };
	    const _runSchema = async (name) => {
	        _updateIsValidating(name, true);
	        const result = await _options.resolver(_formValues, _options.context, getResolverOptions(name || _names.mount, _fields, _options.criteriaMode, _options.shouldUseNativeValidation));
	        _updateIsValidating(name);
	        return result;
	    };
	    const executeSchemaAndUpdateState = async (names) => {
	        const { errors } = await _runSchema(names);
	        if (names) {
	            for (const name of names) {
	                const error = get(errors, name);
	                error
	                    ? set(_formState.errors, name, error)
	                    : unset(_formState.errors, name);
	            }
	        }
	        else {
	            _formState.errors = errors;
	        }
	        return errors;
	    };
	    const executeBuiltInValidation = async (fields, shouldOnlyCheckValid, context = {
	        valid: true,
	    }) => {
	        for (const name in fields) {
	            const field = fields[name];
	            if (field) {
	                const { _f, ...fieldValue } = field;
	                if (_f) {
	                    const isFieldArrayRoot = _names.array.has(_f.name);
	                    const isPromiseFunction = field._f && hasPromiseValidation(field._f);
	                    if (isPromiseFunction && _proxyFormState.validatingFields) {
	                        _updateIsValidating([_f.name], true);
	                    }
	                    const fieldError = await validateField(field, _names.disabled, _formValues, shouldDisplayAllAssociatedErrors, _options.shouldUseNativeValidation && !shouldOnlyCheckValid, isFieldArrayRoot);
	                    if (isPromiseFunction && _proxyFormState.validatingFields) {
	                        _updateIsValidating([_f.name]);
	                    }
	                    if (fieldError[_f.name]) {
	                        context.valid = false;
	                        if (shouldOnlyCheckValid) {
	                            break;
	                        }
	                    }
	                    !shouldOnlyCheckValid &&
	                        (get(fieldError, _f.name)
	                            ? isFieldArrayRoot
	                                ? updateFieldArrayRootError(_formState.errors, fieldError, _f.name)
	                                : set(_formState.errors, _f.name, fieldError[_f.name])
	                            : unset(_formState.errors, _f.name));
	                }
	                !isEmptyObject(fieldValue) &&
	                    (await executeBuiltInValidation(fieldValue, shouldOnlyCheckValid, context));
	            }
	        }
	        return context.valid;
	    };
	    const _removeUnmounted = () => {
	        for (const name of _names.unMount) {
	            const field = get(_fields, name);
	            field &&
	                (field._f.refs
	                    ? field._f.refs.every((ref) => !live(ref))
	                    : !live(field._f.ref)) &&
	                unregister(name);
	        }
	        _names.unMount = new Set();
	    };
	    const _getDirty = (name, data) => !_options.disabled &&
	        (name && data && set(_formValues, name, data),
	            !deepEqual(getValues(), _defaultValues));
	    const _getWatch = (names, defaultValue, isGlobal) => generateWatchOutput(names, _names, {
	        ...(_state.mount
	            ? _formValues
	            : isUndefined(defaultValue)
	                ? _defaultValues
	                : isString(names)
	                    ? { [names]: defaultValue }
	                    : defaultValue),
	    }, isGlobal, defaultValue);
	    const _getFieldArray = (name) => compact(get(_state.mount ? _formValues : _defaultValues, name, _options.shouldUnregister ? get(_defaultValues, name, []) : []));
	    const setFieldValue = (name, value, options = {}) => {
	        const field = get(_fields, name);
	        let fieldValue = value;
	        if (field) {
	            const fieldReference = field._f;
	            if (fieldReference) {
	                !fieldReference.disabled &&
	                    set(_formValues, name, getFieldValueAs(value, fieldReference));
	                fieldValue =
	                    isHTMLElement(fieldReference.ref) && isNullOrUndefined(value)
	                        ? ''
	                        : value;
	                if (isMultipleSelect(fieldReference.ref)) {
	                    [...fieldReference.ref.options].forEach((optionRef) => (optionRef.selected = fieldValue.includes(optionRef.value)));
	                }
	                else if (fieldReference.refs) {
	                    if (isCheckBoxInput(fieldReference.ref)) {
	                        fieldReference.refs.forEach((checkboxRef) => {
	                            if (!checkboxRef.defaultChecked || !checkboxRef.disabled) {
	                                if (Array.isArray(fieldValue)) {
	                                    checkboxRef.checked = !!fieldValue.find((data) => data === checkboxRef.value);
	                                }
	                                else {
	                                    checkboxRef.checked =
	                                        fieldValue === checkboxRef.value || !!fieldValue;
	                                }
	                            }
	                        });
	                    }
	                    else {
	                        fieldReference.refs.forEach((radioRef) => (radioRef.checked = radioRef.value === fieldValue));
	                    }
	                }
	                else if (isFileInput(fieldReference.ref)) {
	                    fieldReference.ref.value = '';
	                }
	                else {
	                    fieldReference.ref.value = fieldValue;
	                    if (!fieldReference.ref.type) {
	                        _subjects.state.next({
	                            name,
	                            values: cloneObject(_formValues),
	                        });
	                    }
	                }
	            }
	        }
	        (options.shouldDirty || options.shouldTouch) &&
	            updateTouchAndDirty(name, fieldValue, options.shouldTouch, options.shouldDirty, true);
	        options.shouldValidate && trigger(name);
	    };
	    const setValues = (name, value, options) => {
	        for (const fieldKey in value) {
	            if (!value.hasOwnProperty(fieldKey)) {
	                return;
	            }
	            const fieldValue = value[fieldKey];
	            const fieldName = name + '.' + fieldKey;
	            const field = get(_fields, fieldName);
	            (_names.array.has(name) ||
	                isObject$2(fieldValue) ||
	                (field && !field._f)) &&
	                !isDateObject(fieldValue)
	                ? setValues(fieldName, fieldValue, options)
	                : setFieldValue(fieldName, fieldValue, options);
	        }
	    };
	    const setValue = (name, value, options = {}) => {
	        const field = get(_fields, name);
	        const isFieldArray = _names.array.has(name);
	        const cloneValue = cloneObject(value);
	        set(_formValues, name, cloneValue);
	        if (isFieldArray) {
	            _subjects.array.next({
	                name,
	                values: cloneObject(_formValues),
	            });
	            if ((_proxyFormState.isDirty ||
	                _proxyFormState.dirtyFields ||
	                _proxySubscribeFormState.isDirty ||
	                _proxySubscribeFormState.dirtyFields) &&
	                options.shouldDirty) {
	                _subjects.state.next({
	                    name,
	                    dirtyFields: getDirtyFields(_defaultValues, _formValues),
	                    isDirty: _getDirty(name, cloneValue),
	                });
	            }
	        }
	        else {
	            field && !field._f && !isNullOrUndefined(cloneValue)
	                ? setValues(name, cloneValue, options)
	                : setFieldValue(name, cloneValue, options);
	        }
	        isWatched(name, _names) && _subjects.state.next({ ..._formState, name });
	        _subjects.state.next({
	            name: _state.mount ? name : undefined,
	            values: cloneObject(_formValues),
	        });
	    };
	    const onChange = async (event) => {
	        _state.mount = true;
	        const target = event.target;
	        let name = target.name;
	        let isFieldValueUpdated = true;
	        const field = get(_fields, name);
	        const _updateIsFieldValueUpdated = (fieldValue) => {
	            isFieldValueUpdated =
	                Number.isNaN(fieldValue) ||
	                    (isDateObject(fieldValue) && isNaN(fieldValue.getTime())) ||
	                    deepEqual(fieldValue, get(_formValues, name, fieldValue));
	        };
	        const validationModeBeforeSubmit = getValidationModes(_options.mode);
	        const validationModeAfterSubmit = getValidationModes(_options.reValidateMode);
	        if (field) {
	            let error;
	            let isValid;
	            const fieldValue = target.type
	                ? getFieldValue(field._f)
	                : getEventValue(event);
	            const isBlurEvent = event.type === EVENTS.BLUR || event.type === EVENTS.FOCUS_OUT;
	            const shouldSkipValidation = (!hasValidation(field._f) &&
	                !_options.resolver &&
	                !get(_formState.errors, name) &&
	                !field._f.deps) ||
	                skipValidation(isBlurEvent, get(_formState.touchedFields, name), _formState.isSubmitted, validationModeAfterSubmit, validationModeBeforeSubmit);
	            const watched = isWatched(name, _names, isBlurEvent);
	            set(_formValues, name, fieldValue);
	            if (isBlurEvent) {
	                if (!target || !target.readOnly) {
	                    field._f.onBlur && field._f.onBlur(event);
	                    delayErrorCallback && delayErrorCallback(0);
	                }
	            }
	            else if (field._f.onChange) {
	                field._f.onChange(event);
	            }
	            const fieldState = updateTouchAndDirty(name, fieldValue, isBlurEvent);
	            const shouldRender = !isEmptyObject(fieldState) || watched;
	            !isBlurEvent &&
	                _subjects.state.next({
	                    name,
	                    type: event.type,
	                    values: cloneObject(_formValues),
	                });
	            if (shouldSkipValidation) {
	                if (_proxyFormState.isValid || _proxySubscribeFormState.isValid) {
	                    if (_options.mode === 'onBlur') {
	                        if (isBlurEvent) {
	                            _setValid();
	                        }
	                    }
	                    else if (!isBlurEvent) {
	                        _setValid();
	                    }
	                }
	                return (shouldRender &&
	                    _subjects.state.next({ name, ...(watched ? {} : fieldState) }));
	            }
	            !isBlurEvent && watched && _subjects.state.next({ ..._formState });
	            if (_options.resolver) {
	                const { errors } = await _runSchema([name]);
	                _updateIsFieldValueUpdated(fieldValue);
	                if (isFieldValueUpdated) {
	                    const previousErrorLookupResult = schemaErrorLookup(_formState.errors, _fields, name);
	                    const errorLookupResult = schemaErrorLookup(errors, _fields, previousErrorLookupResult.name || name);
	                    error = errorLookupResult.error;
	                    name = errorLookupResult.name;
	                    isValid = isEmptyObject(errors);
	                }
	            }
	            else {
	                _updateIsValidating([name], true);
	                error = (await validateField(field, _names.disabled, _formValues, shouldDisplayAllAssociatedErrors, _options.shouldUseNativeValidation))[name];
	                _updateIsValidating([name]);
	                _updateIsFieldValueUpdated(fieldValue);
	                if (isFieldValueUpdated) {
	                    if (error) {
	                        isValid = false;
	                    }
	                    else if (_proxyFormState.isValid ||
	                        _proxySubscribeFormState.isValid) {
	                        isValid = await executeBuiltInValidation(_fields, true);
	                    }
	                }
	            }
	            if (isFieldValueUpdated) {
	                field._f.deps &&
	                    (!Array.isArray(field._f.deps) || field._f.deps.length > 0) &&
	                    trigger(field._f.deps);
	                shouldRenderByError(name, isValid, error, fieldState);
	            }
	        }
	    };
	    const _focusInput = (ref, key) => {
	        if (get(_formState.errors, key) && ref.focus) {
	            ref.focus();
	            return 1;
	        }
	        return;
	    };
	    const trigger = async (name, options = {}) => {
	        let isValid;
	        let validationResult;
	        const fieldNames = convertToArrayPayload(name);
	        if (_options.resolver) {
	            const errors = await executeSchemaAndUpdateState(isUndefined(name) ? name : fieldNames);
	            isValid = isEmptyObject(errors);
	            validationResult = name
	                ? !fieldNames.some((name) => get(errors, name))
	                : isValid;
	        }
	        else if (name) {
	            validationResult = (await Promise.all(fieldNames.map(async (fieldName) => {
	                const field = get(_fields, fieldName);
	                return await executeBuiltInValidation(field && field._f ? { [fieldName]: field } : field);
	            }))).every(Boolean);
	            !(!validationResult && !_formState.isValid) && _setValid();
	        }
	        else {
	            validationResult = isValid = await executeBuiltInValidation(_fields);
	        }
	        _subjects.state.next({
	            ...(!isString(name) ||
	                ((_proxyFormState.isValid || _proxySubscribeFormState.isValid) &&
	                    isValid !== _formState.isValid)
	                ? {}
	                : { name }),
	            ...(_options.resolver || !name ? { isValid } : {}),
	            errors: _formState.errors,
	        });
	        options.shouldFocus &&
	            !validationResult &&
	            iterateFieldsByAction(_fields, _focusInput, name ? fieldNames : _names.mount);
	        return validationResult;
	    };
	    const getValues = (fieldNames, config) => {
	        let values = {
	            ...(_state.mount ? _formValues : _defaultValues),
	        };
	        if (config) {
	            values = extractFormValues(config.dirtyFields ? _formState.dirtyFields : _formState.touchedFields, values);
	        }
	        return isUndefined(fieldNames)
	            ? values
	            : isString(fieldNames)
	                ? get(values, fieldNames)
	                : fieldNames.map((name) => get(values, name));
	    };
	    const getFieldState = (name, formState) => ({
	        invalid: !!get((formState || _formState).errors, name),
	        isDirty: !!get((formState || _formState).dirtyFields, name),
	        error: get((formState || _formState).errors, name),
	        isValidating: !!get(_formState.validatingFields, name),
	        isTouched: !!get((formState || _formState).touchedFields, name),
	    });
	    const clearErrors = (name) => {
	        name &&
	            convertToArrayPayload(name).forEach((inputName) => unset(_formState.errors, inputName));
	        _subjects.state.next({
	            errors: name ? _formState.errors : {},
	        });
	    };
	    const setError = (name, error, options) => {
	        const ref = (get(_fields, name, { _f: {} })._f || {}).ref;
	        const currentError = get(_formState.errors, name) || {};
	        // Don't override existing error messages elsewhere in the object tree.
	        const { ref: currentRef, message, type, ...restOfErrorTree } = currentError;
	        set(_formState.errors, name, {
	            ...restOfErrorTree,
	            ...error,
	            ref,
	        });
	        _subjects.state.next({
	            name,
	            errors: _formState.errors,
	            isValid: false,
	        });
	        options && options.shouldFocus && ref && ref.focus && ref.focus();
	    };
	    const watch = (name, defaultValue) => isFunction(name)
	        ? _subjects.state.subscribe({
	            next: (payload) => 'values' in payload &&
	                name(_getWatch(undefined, defaultValue), payload),
	        })
	        : _getWatch(name, defaultValue, true);
	    const _subscribe = (props) => _subjects.state.subscribe({
	        next: (formState) => {
	            if (shouldSubscribeByName(props.name, formState.name, props.exact) &&
	                shouldRenderFormState(formState, props.formState || _proxyFormState, _setFormState, props.reRenderRoot)) {
	                props.callback({
	                    values: { ..._formValues },
	                    ..._formState,
	                    ...formState,
	                    defaultValues: _defaultValues,
	                });
	            }
	        },
	    }).unsubscribe;
	    const subscribe = (props) => {
	        _state.mount = true;
	        _proxySubscribeFormState = {
	            ..._proxySubscribeFormState,
	            ...props.formState,
	        };
	        return _subscribe({
	            ...props,
	            formState: _proxySubscribeFormState,
	        });
	    };
	    const unregister = (name, options = {}) => {
	        for (const fieldName of name ? convertToArrayPayload(name) : _names.mount) {
	            _names.mount.delete(fieldName);
	            _names.array.delete(fieldName);
	            if (!options.keepValue) {
	                unset(_fields, fieldName);
	                unset(_formValues, fieldName);
	            }
	            !options.keepError && unset(_formState.errors, fieldName);
	            !options.keepDirty && unset(_formState.dirtyFields, fieldName);
	            !options.keepTouched && unset(_formState.touchedFields, fieldName);
	            !options.keepIsValidating &&
	                unset(_formState.validatingFields, fieldName);
	            !_options.shouldUnregister &&
	                !options.keepDefaultValue &&
	                unset(_defaultValues, fieldName);
	        }
	        _subjects.state.next({
	            values: cloneObject(_formValues),
	        });
	        _subjects.state.next({
	            ..._formState,
	            ...(!options.keepDirty ? {} : { isDirty: _getDirty() }),
	        });
	        !options.keepIsValid && _setValid();
	    };
	    const _setDisabledField = ({ disabled, name, }) => {
	        if ((isBoolean(disabled) && _state.mount) ||
	            !!disabled ||
	            _names.disabled.has(name)) {
	            disabled ? _names.disabled.add(name) : _names.disabled.delete(name);
	        }
	    };
	    const register = (name, options = {}) => {
	        let field = get(_fields, name);
	        const disabledIsDefined = isBoolean(options.disabled) || isBoolean(_options.disabled);
	        set(_fields, name, {
	            ...(field || {}),
	            _f: {
	                ...(field && field._f ? field._f : { ref: { name } }),
	                name,
	                mount: true,
	                ...options,
	            },
	        });
	        _names.mount.add(name);
	        if (field) {
	            _setDisabledField({
	                disabled: isBoolean(options.disabled)
	                    ? options.disabled
	                    : _options.disabled,
	                name,
	            });
	        }
	        else {
	            updateValidAndValue(name, true, options.value);
	        }
	        return {
	            ...(disabledIsDefined
	                ? { disabled: options.disabled || _options.disabled }
	                : {}),
	            ...(_options.progressive
	                ? {
	                    required: !!options.required,
	                    min: getRuleValue(options.min),
	                    max: getRuleValue(options.max),
	                    minLength: getRuleValue(options.minLength),
	                    maxLength: getRuleValue(options.maxLength),
	                    pattern: getRuleValue(options.pattern),
	                }
	                : {}),
	            name,
	            onChange,
	            onBlur: onChange,
	            ref: (ref) => {
	                if (ref) {
	                    register(name, options);
	                    field = get(_fields, name);
	                    const fieldRef = isUndefined(ref.value)
	                        ? ref.querySelectorAll
	                            ? ref.querySelectorAll('input,select,textarea')[0] || ref
	                            : ref
	                        : ref;
	                    const radioOrCheckbox = isRadioOrCheckbox(fieldRef);
	                    const refs = field._f.refs || [];
	                    if (radioOrCheckbox
	                        ? refs.find((option) => option === fieldRef)
	                        : fieldRef === field._f.ref) {
	                        return;
	                    }
	                    set(_fields, name, {
	                        _f: {
	                            ...field._f,
	                            ...(radioOrCheckbox
	                                ? {
	                                    refs: [
	                                        ...refs.filter(live),
	                                        fieldRef,
	                                        ...(Array.isArray(get(_defaultValues, name)) ? [{}] : []),
	                                    ],
	                                    ref: { type: fieldRef.type, name },
	                                }
	                                : { ref: fieldRef }),
	                        },
	                    });
	                    updateValidAndValue(name, false, undefined, fieldRef);
	                }
	                else {
	                    field = get(_fields, name, {});
	                    if (field._f) {
	                        field._f.mount = false;
	                    }
	                    (_options.shouldUnregister || options.shouldUnregister) &&
	                        !(isNameInFieldArray(_names.array, name) && _state.action) &&
	                        _names.unMount.add(name);
	                }
	            },
	        };
	    };
	    const _focusError = () => _options.shouldFocusError &&
	        iterateFieldsByAction(_fields, _focusInput, _names.mount);
	    const _disableForm = (disabled) => {
	        if (isBoolean(disabled)) {
	            _subjects.state.next({ disabled });
	            iterateFieldsByAction(_fields, (ref, name) => {
	                const currentField = get(_fields, name);
	                if (currentField) {
	                    ref.disabled = currentField._f.disabled || disabled;
	                    if (Array.isArray(currentField._f.refs)) {
	                        currentField._f.refs.forEach((inputRef) => {
	                            inputRef.disabled = currentField._f.disabled || disabled;
	                        });
	                    }
	                }
	            }, 0, false);
	        }
	    };
	    const handleSubmit = (onValid, onInvalid) => async (e) => {
	        let onValidError = undefined;
	        if (e) {
	            e.preventDefault && e.preventDefault();
	            e.persist &&
	                e.persist();
	        }
	        let fieldValues = cloneObject(_formValues);
	        _subjects.state.next({
	            isSubmitting: true,
	        });
	        if (_options.resolver) {
	            const { errors, values } = await _runSchema();
	            _formState.errors = errors;
	            fieldValues = cloneObject(values);
	        }
	        else {
	            await executeBuiltInValidation(_fields);
	        }
	        if (_names.disabled.size) {
	            for (const name of _names.disabled) {
	                unset(fieldValues, name);
	            }
	        }
	        unset(_formState.errors, 'root');
	        if (isEmptyObject(_formState.errors)) {
	            _subjects.state.next({
	                errors: {},
	            });
	            try {
	                await onValid(fieldValues, e);
	            }
	            catch (error) {
	                onValidError = error;
	            }
	        }
	        else {
	            if (onInvalid) {
	                await onInvalid({ ..._formState.errors }, e);
	            }
	            _focusError();
	            setTimeout(_focusError);
	        }
	        _subjects.state.next({
	            isSubmitted: true,
	            isSubmitting: false,
	            isSubmitSuccessful: isEmptyObject(_formState.errors) && !onValidError,
	            submitCount: _formState.submitCount + 1,
	            errors: _formState.errors,
	        });
	        if (onValidError) {
	            throw onValidError;
	        }
	    };
	    const resetField = (name, options = {}) => {
	        if (get(_fields, name)) {
	            if (isUndefined(options.defaultValue)) {
	                setValue(name, cloneObject(get(_defaultValues, name)));
	            }
	            else {
	                setValue(name, options.defaultValue);
	                set(_defaultValues, name, cloneObject(options.defaultValue));
	            }
	            if (!options.keepTouched) {
	                unset(_formState.touchedFields, name);
	            }
	            if (!options.keepDirty) {
	                unset(_formState.dirtyFields, name);
	                _formState.isDirty = options.defaultValue
	                    ? _getDirty(name, cloneObject(get(_defaultValues, name)))
	                    : _getDirty();
	            }
	            if (!options.keepError) {
	                unset(_formState.errors, name);
	                _proxyFormState.isValid && _setValid();
	            }
	            _subjects.state.next({ ..._formState });
	        }
	    };
	    const _reset = (formValues, keepStateOptions = {}) => {
	        const updatedValues = formValues ? cloneObject(formValues) : _defaultValues;
	        const cloneUpdatedValues = cloneObject(updatedValues);
	        const isEmptyResetValues = isEmptyObject(formValues);
	        const values = isEmptyResetValues ? _defaultValues : cloneUpdatedValues;
	        if (!keepStateOptions.keepDefaultValues) {
	            _defaultValues = updatedValues;
	        }
	        if (!keepStateOptions.keepValues) {
	            if (keepStateOptions.keepDirtyValues) {
	                const fieldsToCheck = new Set([
	                    ..._names.mount,
	                    ...Object.keys(getDirtyFields(_defaultValues, _formValues)),
	                ]);
	                for (const fieldName of Array.from(fieldsToCheck)) {
	                    get(_formState.dirtyFields, fieldName)
	                        ? set(values, fieldName, get(_formValues, fieldName))
	                        : setValue(fieldName, get(values, fieldName));
	                }
	            }
	            else {
	                if (isWeb && isUndefined(formValues)) {
	                    for (const name of _names.mount) {
	                        const field = get(_fields, name);
	                        if (field && field._f) {
	                            const fieldReference = Array.isArray(field._f.refs)
	                                ? field._f.refs[0]
	                                : field._f.ref;
	                            if (isHTMLElement(fieldReference)) {
	                                const form = fieldReference.closest('form');
	                                if (form) {
	                                    form.reset();
	                                    break;
	                                }
	                            }
	                        }
	                    }
	                }
	                if (keepStateOptions.keepFieldsRef) {
	                    for (const fieldName of _names.mount) {
	                        setValue(fieldName, get(values, fieldName));
	                    }
	                }
	                else {
	                    _fields = {};
	                }
	            }
	            _formValues = _options.shouldUnregister
	                ? keepStateOptions.keepDefaultValues
	                    ? cloneObject(_defaultValues)
	                    : {}
	                : cloneObject(values);
	            _subjects.array.next({
	                values: { ...values },
	            });
	            _subjects.state.next({
	                values: { ...values },
	            });
	        }
	        _names = {
	            mount: keepStateOptions.keepDirtyValues ? _names.mount : new Set(),
	            unMount: new Set(),
	            array: new Set(),
	            disabled: new Set(),
	            watch: new Set(),
	            watchAll: false,
	            focus: '',
	        };
	        _state.mount =
	            !_proxyFormState.isValid ||
	                !!keepStateOptions.keepIsValid ||
	                !!keepStateOptions.keepDirtyValues;
	        _state.watch = !!_options.shouldUnregister;
	        _subjects.state.next({
	            submitCount: keepStateOptions.keepSubmitCount
	                ? _formState.submitCount
	                : 0,
	            isDirty: isEmptyResetValues
	                ? false
	                : keepStateOptions.keepDirty
	                    ? _formState.isDirty
	                    : !!(keepStateOptions.keepDefaultValues &&
	                        !deepEqual(formValues, _defaultValues)),
	            isSubmitted: keepStateOptions.keepIsSubmitted
	                ? _formState.isSubmitted
	                : false,
	            dirtyFields: isEmptyResetValues
	                ? {}
	                : keepStateOptions.keepDirtyValues
	                    ? keepStateOptions.keepDefaultValues && _formValues
	                        ? getDirtyFields(_defaultValues, _formValues)
	                        : _formState.dirtyFields
	                    : keepStateOptions.keepDefaultValues && formValues
	                        ? getDirtyFields(_defaultValues, formValues)
	                        : keepStateOptions.keepDirty
	                            ? _formState.dirtyFields
	                            : {},
	            touchedFields: keepStateOptions.keepTouched
	                ? _formState.touchedFields
	                : {},
	            errors: keepStateOptions.keepErrors ? _formState.errors : {},
	            isSubmitSuccessful: keepStateOptions.keepIsSubmitSuccessful
	                ? _formState.isSubmitSuccessful
	                : false,
	            isSubmitting: false,
	            defaultValues: _defaultValues,
	        });
	    };
	    const reset = (formValues, keepStateOptions) => _reset(isFunction(formValues)
	        ? formValues(_formValues)
	        : formValues, keepStateOptions);
	    const setFocus = (name, options = {}) => {
	        const field = get(_fields, name);
	        const fieldReference = field && field._f;
	        if (fieldReference) {
	            const fieldRef = fieldReference.refs
	                ? fieldReference.refs[0]
	                : fieldReference.ref;
	            if (fieldRef.focus) {
	                fieldRef.focus();
	                options.shouldSelect &&
	                    isFunction(fieldRef.select) &&
	                    fieldRef.select();
	            }
	        }
	    };
	    const _setFormState = (updatedFormState) => {
	        _formState = {
	            ..._formState,
	            ...updatedFormState,
	        };
	    };
	    const _resetDefaultValues = () => isFunction(_options.defaultValues) &&
	        _options.defaultValues().then((values) => {
	            reset(values, _options.resetOptions);
	            _subjects.state.next({
	                isLoading: false,
	            });
	        });
	    const methods = {
	        control: {
	            register,
	            unregister,
	            getFieldState,
	            handleSubmit,
	            setError,
	            _subscribe,
	            _runSchema,
	            _focusError,
	            _getWatch,
	            _getDirty,
	            _setValid,
	            _setFieldArray,
	            _setDisabledField,
	            _setErrors,
	            _getFieldArray,
	            _reset,
	            _resetDefaultValues,
	            _removeUnmounted,
	            _disableForm,
	            _subjects,
	            _proxyFormState,
	            get _fields() {
	                return _fields;
	            },
	            get _formValues() {
	                return _formValues;
	            },
	            get _state() {
	                return _state;
	            },
	            set _state(value) {
	                _state = value;
	            },
	            get _defaultValues() {
	                return _defaultValues;
	            },
	            get _names() {
	                return _names;
	            },
	            set _names(value) {
	                _names = value;
	            },
	            get _formState() {
	                return _formState;
	            },
	            get _options() {
	                return _options;
	            },
	            set _options(value) {
	                _options = {
	                    ..._options,
	                    ...value,
	                };
	            },
	        },
	        subscribe,
	        trigger,
	        register,
	        handleSubmit,
	        watch,
	        setValue,
	        getValues,
	        reset,
	        resetField,
	        clearErrors,
	        unregister,
	        setError,
	        setFocus,
	        getFieldState,
	    };
	    return {
	        ...methods,
	        formControl: methods,
	    };
	}

	/**
	 * Custom hook to manage the entire form.
	 *
	 * @remarks
	 * [API](https://react-hook-form.com/docs/useform)  [Demo](https://codesandbox.io/s/react-hook-form-get-started-ts-5ksmm)  [Video](https://www.youtube.com/watch?v=RkXv4AXXC_4)
	 *
	 * @param props - form configuration and validation parameters.
	 *
	 * @returns methods - individual functions to manage the form state. {@link UseFormReturn}
	 *
	 * @example
	 * ```tsx
	 * function App() {
	 *   const { register, handleSubmit, watch, formState: { errors } } = useForm();
	 *   const onSubmit = data => console.log(data);
	 *
	 *   console.log(watch("example"));
	 *
	 *   return (
	 *     <form onSubmit={handleSubmit(onSubmit)}>
	 *       <input defaultValue="test" {...register("example")} />
	 *       <input {...register("exampleRequired", { required: true })} />
	 *       {errors.exampleRequired && <span>This field is required</span>}
	 *       <button>Submit</button>
	 *     </form>
	 *   );
	 * }
	 * ```
	 */
	function useForm(props = {}) {
	    const _formControl = React.useRef(undefined);
	    const _values = React.useRef(undefined);
	    const [formState, updateFormState] = React.useState({
	        isDirty: false,
	        isValidating: false,
	        isLoading: isFunction(props.defaultValues),
	        isSubmitted: false,
	        isSubmitting: false,
	        isSubmitSuccessful: false,
	        isValid: false,
	        submitCount: 0,
	        dirtyFields: {},
	        touchedFields: {},
	        validatingFields: {},
	        errors: props.errors || {},
	        disabled: props.disabled || false,
	        isReady: false,
	        defaultValues: isFunction(props.defaultValues)
	            ? undefined
	            : props.defaultValues,
	    });
	    if (!_formControl.current) {
	        if (props.formControl) {
	            _formControl.current = {
	                ...props.formControl,
	                formState,
	            };
	            if (props.defaultValues && !isFunction(props.defaultValues)) {
	                props.formControl.reset(props.defaultValues, props.resetOptions);
	            }
	        }
	        else {
	            const { formControl, ...rest } = createFormControl(props);
	            _formControl.current = {
	                ...rest,
	                formState,
	            };
	        }
	    }
	    const control = _formControl.current.control;
	    control._options = props;
	    useIsomorphicLayoutEffect(() => {
	        const sub = control._subscribe({
	            formState: control._proxyFormState,
	            callback: () => updateFormState({ ...control._formState }),
	            reRenderRoot: true,
	        });
	        updateFormState((data) => ({
	            ...data,
	            isReady: true,
	        }));
	        control._formState.isReady = true;
	        return sub;
	    }, [control]);
	    React.useEffect(() => control._disableForm(props.disabled), [control, props.disabled]);
	    React.useEffect(() => {
	        if (props.mode) {
	            control._options.mode = props.mode;
	        }
	        if (props.reValidateMode) {
	            control._options.reValidateMode = props.reValidateMode;
	        }
	    }, [control, props.mode, props.reValidateMode]);
	    React.useEffect(() => {
	        if (props.errors) {
	            control._setErrors(props.errors);
	            control._focusError();
	        }
	    }, [control, props.errors]);
	    React.useEffect(() => {
	        props.shouldUnregister &&
	            control._subjects.state.next({
	                values: control._getWatch(),
	            });
	    }, [control, props.shouldUnregister]);
	    React.useEffect(() => {
	        if (control._proxyFormState.isDirty) {
	            const isDirty = control._getDirty();
	            if (isDirty !== formState.isDirty) {
	                control._subjects.state.next({
	                    isDirty,
	                });
	            }
	        }
	    }, [control, formState.isDirty]);
	    React.useEffect(() => {
	        if (props.values && !deepEqual(props.values, _values.current)) {
	            control._reset(props.values, {
	                keepFieldsRef: true,
	                ...control._options.resetOptions,
	            });
	            _values.current = props.values;
	            updateFormState((state) => ({ ...state }));
	        }
	        else {
	            control._resetDefaultValues();
	        }
	    }, [control, props.values]);
	    React.useEffect(() => {
	        if (!control._state.mount) {
	            control._setValid();
	            control._state.mount = true;
	        }
	        if (control._state.watch) {
	            control._state.watch = false;
	            control._subjects.state.next({ ...control._formState });
	        }
	        control._removeUnmounted();
	    });
	    _formControl.current.formState = getProxyFormState(formState, control);
	    return _formControl.current;
	}

	const r=(t,r,o)=>{if(t&&"reportValidity"in t){const s=get(o,r);t.setCustomValidity(s&&s.message||""),t.reportValidity();}},o$1=(e,t)=>{for(const o in t.fields){const s=t.fields[o];s&&s.ref&&"reportValidity"in s.ref?r(s.ref,o,e):s&&s.refs&&s.refs.forEach(t=>r(t,o,e));}},s=(r,s)=>{s.shouldUseNativeValidation&&o$1(r,s);const n={};for(const o in r){const f=get(s.fields,o),c=Object.assign(r[o]||{},{ref:f&&f.ref});if(i(s.names||Object.keys(r),o)){const r=Object.assign({},get(n,o));set(r,"root",c),set(n,o,r);}else set(n,o,c);}return n},i=(e,t)=>{const r=n(t);return e.some(e=>n(e).match(`^${r}\\.\\d+`))};function n(e){return e.replace(/\]|\[/g,"")}

	function o(o,n,s$1){return void 0===s$1&&(s$1={}),function(a,i,c){try{return Promise.resolve(function(t,r){try{var u=(null!=n&&n.context&&"development"==="production"&&console.warn("You should not used the yup options context. Please, use the 'useForm' context object instead"),Promise.resolve(o["sync"===s$1.mode?"validateSync":"validate"](a,Object.assign({abortEarly:!1},n,{context:i}))).then(function(t){return c.shouldUseNativeValidation&&o$1({},c),{values:s$1.raw?Object.assign({},a):t,errors:{}}}));}catch(e){return r(e)}return u&&u.then?u.then(void 0,r):u}(0,function(e){if(!e.inner)throw e;return {values:{},errors:s((o=e,n=!c.shouldUseNativeValidation&&"all"===c.criteriaMode,(o.inner||[]).reduce(function(e,t){if(e[t.path]||(e[t.path]={message:t.message,type:t.type}),n){var o=e[t.path].types,s=o&&o[t.type];e[t.path]=appendErrors(t.path,n,e,t.type,s?[].concat(s,t.message):t.message);}return e},{})),c)};var o,n;}))}catch(e){return Promise.reject(e)}}}

	/**
	 * Based on Kendo UI Core expression code <https://github.com/telerik/kendo-ui-core#license-information>
	 */

	var propertyExpr;
	var hasRequiredPropertyExpr;

	function requirePropertyExpr () {
		if (hasRequiredPropertyExpr) return propertyExpr;
		hasRequiredPropertyExpr = 1;

		function Cache(maxSize) {
		  this._maxSize = maxSize;
		  this.clear();
		}
		Cache.prototype.clear = function () {
		  this._size = 0;
		  this._values = Object.create(null);
		};
		Cache.prototype.get = function (key) {
		  return this._values[key]
		};
		Cache.prototype.set = function (key, value) {
		  this._size >= this._maxSize && this.clear();
		  if (!(key in this._values)) this._size++;

		  return (this._values[key] = value)
		};

		var SPLIT_REGEX = /[^.^\]^[]+|(?=\[\]|\.\.)/g,
		  DIGIT_REGEX = /^\d+$/,
		  LEAD_DIGIT_REGEX = /^\d/,
		  SPEC_CHAR_REGEX = /[~`!#$%\^&*+=\-\[\]\\';,/{}|\\":<>\?]/g,
		  CLEAN_QUOTES_REGEX = /^\s*(['"]?)(.*?)(\1)\s*$/,
		  MAX_CACHE_SIZE = 512;

		var pathCache = new Cache(MAX_CACHE_SIZE),
		  setCache = new Cache(MAX_CACHE_SIZE),
		  getCache = new Cache(MAX_CACHE_SIZE);

		propertyExpr = {
		  Cache: Cache,

		  split: split,

		  normalizePath: normalizePath,

		  setter: function (path) {
		    var parts = normalizePath(path);

		    return (
		      setCache.get(path) ||
		      setCache.set(path, function setter(obj, value) {
		        var index = 0;
		        var len = parts.length;
		        var data = obj;

		        while (index < len - 1) {
		          var part = parts[index];
		          if (
		            part === '__proto__' ||
		            part === 'constructor' ||
		            part === 'prototype'
		          ) {
		            return obj
		          }

		          data = data[parts[index++]];
		        }
		        data[parts[index]] = value;
		      })
		    )
		  },

		  getter: function (path, safe) {
		    var parts = normalizePath(path);
		    return (
		      getCache.get(path) ||
		      getCache.set(path, function getter(data) {
		        var index = 0,
		          len = parts.length;
		        while (index < len) {
		          if (data != null || !safe) data = data[parts[index++]];
		          else return
		        }
		        return data
		      })
		    )
		  },

		  join: function (segments) {
		    return segments.reduce(function (path, part) {
		      return (
		        path +
		        (isQuoted(part) || DIGIT_REGEX.test(part)
		          ? '[' + part + ']'
		          : (path ? '.' : '') + part)
		      )
		    }, '')
		  },

		  forEach: function (path, cb, thisArg) {
		    forEach(Array.isArray(path) ? path : split(path), cb, thisArg);
		  },
		};

		function normalizePath(path) {
		  return (
		    pathCache.get(path) ||
		    pathCache.set(
		      path,
		      split(path).map(function (part) {
		        return part.replace(CLEAN_QUOTES_REGEX, '$2')
		      })
		    )
		  )
		}

		function split(path) {
		  return path.match(SPLIT_REGEX) || ['']
		}

		function forEach(parts, iter, thisArg) {
		  var len = parts.length,
		    part,
		    idx,
		    isArray,
		    isBracket;

		  for (idx = 0; idx < len; idx++) {
		    part = parts[idx];

		    if (part) {
		      if (shouldBeQuoted(part)) {
		        part = '"' + part + '"';
		      }

		      isBracket = isQuoted(part);
		      isArray = !isBracket && /^\d+$/.test(part);

		      iter.call(thisArg, part, isBracket, isArray, idx, parts);
		    }
		  }
		}

		function isQuoted(str) {
		  return (
		    typeof str === 'string' && str && ["'", '"'].indexOf(str.charAt(0)) !== -1
		  )
		}

		function hasLeadingNumber(part) {
		  return part.match(LEAD_DIGIT_REGEX) && !part.match(DIGIT_REGEX)
		}

		function hasSpecialChars(part) {
		  return SPEC_CHAR_REGEX.test(part)
		}

		function shouldBeQuoted(part) {
		  return !isQuoted(part) && (hasLeadingNumber(part) || hasSpecialChars(part))
		}
		return propertyExpr;
	}

	var propertyExprExports = requirePropertyExpr();

	var tinyCase;
	var hasRequiredTinyCase;

	function requireTinyCase () {
		if (hasRequiredTinyCase) return tinyCase;
		hasRequiredTinyCase = 1;
		const reWords = /[A-Z\xc0-\xd6\xd8-\xde]?[a-z\xdf-\xf6\xf8-\xff]+(?:['](?:d|ll|m|re|s|t|ve))?(?=[\xac\xb1\xd7\xf7\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\xbf\u2000-\u206f \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000]|[A-Z\xc0-\xd6\xd8-\xde]|$)|(?:[A-Z\xc0-\xd6\xd8-\xde]|[^\ud800-\udfff\xac\xb1\xd7\xf7\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\xbf\u2000-\u206f \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\d+\u2700-\u27bfa-z\xdf-\xf6\xf8-\xffA-Z\xc0-\xd6\xd8-\xde])+(?:['](?:D|LL|M|RE|S|T|VE))?(?=[\xac\xb1\xd7\xf7\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\xbf\u2000-\u206f \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000]|[A-Z\xc0-\xd6\xd8-\xde](?:[a-z\xdf-\xf6\xf8-\xff]|[^\ud800-\udfff\xac\xb1\xd7\xf7\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\xbf\u2000-\u206f \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\d+\u2700-\u27bfa-z\xdf-\xf6\xf8-\xffA-Z\xc0-\xd6\xd8-\xde])|$)|[A-Z\xc0-\xd6\xd8-\xde]?(?:[a-z\xdf-\xf6\xf8-\xff]|[^\ud800-\udfff\xac\xb1\xd7\xf7\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\xbf\u2000-\u206f \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\d+\u2700-\u27bfa-z\xdf-\xf6\xf8-\xffA-Z\xc0-\xd6\xd8-\xde])+(?:['](?:d|ll|m|re|s|t|ve))?|[A-Z\xc0-\xd6\xd8-\xde]+(?:['](?:D|LL|M|RE|S|T|VE))?|\d*(?:1ST|2ND|3RD|(?![123])\dTH)(?=\b|[a-z_])|\d*(?:1st|2nd|3rd|(?![123])\dth)(?=\b|[A-Z_])|\d+|(?:[\u2700-\u27bf]|(?:\ud83c[\udde6-\uddff]){2}|[\ud800-\udbff][\udc00-\udfff])[\ufe0e\ufe0f]?(?:[\u0300-\u036f\ufe20-\ufe2f\u20d0-\u20ff]|\ud83c[\udffb-\udfff])?(?:\u200d(?:[^\ud800-\udfff]|(?:\ud83c[\udde6-\uddff]){2}|[\ud800-\udbff][\udc00-\udfff])[\ufe0e\ufe0f]?(?:[\u0300-\u036f\ufe20-\ufe2f\u20d0-\u20ff]|\ud83c[\udffb-\udfff])?)*/g;

		const words = (str) => str.match(reWords) || [];

		const upperFirst = (str) => str[0].toUpperCase() + str.slice(1);

		const join = (str, d) => words(str).join(d).toLowerCase();

		const camelCase = (str) =>
		  words(str).reduce(
		    (acc, next) =>
		      `${acc}${
	        !acc
	          ? next.toLowerCase()
	          : next[0].toUpperCase() + next.slice(1).toLowerCase()
	      }`,
		    '',
		  );

		const pascalCase = (str) => upperFirst(camelCase(str));

		const snakeCase = (str) => join(str, '_');

		const kebabCase = (str) => join(str, '-');

		const sentenceCase = (str) => upperFirst(join(str, ' '));

		const titleCase = (str) => words(str).map(upperFirst).join(' ');

		tinyCase = {
		  words,
		  upperFirst,
		  camelCase,
		  pascalCase,
		  snakeCase,
		  kebabCase,
		  sentenceCase,
		  titleCase,
		};
		return tinyCase;
	}

	var tinyCaseExports = requireTinyCase();

	var toposort$1 = {exports: {}};

	var hasRequiredToposort;

	function requireToposort () {
		if (hasRequiredToposort) return toposort$1.exports;
		hasRequiredToposort = 1;
		/**
		 * Topological sorting function
		 *
		 * @param {Array} edges
		 * @returns {Array}
		 */

		toposort$1.exports = function(edges) {
		  return toposort(uniqueNodes(edges), edges)
		};

		toposort$1.exports.array = toposort;

		function toposort(nodes, edges) {
		  var cursor = nodes.length
		    , sorted = new Array(cursor)
		    , visited = {}
		    , i = cursor
		    // Better data structures make algorithm much faster.
		    , outgoingEdges = makeOutgoingEdges(edges)
		    , nodesHash = makeNodesHash(nodes);

		  // check for unknown nodes
		  edges.forEach(function(edge) {
		    if (!nodesHash.has(edge[0]) || !nodesHash.has(edge[1])) {
		      throw new Error('Unknown node. There is an unknown node in the supplied edges.')
		    }
		  });

		  while (i--) {
		    if (!visited[i]) visit(nodes[i], i, new Set());
		  }

		  return sorted

		  function visit(node, i, predecessors) {
		    if(predecessors.has(node)) {
		      var nodeRep;
		      try {
		        nodeRep = ", node was:" + JSON.stringify(node);
		      } catch(e) {
		        nodeRep = "";
		      }
		      throw new Error('Cyclic dependency' + nodeRep)
		    }

		    if (!nodesHash.has(node)) {
		      throw new Error('Found unknown node. Make sure to provided all involved nodes. Unknown node: '+JSON.stringify(node))
		    }

		    if (visited[i]) return;
		    visited[i] = true;

		    var outgoing = outgoingEdges.get(node) || new Set();
		    outgoing = Array.from(outgoing);

		    if (i = outgoing.length) {
		      predecessors.add(node);
		      do {
		        var child = outgoing[--i];
		        visit(child, nodesHash.get(child), predecessors);
		      } while (i)
		      predecessors.delete(node);
		    }

		    sorted[--cursor] = node;
		  }
		}

		function uniqueNodes(arr){
		  var res = new Set();
		  for (var i = 0, len = arr.length; i < len; i++) {
		    var edge = arr[i];
		    res.add(edge[0]);
		    res.add(edge[1]);
		  }
		  return Array.from(res)
		}

		function makeOutgoingEdges(arr){
		  var edges = new Map();
		  for (var i = 0, len = arr.length; i < len; i++) {
		    var edge = arr[i];
		    if (!edges.has(edge[0])) edges.set(edge[0], new Set());
		    if (!edges.has(edge[1])) edges.set(edge[1], new Set());
		    edges.get(edge[0]).add(edge[1]);
		  }
		  return edges
		}

		function makeNodesHash(arr){
		  var res = new Map();
		  for (var i = 0, len = arr.length; i < len; i++) {
		    res.set(arr[i], i);
		  }
		  return res
		}
		return toposort$1.exports;
	}

	var toposortExports = requireToposort();
	var toposort = /*@__PURE__*/getDefaultExportFromCjs(toposortExports);

	const toString = Object.prototype.toString;
	const errorToString = Error.prototype.toString;
	const regExpToString = RegExp.prototype.toString;
	const symbolToString = typeof Symbol !== 'undefined' ? Symbol.prototype.toString : () => '';
	const SYMBOL_REGEXP = /^Symbol\((.*)\)(.*)$/;
	function printNumber(val) {
	  if (val != +val) return 'NaN';
	  const isNegativeZero = val === 0 && 1 / val < 0;
	  return isNegativeZero ? '-0' : '' + val;
	}
	function printSimpleValue(val, quoteStrings = false) {
	  if (val == null || val === true || val === false) return '' + val;
	  const typeOf = typeof val;
	  if (typeOf === 'number') return printNumber(val);
	  if (typeOf === 'string') return quoteStrings ? `"${val}"` : val;
	  if (typeOf === 'function') return '[Function ' + (val.name || 'anonymous') + ']';
	  if (typeOf === 'symbol') return symbolToString.call(val).replace(SYMBOL_REGEXP, 'Symbol($1)');
	  const tag = toString.call(val).slice(8, -1);
	  if (tag === 'Date') return isNaN(val.getTime()) ? '' + val : val.toISOString(val);
	  if (tag === 'Error' || val instanceof Error) return '[' + errorToString.call(val) + ']';
	  if (tag === 'RegExp') return regExpToString.call(val);
	  return null;
	}
	function printValue(value, quoteStrings) {
	  let result = printSimpleValue(value, quoteStrings);
	  if (result !== null) return result;
	  return JSON.stringify(value, function (key, value) {
	    let result = printSimpleValue(this[key], quoteStrings);
	    if (result !== null) return result;
	    return value;
	  }, 2);
	}

	function toArray(value) {
	  return value == null ? [] : [].concat(value);
	}

	let _Symbol$toStringTag, _Symbol$hasInstance, _Symbol$toStringTag2;
	let strReg = /\$\{\s*(\w+)\s*\}/g;
	_Symbol$toStringTag = Symbol.toStringTag;
	class ValidationErrorNoStack {
	  constructor(errorOrErrors, value, field, type) {
	    this.name = void 0;
	    this.message = void 0;
	    this.value = void 0;
	    this.path = void 0;
	    this.type = void 0;
	    this.params = void 0;
	    this.errors = void 0;
	    this.inner = void 0;
	    this[_Symbol$toStringTag] = 'Error';
	    this.name = 'ValidationError';
	    this.value = value;
	    this.path = field;
	    this.type = type;
	    this.errors = [];
	    this.inner = [];
	    toArray(errorOrErrors).forEach(err => {
	      if (ValidationError.isError(err)) {
	        this.errors.push(...err.errors);
	        const innerErrors = err.inner.length ? err.inner : [err];
	        this.inner.push(...innerErrors);
	      } else {
	        this.errors.push(err);
	      }
	    });
	    this.message = this.errors.length > 1 ? `${this.errors.length} errors occurred` : this.errors[0];
	  }
	}
	_Symbol$hasInstance = Symbol.hasInstance;
	_Symbol$toStringTag2 = Symbol.toStringTag;
	class ValidationError extends Error {
	  static formatError(message, params) {
	    // Attempt to make the path more friendly for error message interpolation.
	    const path = params.label || params.path || 'this';
	    // Store the original path under `originalPath` so it isn't lost to custom
	    // message functions; e.g., ones provided in `setLocale()` calls.
	    params = Object.assign({}, params, {
	      path,
	      originalPath: params.path
	    });
	    if (typeof message === 'string') return message.replace(strReg, (_, key) => printValue(params[key]));
	    if (typeof message === 'function') return message(params);
	    return message;
	  }
	  static isError(err) {
	    return err && err.name === 'ValidationError';
	  }
	  constructor(errorOrErrors, value, field, type, disableStack) {
	    const errorNoStack = new ValidationErrorNoStack(errorOrErrors, value, field, type);
	    if (disableStack) {
	      return errorNoStack;
	    }
	    super();
	    this.value = void 0;
	    this.path = void 0;
	    this.type = void 0;
	    this.params = void 0;
	    this.errors = [];
	    this.inner = [];
	    this[_Symbol$toStringTag2] = 'Error';
	    this.name = errorNoStack.name;
	    this.message = errorNoStack.message;
	    this.type = errorNoStack.type;
	    this.value = errorNoStack.value;
	    this.path = errorNoStack.path;
	    this.errors = errorNoStack.errors;
	    this.inner = errorNoStack.inner;
	    if (Error.captureStackTrace) {
	      Error.captureStackTrace(this, ValidationError);
	    }
	  }
	  static [_Symbol$hasInstance](inst) {
	    return ValidationErrorNoStack[Symbol.hasInstance](inst) || super[Symbol.hasInstance](inst);
	  }
	}

	let mixed = {
	  default: '${path} is invalid',
	  required: '${path} is a required field',
	  defined: '${path} must be defined',
	  notNull: '${path} cannot be null',
	  oneOf: '${path} must be one of the following values: ${values}',
	  notOneOf: '${path} must not be one of the following values: ${values}',
	  notType: ({
	    path,
	    type,
	    value,
	    originalValue
	  }) => {
	    const castMsg = originalValue != null && originalValue !== value ? ` (cast from the value \`${printValue(originalValue, true)}\`).` : '.';
	    return type !== 'mixed' ? `${path} must be a \`${type}\` type, ` + `but the final value was: \`${printValue(value, true)}\`` + castMsg : `${path} must match the configured type. ` + `The validated value was: \`${printValue(value, true)}\`` + castMsg;
	  }
	};
	let string = {
	  length: '${path} must be exactly ${length} characters',
	  min: '${path} must be at least ${min} characters',
	  max: '${path} must be at most ${max} characters',
	  matches: '${path} must match the following: "${regex}"',
	  email: '${path} must be a valid email',
	  url: '${path} must be a valid URL',
	  uuid: '${path} must be a valid UUID',
	  datetime: '${path} must be a valid ISO date-time',
	  datetime_precision: '${path} must be a valid ISO date-time with a sub-second precision of exactly ${precision} digits',
	  datetime_offset: '${path} must be a valid ISO date-time with UTC "Z" timezone',
	  trim: '${path} must be a trimmed string',
	  lowercase: '${path} must be a lowercase string',
	  uppercase: '${path} must be a upper case string'
	};
	let number = {
	  min: '${path} must be greater than or equal to ${min}',
	  max: '${path} must be less than or equal to ${max}',
	  lessThan: '${path} must be less than ${less}',
	  moreThan: '${path} must be greater than ${more}',
	  positive: '${path} must be a positive number',
	  negative: '${path} must be a negative number',
	  integer: '${path} must be an integer'
	};
	let date = {
	  min: '${path} field must be later than ${min}',
	  max: '${path} field must be at earlier than ${max}'
	};
	let boolean = {
	  isValue: '${path} field must be ${value}'
	};
	let object = {
	  noUnknown: '${path} field has unspecified keys: ${unknown}',
	  exact: '${path} object contains unknown properties: ${properties}'
	};
	let array = {
	  min: '${path} field must have at least ${min} items',
	  max: '${path} field must have less than or equal to ${max} items',
	  length: '${path} must have ${length} items'
	};
	let tuple = {
	  notType: params => {
	    const {
	      path,
	      value,
	      spec
	    } = params;
	    const typeLen = spec.types.length;
	    if (Array.isArray(value)) {
	      if (value.length < typeLen) return `${path} tuple value has too few items, expected a length of ${typeLen} but got ${value.length} for value: \`${printValue(value, true)}\``;
	      if (value.length > typeLen) return `${path} tuple value has too many items, expected a length of ${typeLen} but got ${value.length} for value: \`${printValue(value, true)}\``;
	    }
	    return ValidationError.formatError(mixed.notType, params);
	  }
	};
	Object.assign(Object.create(null), {
	  mixed,
	  string,
	  number,
	  date,
	  object,
	  array,
	  boolean,
	  tuple
	});

	const isSchema = obj => obj && obj.__isYupSchema__;

	class Condition {
	  static fromOptions(refs, config) {
	    if (!config.then && !config.otherwise) throw new TypeError('either `then:` or `otherwise:` is required for `when()` conditions');
	    let {
	      is,
	      then,
	      otherwise
	    } = config;
	    let check = typeof is === 'function' ? is : (...values) => values.every(value => value === is);
	    return new Condition(refs, (values, schema) => {
	      var _branch;
	      let branch = check(...values) ? then : otherwise;
	      return (_branch = branch == null ? void 0 : branch(schema)) != null ? _branch : schema;
	    });
	  }
	  constructor(refs, builder) {
	    this.fn = void 0;
	    this.refs = refs;
	    this.refs = refs;
	    this.fn = builder;
	  }
	  resolve(base, options) {
	    let values = this.refs.map(ref =>
	    // TODO: ? operator here?
	    ref.getValue(options == null ? void 0 : options.value, options == null ? void 0 : options.parent, options == null ? void 0 : options.context));
	    let schema = this.fn(values, base, options);
	    if (schema === undefined ||
	    // @ts-ignore this can be base
	    schema === base) {
	      return base;
	    }
	    if (!isSchema(schema)) throw new TypeError('conditions must return a schema object');
	    return schema.resolve(options);
	  }
	}

	const prefixes = {
	  context: '$',
	  value: '.'
	};
	class Reference {
	  constructor(key, options = {}) {
	    this.key = void 0;
	    this.isContext = void 0;
	    this.isValue = void 0;
	    this.isSibling = void 0;
	    this.path = void 0;
	    this.getter = void 0;
	    this.map = void 0;
	    if (typeof key !== 'string') throw new TypeError('ref must be a string, got: ' + key);
	    this.key = key.trim();
	    if (key === '') throw new TypeError('ref must be a non-empty string');
	    this.isContext = this.key[0] === prefixes.context;
	    this.isValue = this.key[0] === prefixes.value;
	    this.isSibling = !this.isContext && !this.isValue;
	    let prefix = this.isContext ? prefixes.context : this.isValue ? prefixes.value : '';
	    this.path = this.key.slice(prefix.length);
	    this.getter = this.path && propertyExprExports.getter(this.path, true);
	    this.map = options.map;
	  }
	  getValue(value, parent, context) {
	    let result = this.isContext ? context : this.isValue ? value : parent;
	    if (this.getter) result = this.getter(result || {});
	    if (this.map) result = this.map(result);
	    return result;
	  }

	  /**
	   *
	   * @param {*} value
	   * @param {Object} options
	   * @param {Object=} options.context
	   * @param {Object=} options.parent
	   */
	  cast(value, options) {
	    return this.getValue(value, options == null ? void 0 : options.parent, options == null ? void 0 : options.context);
	  }
	  resolve() {
	    return this;
	  }
	  describe() {
	    return {
	      type: 'ref',
	      key: this.key
	    };
	  }
	  toString() {
	    return `Ref(${this.key})`;
	  }
	  static isRef(value) {
	    return value && value.__isYupRef;
	  }
	}

	// @ts-ignore
	Reference.prototype.__isYupRef = true;

	const isAbsent = value => value == null;

	function createValidation(config) {
	  function validate({
	    value,
	    path = '',
	    options,
	    originalValue,
	    schema
	  }, panic, next) {
	    const {
	      name,
	      test,
	      params,
	      message,
	      skipAbsent
	    } = config;
	    let {
	      parent,
	      context,
	      abortEarly = schema.spec.abortEarly,
	      disableStackTrace = schema.spec.disableStackTrace
	    } = options;
	    const resolveOptions = {
	      value,
	      parent,
	      context
	    };
	    function createError(overrides = {}) {
	      const nextParams = resolveParams(Object.assign({
	        value,
	        originalValue,
	        label: schema.spec.label,
	        path: overrides.path || path,
	        spec: schema.spec,
	        disableStackTrace: overrides.disableStackTrace || disableStackTrace
	      }, params, overrides.params), resolveOptions);
	      const error = new ValidationError(ValidationError.formatError(overrides.message || message, nextParams), value, nextParams.path, overrides.type || name, nextParams.disableStackTrace);
	      error.params = nextParams;
	      return error;
	    }
	    const invalid = abortEarly ? panic : next;
	    let ctx = {
	      path,
	      parent,
	      type: name,
	      from: options.from,
	      createError,
	      resolve(item) {
	        return resolveMaybeRef(item, resolveOptions);
	      },
	      options,
	      originalValue,
	      schema
	    };
	    const handleResult = validOrError => {
	      if (ValidationError.isError(validOrError)) invalid(validOrError);else if (!validOrError) invalid(createError());else next(null);
	    };
	    const handleError = err => {
	      if (ValidationError.isError(err)) invalid(err);else panic(err);
	    };
	    const shouldSkip = skipAbsent && isAbsent(value);
	    if (shouldSkip) {
	      return handleResult(true);
	    }
	    let result;
	    try {
	      var _result;
	      result = test.call(ctx, value, ctx);
	      if (typeof ((_result = result) == null ? void 0 : _result.then) === 'function') {
	        if (options.sync) {
	          throw new Error(`Validation test of type: "${ctx.type}" returned a Promise during a synchronous validate. ` + `This test will finish after the validate call has returned`);
	        }
	        return Promise.resolve(result).then(handleResult, handleError);
	      }
	    } catch (err) {
	      handleError(err);
	      return;
	    }
	    handleResult(result);
	  }
	  validate.OPTIONS = config;
	  return validate;
	}

	// Warning: mutates the input
	function resolveParams(params, options) {
	  if (!params) return params;
	  for (const key of Object.keys(params)) {
	    params[key] = resolveMaybeRef(params[key], options);
	  }
	  return params;
	}
	function resolveMaybeRef(item, options) {
	  return Reference.isRef(item) ? item.getValue(options.value, options.parent, options.context) : item;
	}

	function getIn(schema, path, value, context = value) {
	  let parent, lastPart, lastPartDebug;

	  // root path: ''
	  if (!path) return {
	    parent,
	    parentPath: path,
	    schema
	  };
	  propertyExprExports.forEach(path, (_part, isBracket, isArray) => {
	    let part = isBracket ? _part.slice(1, _part.length - 1) : _part;
	    schema = schema.resolve({
	      context,
	      parent,
	      value
	    });
	    let isTuple = schema.type === 'tuple';
	    let idx = isArray ? parseInt(part, 10) : 0;
	    if (schema.innerType || isTuple) {
	      if (isTuple && !isArray) throw new Error(`Yup.reach cannot implicitly index into a tuple type. the path part "${lastPartDebug}" must contain an index to the tuple element, e.g. "${lastPartDebug}[0]"`);
	      if (value && idx >= value.length) {
	        throw new Error(`Yup.reach cannot resolve an array item at index: ${_part}, in the path: ${path}. ` + `because there is no value at that index. `);
	      }
	      parent = value;
	      value = value && value[idx];
	      schema = isTuple ? schema.spec.types[idx] : schema.innerType;
	    }

	    // sometimes the array index part of a path doesn't exist: "nested.arr.child"
	    // in these cases the current part is the next schema and should be processed
	    // in this iteration. For cases where the index signature is included this
	    // check will fail and we'll handle the `child` part on the next iteration like normal
	    if (!isArray) {
	      if (!schema.fields || !schema.fields[part]) throw new Error(`The schema does not contain the path: ${path}. ` + `(failed at: ${lastPartDebug} which is a type: "${schema.type}")`);
	      parent = value;
	      value = value && value[part];
	      schema = schema.fields[part];
	    }
	    lastPart = part;
	    lastPartDebug = isBracket ? '[' + _part + ']' : '.' + _part;
	  });
	  return {
	    schema,
	    parent,
	    parentPath: lastPart
	  };
	}

	class ReferenceSet extends Set {
	  describe() {
	    const description = [];
	    for (const item of this.values()) {
	      description.push(Reference.isRef(item) ? item.describe() : item);
	    }
	    return description;
	  }
	  resolveAll(resolve) {
	    let result = [];
	    for (const item of this.values()) {
	      result.push(resolve(item));
	    }
	    return result;
	  }
	  clone() {
	    return new ReferenceSet(this.values());
	  }
	  merge(newItems, removeItems) {
	    const next = this.clone();
	    newItems.forEach(value => next.add(value));
	    removeItems.forEach(value => next.delete(value));
	    return next;
	  }
	}

	// tweaked from https://github.com/Kelin2025/nanoclone/blob/0abeb7635bda9b68ef2277093f76dbe3bf3948e1/src/index.js
	function clone(src, seen = new Map()) {
	  if (isSchema(src) || !src || typeof src !== 'object') return src;
	  if (seen.has(src)) return seen.get(src);
	  let copy;
	  if (src instanceof Date) {
	    // Date
	    copy = new Date(src.getTime());
	    seen.set(src, copy);
	  } else if (src instanceof RegExp) {
	    // RegExp
	    copy = new RegExp(src);
	    seen.set(src, copy);
	  } else if (Array.isArray(src)) {
	    // Array
	    copy = new Array(src.length);
	    seen.set(src, copy);
	    for (let i = 0; i < src.length; i++) copy[i] = clone(src[i], seen);
	  } else if (src instanceof Map) {
	    // Map
	    copy = new Map();
	    seen.set(src, copy);
	    for (const [k, v] of src.entries()) copy.set(k, clone(v, seen));
	  } else if (src instanceof Set) {
	    // Set
	    copy = new Set();
	    seen.set(src, copy);
	    for (const v of src) copy.add(clone(v, seen));
	  } else if (src instanceof Object) {
	    // Object
	    copy = {};
	    seen.set(src, copy);
	    for (const [k, v] of Object.entries(src)) copy[k] = clone(v, seen);
	  } else {
	    throw Error(`Unable to clone ${src}`);
	  }
	  return copy;
	}

	/**
	 * Copied from @standard-schema/spec to avoid having a dependency on it.
	 * https://github.com/standard-schema/standard-schema/blob/main/packages/spec/src/index.ts
	 */

	function createStandardPath(path) {
	  if (!(path != null && path.length)) {
	    return undefined;
	  }

	  // Array to store the final path segments
	  const segments = [];
	  // Buffer for building the current segment
	  let currentSegment = '';
	  // Track if we're inside square brackets (array/property access)
	  let inBrackets = false;
	  // Track if we're inside quotes (for property names with special chars)
	  let inQuotes = false;
	  for (let i = 0; i < path.length; i++) {
	    const char = path[i];
	    if (char === '[' && !inQuotes) {
	      // When entering brackets, push any accumulated segment after splitting on dots
	      if (currentSegment) {
	        segments.push(...currentSegment.split('.').filter(Boolean));
	        currentSegment = '';
	      }
	      inBrackets = true;
	      continue;
	    }
	    if (char === ']' && !inQuotes) {
	      if (currentSegment) {
	        // Handle numeric indices (e.g. arr[0])
	        if (/^\d+$/.test(currentSegment)) {
	          segments.push(currentSegment);
	        } else {
	          // Handle quoted property names (e.g. obj["foo.bar"])
	          segments.push(currentSegment.replace(/^"|"$/g, ''));
	        }
	        currentSegment = '';
	      }
	      inBrackets = false;
	      continue;
	    }
	    if (char === '"') {
	      // Toggle quote state for handling quoted property names
	      inQuotes = !inQuotes;
	      continue;
	    }
	    if (char === '.' && !inBrackets && !inQuotes) {
	      // On dots outside brackets/quotes, push current segment
	      if (currentSegment) {
	        segments.push(currentSegment);
	        currentSegment = '';
	      }
	      continue;
	    }
	    currentSegment += char;
	  }

	  // Push any remaining segment after splitting on dots
	  if (currentSegment) {
	    segments.push(...currentSegment.split('.').filter(Boolean));
	  }
	  return segments;
	}
	function createStandardIssues(error, parentPath) {
	  const path = parentPath ? `${parentPath}.${error.path}` : error.path;
	  return error.errors.map(err => ({
	    message: err,
	    path: createStandardPath(path)
	  }));
	}
	function issuesFromValidationError(error, parentPath) {
	  var _error$inner;
	  if (!((_error$inner = error.inner) != null && _error$inner.length) && error.errors.length) {
	    return createStandardIssues(error, parentPath);
	  }
	  const path = parentPath ? `${parentPath}.${error.path}` : error.path;
	  return error.inner.flatMap(err => issuesFromValidationError(err, path));
	}

	// If `CustomSchemaMeta` isn't extended with any keys, we'll fall back to a
	// loose Record definition allowing free form usage.
	class Schema {
	  constructor(options) {
	    this.type = void 0;
	    this.deps = [];
	    this.tests = void 0;
	    this.transforms = void 0;
	    this.conditions = [];
	    this._mutate = void 0;
	    this.internalTests = {};
	    this._whitelist = new ReferenceSet();
	    this._blacklist = new ReferenceSet();
	    this.exclusiveTests = Object.create(null);
	    this._typeCheck = void 0;
	    this.spec = void 0;
	    this.tests = [];
	    this.transforms = [];
	    this.withMutation(() => {
	      this.typeError(mixed.notType);
	    });
	    this.type = options.type;
	    this._typeCheck = options.check;
	    this.spec = Object.assign({
	      strip: false,
	      strict: false,
	      abortEarly: true,
	      recursive: true,
	      disableStackTrace: false,
	      nullable: false,
	      optional: true,
	      coerce: true
	    }, options == null ? void 0 : options.spec);
	    this.withMutation(s => {
	      s.nonNullable();
	    });
	  }

	  // TODO: remove
	  get _type() {
	    return this.type;
	  }
	  clone(spec) {
	    if (this._mutate) {
	      if (spec) Object.assign(this.spec, spec);
	      return this;
	    }

	    // if the nested value is a schema we can skip cloning, since
	    // they are already immutable
	    const next = Object.create(Object.getPrototypeOf(this));

	    // @ts-expect-error this is readonly
	    next.type = this.type;
	    next._typeCheck = this._typeCheck;
	    next._whitelist = this._whitelist.clone();
	    next._blacklist = this._blacklist.clone();
	    next.internalTests = Object.assign({}, this.internalTests);
	    next.exclusiveTests = Object.assign({}, this.exclusiveTests);

	    // @ts-expect-error this is readonly
	    next.deps = [...this.deps];
	    next.conditions = [...this.conditions];
	    next.tests = [...this.tests];
	    next.transforms = [...this.transforms];
	    next.spec = clone(Object.assign({}, this.spec, spec));
	    return next;
	  }
	  label(label) {
	    let next = this.clone();
	    next.spec.label = label;
	    return next;
	  }
	  meta(...args) {
	    if (args.length === 0) return this.spec.meta;
	    let next = this.clone();
	    next.spec.meta = Object.assign(next.spec.meta || {}, args[0]);
	    return next;
	  }
	  withMutation(fn) {
	    let before = this._mutate;
	    this._mutate = true;
	    let result = fn(this);
	    this._mutate = before;
	    return result;
	  }
	  concat(schema) {
	    if (!schema || schema === this) return this;
	    if (schema.type !== this.type && this.type !== 'mixed') throw new TypeError(`You cannot \`concat()\` schema's of different types: ${this.type} and ${schema.type}`);
	    let base = this;
	    let combined = schema.clone();
	    const mergedSpec = Object.assign({}, base.spec, combined.spec);
	    combined.spec = mergedSpec;
	    combined.internalTests = Object.assign({}, base.internalTests, combined.internalTests);

	    // manually merge the blacklist/whitelist (the other `schema` takes
	    // precedence in case of conflicts)
	    combined._whitelist = base._whitelist.merge(schema._whitelist, schema._blacklist);
	    combined._blacklist = base._blacklist.merge(schema._blacklist, schema._whitelist);

	    // start with the current tests
	    combined.tests = base.tests;
	    combined.exclusiveTests = base.exclusiveTests;

	    // manually add the new tests to ensure
	    // the deduping logic is consistent
	    combined.withMutation(next => {
	      schema.tests.forEach(fn => {
	        next.test(fn.OPTIONS);
	      });
	    });
	    combined.transforms = [...base.transforms, ...combined.transforms];
	    return combined;
	  }
	  isType(v) {
	    if (v == null) {
	      if (this.spec.nullable && v === null) return true;
	      if (this.spec.optional && v === undefined) return true;
	      return false;
	    }
	    return this._typeCheck(v);
	  }
	  resolve(options) {
	    let schema = this;
	    if (schema.conditions.length) {
	      let conditions = schema.conditions;
	      schema = schema.clone();
	      schema.conditions = [];
	      schema = conditions.reduce((prevSchema, condition) => condition.resolve(prevSchema, options), schema);
	      schema = schema.resolve(options);
	    }
	    return schema;
	  }
	  resolveOptions(options) {
	    var _options$strict, _options$abortEarly, _options$recursive, _options$disableStack;
	    return Object.assign({}, options, {
	      from: options.from || [],
	      strict: (_options$strict = options.strict) != null ? _options$strict : this.spec.strict,
	      abortEarly: (_options$abortEarly = options.abortEarly) != null ? _options$abortEarly : this.spec.abortEarly,
	      recursive: (_options$recursive = options.recursive) != null ? _options$recursive : this.spec.recursive,
	      disableStackTrace: (_options$disableStack = options.disableStackTrace) != null ? _options$disableStack : this.spec.disableStackTrace
	    });
	  }

	  /**
	   * Run the configured transform pipeline over an input value.
	   */

	  cast(value, options = {}) {
	    let resolvedSchema = this.resolve(Object.assign({}, options, {
	      value
	      // parent: options.parent,
	      // context: options.context,
	    }));

	    let allowOptionality = options.assert === 'ignore-optionality';
	    let result = resolvedSchema._cast(value, options);
	    if (options.assert !== false && !resolvedSchema.isType(result)) {
	      if (allowOptionality && isAbsent(result)) {
	        return result;
	      }
	      let formattedValue = printValue(value);
	      let formattedResult = printValue(result);
	      throw new TypeError(`The value of ${options.path || 'field'} could not be cast to a value ` + `that satisfies the schema type: "${resolvedSchema.type}". \n\n` + `attempted value: ${formattedValue} \n` + (formattedResult !== formattedValue ? `result of cast: ${formattedResult}` : ''));
	    }
	    return result;
	  }
	  _cast(rawValue, options) {
	    let value = rawValue === undefined ? rawValue : this.transforms.reduce((prevValue, fn) => fn.call(this, prevValue, rawValue, this, options), rawValue);
	    if (value === undefined) {
	      value = this.getDefault(options);
	    }
	    return value;
	  }
	  _validate(_value, options = {}, panic, next) {
	    let {
	      path,
	      originalValue = _value,
	      strict = this.spec.strict
	    } = options;
	    let value = _value;
	    if (!strict) {
	      value = this._cast(value, Object.assign({
	        assert: false
	      }, options));
	    }
	    let initialTests = [];
	    for (let test of Object.values(this.internalTests)) {
	      if (test) initialTests.push(test);
	    }
	    this.runTests({
	      path,
	      value,
	      originalValue,
	      options,
	      tests: initialTests
	    }, panic, initialErrors => {
	      // even if we aren't ending early we can't proceed further if the types aren't correct
	      if (initialErrors.length) {
	        return next(initialErrors, value);
	      }
	      this.runTests({
	        path,
	        value,
	        originalValue,
	        options,
	        tests: this.tests
	      }, panic, next);
	    });
	  }

	  /**
	   * Executes a set of validations, either schema, produced Tests or a nested
	   * schema validate result.
	   */
	  runTests(runOptions, panic, next) {
	    let fired = false;
	    let {
	      tests,
	      value,
	      originalValue,
	      path,
	      options
	    } = runOptions;
	    let panicOnce = arg => {
	      if (fired) return;
	      fired = true;
	      panic(arg, value);
	    };
	    let nextOnce = arg => {
	      if (fired) return;
	      fired = true;
	      next(arg, value);
	    };
	    let count = tests.length;
	    let nestedErrors = [];
	    if (!count) return nextOnce([]);
	    let args = {
	      value,
	      originalValue,
	      path,
	      options,
	      schema: this
	    };
	    for (let i = 0; i < tests.length; i++) {
	      const test = tests[i];
	      test(args, panicOnce, function finishTestRun(err) {
	        if (err) {
	          Array.isArray(err) ? nestedErrors.push(...err) : nestedErrors.push(err);
	        }
	        if (--count <= 0) {
	          nextOnce(nestedErrors);
	        }
	      });
	    }
	  }
	  asNestedTest({
	    key,
	    index,
	    parent,
	    parentPath,
	    originalParent,
	    options
	  }) {
	    const k = key != null ? key : index;
	    if (k == null) {
	      throw TypeError('Must include `key` or `index` for nested validations');
	    }
	    const isIndex = typeof k === 'number';
	    let value = parent[k];
	    const testOptions = Object.assign({}, options, {
	      // Nested validations fields are always strict:
	      //    1. parent isn't strict so the casting will also have cast inner values
	      //    2. parent is strict in which case the nested values weren't cast either
	      strict: true,
	      parent,
	      value,
	      originalValue: originalParent[k],
	      // FIXME: tests depend on `index` being passed around deeply,
	      //   we should not let the options.key/index bleed through
	      key: undefined,
	      // index: undefined,
	      [isIndex ? 'index' : 'key']: k,
	      path: isIndex || k.includes('.') ? `${parentPath || ''}[${isIndex ? k : `"${k}"`}]` : (parentPath ? `${parentPath}.` : '') + key
	    });
	    return (_, panic, next) => this.resolve(testOptions)._validate(value, testOptions, panic, next);
	  }
	  validate(value, options) {
	    var _options$disableStack2;
	    let schema = this.resolve(Object.assign({}, options, {
	      value
	    }));
	    let disableStackTrace = (_options$disableStack2 = options == null ? void 0 : options.disableStackTrace) != null ? _options$disableStack2 : schema.spec.disableStackTrace;
	    return new Promise((resolve, reject) => schema._validate(value, options, (error, parsed) => {
	      if (ValidationError.isError(error)) error.value = parsed;
	      reject(error);
	    }, (errors, validated) => {
	      if (errors.length) reject(new ValidationError(errors, validated, undefined, undefined, disableStackTrace));else resolve(validated);
	    }));
	  }
	  validateSync(value, options) {
	    var _options$disableStack3;
	    let schema = this.resolve(Object.assign({}, options, {
	      value
	    }));
	    let result;
	    let disableStackTrace = (_options$disableStack3 = options == null ? void 0 : options.disableStackTrace) != null ? _options$disableStack3 : schema.spec.disableStackTrace;
	    schema._validate(value, Object.assign({}, options, {
	      sync: true
	    }), (error, parsed) => {
	      if (ValidationError.isError(error)) error.value = parsed;
	      throw error;
	    }, (errors, validated) => {
	      if (errors.length) throw new ValidationError(errors, value, undefined, undefined, disableStackTrace);
	      result = validated;
	    });
	    return result;
	  }
	  isValid(value, options) {
	    return this.validate(value, options).then(() => true, err => {
	      if (ValidationError.isError(err)) return false;
	      throw err;
	    });
	  }
	  isValidSync(value, options) {
	    try {
	      this.validateSync(value, options);
	      return true;
	    } catch (err) {
	      if (ValidationError.isError(err)) return false;
	      throw err;
	    }
	  }
	  _getDefault(options) {
	    let defaultValue = this.spec.default;
	    if (defaultValue == null) {
	      return defaultValue;
	    }
	    return typeof defaultValue === 'function' ? defaultValue.call(this, options) : clone(defaultValue);
	  }
	  getDefault(options
	  // If schema is defaulted we know it's at least not undefined
	  ) {
	    let schema = this.resolve(options || {});
	    return schema._getDefault(options);
	  }
	  default(def) {
	    if (arguments.length === 0) {
	      return this._getDefault();
	    }
	    let next = this.clone({
	      default: def
	    });
	    return next;
	  }
	  strict(isStrict = true) {
	    return this.clone({
	      strict: isStrict
	    });
	  }
	  nullability(nullable, message) {
	    const next = this.clone({
	      nullable
	    });
	    next.internalTests.nullable = createValidation({
	      message,
	      name: 'nullable',
	      test(value) {
	        return value === null ? this.schema.spec.nullable : true;
	      }
	    });
	    return next;
	  }
	  optionality(optional, message) {
	    const next = this.clone({
	      optional
	    });
	    next.internalTests.optionality = createValidation({
	      message,
	      name: 'optionality',
	      test(value) {
	        return value === undefined ? this.schema.spec.optional : true;
	      }
	    });
	    return next;
	  }
	  optional() {
	    return this.optionality(true);
	  }
	  defined(message = mixed.defined) {
	    return this.optionality(false, message);
	  }
	  nullable() {
	    return this.nullability(true);
	  }
	  nonNullable(message = mixed.notNull) {
	    return this.nullability(false, message);
	  }
	  required(message = mixed.required) {
	    return this.clone().withMutation(next => next.nonNullable(message).defined(message));
	  }
	  notRequired() {
	    return this.clone().withMutation(next => next.nullable().optional());
	  }
	  transform(fn) {
	    let next = this.clone();
	    next.transforms.push(fn);
	    return next;
	  }

	  /**
	   * Adds a test function to the schema's queue of tests.
	   * tests can be exclusive or non-exclusive.
	   *
	   * - exclusive tests, will replace any existing tests of the same name.
	   * - non-exclusive: can be stacked
	   *
	   * If a non-exclusive test is added to a schema with an exclusive test of the same name
	   * the exclusive test is removed and further tests of the same name will be stacked.
	   *
	   * If an exclusive test is added to a schema with non-exclusive tests of the same name
	   * the previous tests are removed and further tests of the same name will replace each other.
	   */

	  test(...args) {
	    let opts;
	    if (args.length === 1) {
	      if (typeof args[0] === 'function') {
	        opts = {
	          test: args[0]
	        };
	      } else {
	        opts = args[0];
	      }
	    } else if (args.length === 2) {
	      opts = {
	        name: args[0],
	        test: args[1]
	      };
	    } else {
	      opts = {
	        name: args[0],
	        message: args[1],
	        test: args[2]
	      };
	    }
	    if (opts.message === undefined) opts.message = mixed.default;
	    if (typeof opts.test !== 'function') throw new TypeError('`test` is a required parameters');
	    let next = this.clone();
	    let validate = createValidation(opts);
	    let isExclusive = opts.exclusive || opts.name && next.exclusiveTests[opts.name] === true;
	    if (opts.exclusive) {
	      if (!opts.name) throw new TypeError('Exclusive tests must provide a unique `name` identifying the test');
	    }
	    if (opts.name) next.exclusiveTests[opts.name] = !!opts.exclusive;
	    next.tests = next.tests.filter(fn => {
	      if (fn.OPTIONS.name === opts.name) {
	        if (isExclusive) return false;
	        if (fn.OPTIONS.test === validate.OPTIONS.test) return false;
	      }
	      return true;
	    });
	    next.tests.push(validate);
	    return next;
	  }
	  when(keys, options) {
	    if (!Array.isArray(keys) && typeof keys !== 'string') {
	      options = keys;
	      keys = '.';
	    }
	    let next = this.clone();
	    let deps = toArray(keys).map(key => new Reference(key));
	    deps.forEach(dep => {
	      // @ts-ignore readonly array
	      if (dep.isSibling) next.deps.push(dep.key);
	    });
	    next.conditions.push(typeof options === 'function' ? new Condition(deps, options) : Condition.fromOptions(deps, options));
	    return next;
	  }
	  typeError(message) {
	    let next = this.clone();
	    next.internalTests.typeError = createValidation({
	      message,
	      name: 'typeError',
	      skipAbsent: true,
	      test(value) {
	        if (!this.schema._typeCheck(value)) return this.createError({
	          params: {
	            type: this.schema.type
	          }
	        });
	        return true;
	      }
	    });
	    return next;
	  }
	  oneOf(enums, message = mixed.oneOf) {
	    let next = this.clone();
	    enums.forEach(val => {
	      next._whitelist.add(val);
	      next._blacklist.delete(val);
	    });
	    next.internalTests.whiteList = createValidation({
	      message,
	      name: 'oneOf',
	      skipAbsent: true,
	      test(value) {
	        let valids = this.schema._whitelist;
	        let resolved = valids.resolveAll(this.resolve);
	        return resolved.includes(value) ? true : this.createError({
	          params: {
	            values: Array.from(valids).join(', '),
	            resolved
	          }
	        });
	      }
	    });
	    return next;
	  }
	  notOneOf(enums, message = mixed.notOneOf) {
	    let next = this.clone();
	    enums.forEach(val => {
	      next._blacklist.add(val);
	      next._whitelist.delete(val);
	    });
	    next.internalTests.blacklist = createValidation({
	      message,
	      name: 'notOneOf',
	      test(value) {
	        let invalids = this.schema._blacklist;
	        let resolved = invalids.resolveAll(this.resolve);
	        if (resolved.includes(value)) return this.createError({
	          params: {
	            values: Array.from(invalids).join(', '),
	            resolved
	          }
	        });
	        return true;
	      }
	    });
	    return next;
	  }
	  strip(strip = true) {
	    let next = this.clone();
	    next.spec.strip = strip;
	    return next;
	  }

	  /**
	   * Return a serialized description of the schema including validations, flags, types etc.
	   *
	   * @param options Provide any needed context for resolving runtime schema alterations (lazy, when conditions, etc).
	   */
	  describe(options) {
	    const next = (options ? this.resolve(options) : this).clone();
	    const {
	      label,
	      meta,
	      optional,
	      nullable
	    } = next.spec;
	    const description = {
	      meta,
	      label,
	      optional,
	      nullable,
	      default: next.getDefault(options),
	      type: next.type,
	      oneOf: next._whitelist.describe(),
	      notOneOf: next._blacklist.describe(),
	      tests: next.tests.filter((n, idx, list) => list.findIndex(c => c.OPTIONS.name === n.OPTIONS.name) === idx).map(fn => {
	        const params = fn.OPTIONS.params && options ? resolveParams(Object.assign({}, fn.OPTIONS.params), options) : fn.OPTIONS.params;
	        return {
	          name: fn.OPTIONS.name,
	          params
	        };
	      })
	    };
	    return description;
	  }
	  get ['~standard']() {
	    const schema = this;
	    const standard = {
	      version: 1,
	      vendor: 'yup',
	      async validate(value) {
	        try {
	          const result = await schema.validate(value, {
	            abortEarly: false
	          });
	          return {
	            value: result
	          };
	        } catch (err) {
	          if (err instanceof ValidationError) {
	            return {
	              issues: issuesFromValidationError(err)
	            };
	          }
	          throw err;
	        }
	      }
	    };
	    return standard;
	  }
	}
	// @ts-expect-error
	Schema.prototype.__isYupSchema__ = true;
	for (const method of ['validate', 'validateSync']) Schema.prototype[`${method}At`] = function (path, value, options = {}) {
	  const {
	    parent,
	    parentPath,
	    schema
	  } = getIn(this, path, value, options.context);
	  return schema[method](parent && parent[parentPath], Object.assign({}, options, {
	    parent,
	    path
	  }));
	};
	for (const alias of ['equals', 'is']) Schema.prototype[alias] = Schema.prototype.oneOf;
	for (const alias of ['not', 'nope']) Schema.prototype[alias] = Schema.prototype.notOneOf;

	const returnsTrue = () => true;
	function create$8(spec) {
	  return new MixedSchema(spec);
	}
	class MixedSchema extends Schema {
	  constructor(spec) {
	    super(typeof spec === 'function' ? {
	      type: 'mixed',
	      check: spec
	    } : Object.assign({
	      type: 'mixed',
	      check: returnsTrue
	    }, spec));
	  }
	}
	create$8.prototype = MixedSchema.prototype;

	function create$7() {
	  return new BooleanSchema();
	}
	class BooleanSchema extends Schema {
	  constructor() {
	    super({
	      type: 'boolean',
	      check(v) {
	        if (v instanceof Boolean) v = v.valueOf();
	        return typeof v === 'boolean';
	      }
	    });
	    this.withMutation(() => {
	      this.transform((value, _raw) => {
	        if (this.spec.coerce && !this.isType(value)) {
	          if (/^(true|1)$/i.test(String(value))) return true;
	          if (/^(false|0)$/i.test(String(value))) return false;
	        }
	        return value;
	      });
	    });
	  }
	  isTrue(message = boolean.isValue) {
	    return this.test({
	      message,
	      name: 'is-value',
	      exclusive: true,
	      params: {
	        value: 'true'
	      },
	      test(value) {
	        return isAbsent(value) || value === true;
	      }
	    });
	  }
	  isFalse(message = boolean.isValue) {
	    return this.test({
	      message,
	      name: 'is-value',
	      exclusive: true,
	      params: {
	        value: 'false'
	      },
	      test(value) {
	        return isAbsent(value) || value === false;
	      }
	    });
	  }
	  default(def) {
	    return super.default(def);
	  }
	  defined(msg) {
	    return super.defined(msg);
	  }
	  optional() {
	    return super.optional();
	  }
	  required(msg) {
	    return super.required(msg);
	  }
	  notRequired() {
	    return super.notRequired();
	  }
	  nullable() {
	    return super.nullable();
	  }
	  nonNullable(msg) {
	    return super.nonNullable(msg);
	  }
	  strip(v) {
	    return super.strip(v);
	  }
	}
	create$7.prototype = BooleanSchema.prototype;

	/**
	 * This file is a modified version of the file from the following repository:
	 * Date.parse with progressive enhancement for ISO 8601 <https://github.com/csnover/js-iso8601>
	 * NON-CONFORMANT EDITION.
	 *  2011 Colin Snover <http://zetafleet.com>
	 * Released under MIT license.
	 */

	// prettier-ignore
	//                1 YYYY                2 MM        3 DD              4 HH     5 mm        6 ss           7 msec         8 Z 9    10 tzHH    11 tzmm
	const isoReg = /^(\d{4}|[+-]\d{6})(?:-?(\d{2})(?:-?(\d{2}))?)?(?:[ T]?(\d{2}):?(\d{2})(?::?(\d{2})(?:[,.](\d{1,}))?)?(?:(Z)|([+-])(\d{2})(?::?(\d{2}))?)?)?$/;
	function parseIsoDate(date) {
	  const struct = parseDateStruct(date);
	  if (!struct) return Date.parse ? Date.parse(date) : Number.NaN;

	  // timestamps without timezone identifiers should be considered local time
	  if (struct.z === undefined && struct.plusMinus === undefined) {
	    return new Date(struct.year, struct.month, struct.day, struct.hour, struct.minute, struct.second, struct.millisecond).valueOf();
	  }
	  let totalMinutesOffset = 0;
	  if (struct.z !== 'Z' && struct.plusMinus !== undefined) {
	    totalMinutesOffset = struct.hourOffset * 60 + struct.minuteOffset;
	    if (struct.plusMinus === '+') totalMinutesOffset = 0 - totalMinutesOffset;
	  }
	  return Date.UTC(struct.year, struct.month, struct.day, struct.hour, struct.minute + totalMinutesOffset, struct.second, struct.millisecond);
	}
	function parseDateStruct(date) {
	  var _regexResult$7$length, _regexResult$;
	  const regexResult = isoReg.exec(date);
	  if (!regexResult) return null;

	  // use of toNumber() avoids NaN timestamps caused by undefined
	  // values being passed to Date constructor
	  return {
	    year: toNumber(regexResult[1]),
	    month: toNumber(regexResult[2], 1) - 1,
	    day: toNumber(regexResult[3], 1),
	    hour: toNumber(regexResult[4]),
	    minute: toNumber(regexResult[5]),
	    second: toNumber(regexResult[6]),
	    millisecond: regexResult[7] ?
	    // allow arbitrary sub-second precision beyond milliseconds
	    toNumber(regexResult[7].substring(0, 3)) : 0,
	    precision: (_regexResult$7$length = (_regexResult$ = regexResult[7]) == null ? void 0 : _regexResult$.length) != null ? _regexResult$7$length : undefined,
	    z: regexResult[8] || undefined,
	    plusMinus: regexResult[9] || undefined,
	    hourOffset: toNumber(regexResult[10]),
	    minuteOffset: toNumber(regexResult[11])
	  };
	}
	function toNumber(str, defaultValue = 0) {
	  return Number(str) || defaultValue;
	}

	// Taken from HTML spec: https://html.spec.whatwg.org/multipage/input.html#valid-e-mail-address
	let rEmail =
	// eslint-disable-next-line
	/^[a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
	let rUrl =
	// eslint-disable-next-line
	/^((https?|ftp):)?\/\/(((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:)*@)?(((\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5]))|((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.?)(:\d*)?)(\/((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)+(\/(([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)*)*)?)?(\?((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|[\uE000-\uF8FF]|\/|\?)*)?(\#((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|\/|\?)*)?$/i;

	// eslint-disable-next-line
	let rUUID = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
	let yearMonthDay = '^\\d{4}-\\d{2}-\\d{2}';
	let hourMinuteSecond = '\\d{2}:\\d{2}:\\d{2}';
	let zOrOffset = '(([+-]\\d{2}(:?\\d{2})?)|Z)';
	let rIsoDateTime = new RegExp(`${yearMonthDay}T${hourMinuteSecond}(\\.\\d+)?${zOrOffset}$`);
	let isTrimmed = value => isAbsent(value) || value === value.trim();
	let objStringTag = {}.toString();
	function create$6() {
	  return new StringSchema();
	}
	class StringSchema extends Schema {
	  constructor() {
	    super({
	      type: 'string',
	      check(value) {
	        if (value instanceof String) value = value.valueOf();
	        return typeof value === 'string';
	      }
	    });
	    this.withMutation(() => {
	      this.transform((value, _raw) => {
	        if (!this.spec.coerce || this.isType(value)) return value;

	        // don't ever convert arrays
	        if (Array.isArray(value)) return value;
	        const strValue = value != null && value.toString ? value.toString() : value;

	        // no one wants plain objects converted to [Object object]
	        if (strValue === objStringTag) return value;
	        return strValue;
	      });
	    });
	  }
	  required(message) {
	    return super.required(message).withMutation(schema => schema.test({
	      message: message || mixed.required,
	      name: 'required',
	      skipAbsent: true,
	      test: value => !!value.length
	    }));
	  }
	  notRequired() {
	    return super.notRequired().withMutation(schema => {
	      schema.tests = schema.tests.filter(t => t.OPTIONS.name !== 'required');
	      return schema;
	    });
	  }
	  length(length, message = string.length) {
	    return this.test({
	      message,
	      name: 'length',
	      exclusive: true,
	      params: {
	        length
	      },
	      skipAbsent: true,
	      test(value) {
	        return value.length === this.resolve(length);
	      }
	    });
	  }
	  min(min, message = string.min) {
	    return this.test({
	      message,
	      name: 'min',
	      exclusive: true,
	      params: {
	        min
	      },
	      skipAbsent: true,
	      test(value) {
	        return value.length >= this.resolve(min);
	      }
	    });
	  }
	  max(max, message = string.max) {
	    return this.test({
	      name: 'max',
	      exclusive: true,
	      message,
	      params: {
	        max
	      },
	      skipAbsent: true,
	      test(value) {
	        return value.length <= this.resolve(max);
	      }
	    });
	  }
	  matches(regex, options) {
	    let excludeEmptyString = false;
	    let message;
	    let name;
	    if (options) {
	      if (typeof options === 'object') {
	        ({
	          excludeEmptyString = false,
	          message,
	          name
	        } = options);
	      } else {
	        message = options;
	      }
	    }
	    return this.test({
	      name: name || 'matches',
	      message: message || string.matches,
	      params: {
	        regex
	      },
	      skipAbsent: true,
	      test: value => value === '' && excludeEmptyString || value.search(regex) !== -1
	    });
	  }
	  email(message = string.email) {
	    return this.matches(rEmail, {
	      name: 'email',
	      message,
	      excludeEmptyString: true
	    });
	  }
	  url(message = string.url) {
	    return this.matches(rUrl, {
	      name: 'url',
	      message,
	      excludeEmptyString: true
	    });
	  }
	  uuid(message = string.uuid) {
	    return this.matches(rUUID, {
	      name: 'uuid',
	      message,
	      excludeEmptyString: false
	    });
	  }
	  datetime(options) {
	    let message = '';
	    let allowOffset;
	    let precision;
	    if (options) {
	      if (typeof options === 'object') {
	        ({
	          message = '',
	          allowOffset = false,
	          precision = undefined
	        } = options);
	      } else {
	        message = options;
	      }
	    }
	    return this.matches(rIsoDateTime, {
	      name: 'datetime',
	      message: message || string.datetime,
	      excludeEmptyString: true
	    }).test({
	      name: 'datetime_offset',
	      message: message || string.datetime_offset,
	      params: {
	        allowOffset
	      },
	      skipAbsent: true,
	      test: value => {
	        if (!value || allowOffset) return true;
	        const struct = parseDateStruct(value);
	        if (!struct) return false;
	        return !!struct.z;
	      }
	    }).test({
	      name: 'datetime_precision',
	      message: message || string.datetime_precision,
	      params: {
	        precision
	      },
	      skipAbsent: true,
	      test: value => {
	        if (!value || precision == undefined) return true;
	        const struct = parseDateStruct(value);
	        if (!struct) return false;
	        return struct.precision === precision;
	      }
	    });
	  }

	  //-- transforms --
	  ensure() {
	    return this.default('').transform(val => val === null ? '' : val);
	  }
	  trim(message = string.trim) {
	    return this.transform(val => val != null ? val.trim() : val).test({
	      message,
	      name: 'trim',
	      test: isTrimmed
	    });
	  }
	  lowercase(message = string.lowercase) {
	    return this.transform(value => !isAbsent(value) ? value.toLowerCase() : value).test({
	      message,
	      name: 'string_case',
	      exclusive: true,
	      skipAbsent: true,
	      test: value => isAbsent(value) || value === value.toLowerCase()
	    });
	  }
	  uppercase(message = string.uppercase) {
	    return this.transform(value => !isAbsent(value) ? value.toUpperCase() : value).test({
	      message,
	      name: 'string_case',
	      exclusive: true,
	      skipAbsent: true,
	      test: value => isAbsent(value) || value === value.toUpperCase()
	    });
	  }
	}
	create$6.prototype = StringSchema.prototype;

	//
	// String Interfaces
	//

	let isNaN$1 = value => value != +value;
	function create$5() {
	  return new NumberSchema();
	}
	class NumberSchema extends Schema {
	  constructor() {
	    super({
	      type: 'number',
	      check(value) {
	        if (value instanceof Number) value = value.valueOf();
	        return typeof value === 'number' && !isNaN$1(value);
	      }
	    });
	    this.withMutation(() => {
	      this.transform((value, _raw) => {
	        if (!this.spec.coerce) return value;
	        let parsed = value;
	        if (typeof parsed === 'string') {
	          parsed = parsed.replace(/\s/g, '');
	          if (parsed === '') return NaN;
	          // don't use parseFloat to avoid positives on alpha-numeric strings
	          parsed = +parsed;
	        }

	        // null -> NaN isn't useful; treat all nulls as null and let it fail on
	        // nullability check vs TypeErrors
	        if (this.isType(parsed) || parsed === null) return parsed;
	        return parseFloat(parsed);
	      });
	    });
	  }
	  min(min, message = number.min) {
	    return this.test({
	      message,
	      name: 'min',
	      exclusive: true,
	      params: {
	        min
	      },
	      skipAbsent: true,
	      test(value) {
	        return value >= this.resolve(min);
	      }
	    });
	  }
	  max(max, message = number.max) {
	    return this.test({
	      message,
	      name: 'max',
	      exclusive: true,
	      params: {
	        max
	      },
	      skipAbsent: true,
	      test(value) {
	        return value <= this.resolve(max);
	      }
	    });
	  }
	  lessThan(less, message = number.lessThan) {
	    return this.test({
	      message,
	      name: 'max',
	      exclusive: true,
	      params: {
	        less
	      },
	      skipAbsent: true,
	      test(value) {
	        return value < this.resolve(less);
	      }
	    });
	  }
	  moreThan(more, message = number.moreThan) {
	    return this.test({
	      message,
	      name: 'min',
	      exclusive: true,
	      params: {
	        more
	      },
	      skipAbsent: true,
	      test(value) {
	        return value > this.resolve(more);
	      }
	    });
	  }
	  positive(msg = number.positive) {
	    return this.moreThan(0, msg);
	  }
	  negative(msg = number.negative) {
	    return this.lessThan(0, msg);
	  }
	  integer(message = number.integer) {
	    return this.test({
	      name: 'integer',
	      message,
	      skipAbsent: true,
	      test: val => Number.isInteger(val)
	    });
	  }
	  truncate() {
	    return this.transform(value => !isAbsent(value) ? value | 0 : value);
	  }
	  round(method) {
	    var _method;
	    let avail = ['ceil', 'floor', 'round', 'trunc'];
	    method = ((_method = method) == null ? void 0 : _method.toLowerCase()) || 'round';

	    // this exists for symemtry with the new Math.trunc
	    if (method === 'trunc') return this.truncate();
	    if (avail.indexOf(method.toLowerCase()) === -1) throw new TypeError('Only valid options for round() are: ' + avail.join(', '));
	    return this.transform(value => !isAbsent(value) ? Math[method](value) : value);
	  }
	}
	create$5.prototype = NumberSchema.prototype;

	//
	// Number Interfaces
	//

	let invalidDate = new Date('');
	let isDate$1 = obj => Object.prototype.toString.call(obj) === '[object Date]';
	function create$4() {
	  return new DateSchema();
	}
	class DateSchema extends Schema {
	  constructor() {
	    super({
	      type: 'date',
	      check(v) {
	        return isDate$1(v) && !isNaN(v.getTime());
	      }
	    });
	    this.withMutation(() => {
	      this.transform((value, _raw) => {
	        // null -> InvalidDate isn't useful; treat all nulls as null and let it fail on
	        // nullability check vs TypeErrors
	        if (!this.spec.coerce || this.isType(value) || value === null) return value;
	        value = parseIsoDate(value);

	        // 0 is a valid timestamp equivalent to 1970-01-01T00:00:00Z(unix epoch) or before.
	        return !isNaN(value) ? new Date(value) : DateSchema.INVALID_DATE;
	      });
	    });
	  }
	  prepareParam(ref, name) {
	    let param;
	    if (!Reference.isRef(ref)) {
	      let cast = this.cast(ref);
	      if (!this._typeCheck(cast)) throw new TypeError(`\`${name}\` must be a Date or a value that can be \`cast()\` to a Date`);
	      param = cast;
	    } else {
	      param = ref;
	    }
	    return param;
	  }
	  min(min, message = date.min) {
	    let limit = this.prepareParam(min, 'min');
	    return this.test({
	      message,
	      name: 'min',
	      exclusive: true,
	      params: {
	        min
	      },
	      skipAbsent: true,
	      test(value) {
	        return value >= this.resolve(limit);
	      }
	    });
	  }
	  max(max, message = date.max) {
	    let limit = this.prepareParam(max, 'max');
	    return this.test({
	      message,
	      name: 'max',
	      exclusive: true,
	      params: {
	        max
	      },
	      skipAbsent: true,
	      test(value) {
	        return value <= this.resolve(limit);
	      }
	    });
	  }
	}
	DateSchema.INVALID_DATE = invalidDate;
	create$4.prototype = DateSchema.prototype;
	create$4.INVALID_DATE = invalidDate;

	// @ts-expect-error
	function sortFields(fields, excludedEdges = []) {
	  let edges = [];
	  let nodes = new Set();
	  let excludes = new Set(excludedEdges.map(([a, b]) => `${a}-${b}`));
	  function addNode(depPath, key) {
	    let node = propertyExprExports.split(depPath)[0];
	    nodes.add(node);
	    if (!excludes.has(`${key}-${node}`)) edges.push([key, node]);
	  }
	  for (const key of Object.keys(fields)) {
	    let value = fields[key];
	    nodes.add(key);
	    if (Reference.isRef(value) && value.isSibling) addNode(value.path, key);else if (isSchema(value) && 'deps' in value) value.deps.forEach(path => addNode(path, key));
	  }
	  return toposort.array(Array.from(nodes), edges).reverse();
	}

	function findIndex$1(arr, err) {
	  let idx = Infinity;
	  arr.some((key, ii) => {
	    var _err$path;
	    if ((_err$path = err.path) != null && _err$path.includes(key)) {
	      idx = ii;
	      return true;
	    }
	  });
	  return idx;
	}
	function sortByKeyOrder(keys) {
	  return (a, b) => {
	    return findIndex$1(keys, a) - findIndex$1(keys, b);
	  };
	}

	const parseJson = (value, _, schema) => {
	  if (typeof value !== 'string') {
	    return value;
	  }
	  let parsed = value;
	  try {
	    parsed = JSON.parse(value);
	  } catch (err) {
	    /* */
	  }
	  return schema.isType(parsed) ? parsed : value;
	};

	// @ts-ignore
	function deepPartial(schema) {
	  if ('fields' in schema) {
	    const partial = {};
	    for (const [key, fieldSchema] of Object.entries(schema.fields)) {
	      partial[key] = deepPartial(fieldSchema);
	    }
	    return schema.setFields(partial);
	  }
	  if (schema.type === 'array') {
	    const nextArray = schema.optional();
	    if (nextArray.innerType) nextArray.innerType = deepPartial(nextArray.innerType);
	    return nextArray;
	  }
	  if (schema.type === 'tuple') {
	    return schema.optional().clone({
	      types: schema.spec.types.map(deepPartial)
	    });
	  }
	  if ('optional' in schema) {
	    return schema.optional();
	  }
	  return schema;
	}
	const deepHas = (obj, p) => {
	  const path = [...propertyExprExports.normalizePath(p)];
	  if (path.length === 1) return path[0] in obj;
	  let last = path.pop();
	  let parent = propertyExprExports.getter(propertyExprExports.join(path), true)(obj);
	  return !!(parent && last in parent);
	};
	let isObject$1 = obj => Object.prototype.toString.call(obj) === '[object Object]';
	function unknown(ctx, value) {
	  let known = Object.keys(ctx.fields);
	  return Object.keys(value).filter(key => known.indexOf(key) === -1);
	}
	const defaultSort = sortByKeyOrder([]);
	function create$3(spec) {
	  return new ObjectSchema(spec);
	}
	class ObjectSchema extends Schema {
	  constructor(spec) {
	    super({
	      type: 'object',
	      check(value) {
	        return isObject$1(value) || typeof value === 'function';
	      }
	    });
	    this.fields = Object.create(null);
	    this._sortErrors = defaultSort;
	    this._nodes = [];
	    this._excludedEdges = [];
	    this.withMutation(() => {
	      if (spec) {
	        this.shape(spec);
	      }
	    });
	  }
	  _cast(_value, options = {}) {
	    var _options$stripUnknown;
	    let value = super._cast(_value, options);

	    //should ignore nulls here
	    if (value === undefined) return this.getDefault(options);
	    if (!this._typeCheck(value)) return value;
	    let fields = this.fields;
	    let strip = (_options$stripUnknown = options.stripUnknown) != null ? _options$stripUnknown : this.spec.noUnknown;
	    let props = [].concat(this._nodes, Object.keys(value).filter(v => !this._nodes.includes(v)));
	    let intermediateValue = {}; // is filled during the transform below
	    let innerOptions = Object.assign({}, options, {
	      parent: intermediateValue,
	      __validating: options.__validating || false
	    });
	    let isChanged = false;
	    for (const prop of props) {
	      let field = fields[prop];
	      let exists = (prop in value);
	      let inputValue = value[prop];
	      if (field) {
	        let fieldValue;

	        // safe to mutate since this is fired in sequence
	        innerOptions.path = (options.path ? `${options.path}.` : '') + prop;
	        field = field.resolve({
	          value: inputValue,
	          context: options.context,
	          parent: intermediateValue
	        });
	        let fieldSpec = field instanceof Schema ? field.spec : undefined;
	        let strict = fieldSpec == null ? void 0 : fieldSpec.strict;
	        if (fieldSpec != null && fieldSpec.strip) {
	          isChanged = isChanged || prop in value;
	          continue;
	        }
	        fieldValue = !options.__validating || !strict ? field.cast(inputValue, innerOptions) : inputValue;
	        if (fieldValue !== undefined) {
	          intermediateValue[prop] = fieldValue;
	        }
	      } else if (exists && !strip) {
	        intermediateValue[prop] = inputValue;
	      }
	      if (exists !== prop in intermediateValue || intermediateValue[prop] !== inputValue) {
	        isChanged = true;
	      }
	    }
	    return isChanged ? intermediateValue : value;
	  }
	  _validate(_value, options = {}, panic, next) {
	    let {
	      from = [],
	      originalValue = _value,
	      recursive = this.spec.recursive
	    } = options;
	    options.from = [{
	      schema: this,
	      value: originalValue
	    }, ...from];
	    // this flag is needed for handling `strict` correctly in the context of
	    // validation vs just casting. e.g strict() on a field is only used when validating
	    options.__validating = true;
	    options.originalValue = originalValue;
	    super._validate(_value, options, panic, (objectErrors, value) => {
	      if (!recursive || !isObject$1(value)) {
	        next(objectErrors, value);
	        return;
	      }
	      originalValue = originalValue || value;
	      let tests = [];
	      for (let key of this._nodes) {
	        let field = this.fields[key];
	        if (!field || Reference.isRef(field)) {
	          continue;
	        }
	        tests.push(field.asNestedTest({
	          options,
	          key,
	          parent: value,
	          parentPath: options.path,
	          originalParent: originalValue
	        }));
	      }
	      this.runTests({
	        tests,
	        value,
	        originalValue,
	        options
	      }, panic, fieldErrors => {
	        next(fieldErrors.sort(this._sortErrors).concat(objectErrors), value);
	      });
	    });
	  }
	  clone(spec) {
	    const next = super.clone(spec);
	    next.fields = Object.assign({}, this.fields);
	    next._nodes = this._nodes;
	    next._excludedEdges = this._excludedEdges;
	    next._sortErrors = this._sortErrors;
	    return next;
	  }
	  concat(schema) {
	    let next = super.concat(schema);
	    let nextFields = next.fields;
	    for (let [field, schemaOrRef] of Object.entries(this.fields)) {
	      const target = nextFields[field];
	      nextFields[field] = target === undefined ? schemaOrRef : target;
	    }
	    return next.withMutation(s =>
	    // XXX: excludes here is wrong
	    s.setFields(nextFields, [...this._excludedEdges, ...schema._excludedEdges]));
	  }
	  _getDefault(options) {
	    if ('default' in this.spec) {
	      return super._getDefault(options);
	    }

	    // if there is no default set invent one
	    if (!this._nodes.length) {
	      return undefined;
	    }
	    let dft = {};
	    this._nodes.forEach(key => {
	      var _innerOptions;
	      const field = this.fields[key];
	      let innerOptions = options;
	      if ((_innerOptions = innerOptions) != null && _innerOptions.value) {
	        innerOptions = Object.assign({}, innerOptions, {
	          parent: innerOptions.value,
	          value: innerOptions.value[key]
	        });
	      }
	      dft[key] = field && 'getDefault' in field ? field.getDefault(innerOptions) : undefined;
	    });
	    return dft;
	  }
	  setFields(shape, excludedEdges) {
	    let next = this.clone();
	    next.fields = shape;
	    next._nodes = sortFields(shape, excludedEdges);
	    next._sortErrors = sortByKeyOrder(Object.keys(shape));
	    // XXX: this carries over edges which may not be what you want
	    if (excludedEdges) next._excludedEdges = excludedEdges;
	    return next;
	  }
	  shape(additions, excludes = []) {
	    return this.clone().withMutation(next => {
	      let edges = next._excludedEdges;
	      if (excludes.length) {
	        if (!Array.isArray(excludes[0])) excludes = [excludes];
	        edges = [...next._excludedEdges, ...excludes];
	      }

	      // XXX: excludes here is wrong
	      return next.setFields(Object.assign(next.fields, additions), edges);
	    });
	  }
	  partial() {
	    const partial = {};
	    for (const [key, schema] of Object.entries(this.fields)) {
	      partial[key] = 'optional' in schema && schema.optional instanceof Function ? schema.optional() : schema;
	    }
	    return this.setFields(partial);
	  }
	  deepPartial() {
	    const next = deepPartial(this);
	    return next;
	  }
	  pick(keys) {
	    const picked = {};
	    for (const key of keys) {
	      if (this.fields[key]) picked[key] = this.fields[key];
	    }
	    return this.setFields(picked, this._excludedEdges.filter(([a, b]) => keys.includes(a) && keys.includes(b)));
	  }
	  omit(keys) {
	    const remaining = [];
	    for (const key of Object.keys(this.fields)) {
	      if (keys.includes(key)) continue;
	      remaining.push(key);
	    }
	    return this.pick(remaining);
	  }
	  from(from, to, alias) {
	    let fromGetter = propertyExprExports.getter(from, true);
	    return this.transform(obj => {
	      if (!obj) return obj;
	      let newObj = obj;
	      if (deepHas(obj, from)) {
	        newObj = Object.assign({}, obj);
	        if (!alias) delete newObj[from];
	        newObj[to] = fromGetter(obj);
	      }
	      return newObj;
	    });
	  }

	  /** Parse an input JSON string to an object */
	  json() {
	    return this.transform(parseJson);
	  }

	  /**
	   * Similar to `noUnknown` but only validates that an object is the right shape without stripping the unknown keys
	   */
	  exact(message) {
	    return this.test({
	      name: 'exact',
	      exclusive: true,
	      message: message || object.exact,
	      test(value) {
	        if (value == null) return true;
	        const unknownKeys = unknown(this.schema, value);
	        return unknownKeys.length === 0 || this.createError({
	          params: {
	            properties: unknownKeys.join(', ')
	          }
	        });
	      }
	    });
	  }
	  stripUnknown() {
	    return this.clone({
	      noUnknown: true
	    });
	  }
	  noUnknown(noAllow = true, message = object.noUnknown) {
	    if (typeof noAllow !== 'boolean') {
	      message = noAllow;
	      noAllow = true;
	    }
	    let next = this.test({
	      name: 'noUnknown',
	      exclusive: true,
	      message: message,
	      test(value) {
	        if (value == null) return true;
	        const unknownKeys = unknown(this.schema, value);
	        return !noAllow || unknownKeys.length === 0 || this.createError({
	          params: {
	            unknown: unknownKeys.join(', ')
	          }
	        });
	      }
	    });
	    next.spec.noUnknown = noAllow;
	    return next;
	  }
	  unknown(allow = true, message = object.noUnknown) {
	    return this.noUnknown(!allow, message);
	  }
	  transformKeys(fn) {
	    return this.transform(obj => {
	      if (!obj) return obj;
	      const result = {};
	      for (const key of Object.keys(obj)) result[fn(key)] = obj[key];
	      return result;
	    });
	  }
	  camelCase() {
	    return this.transformKeys(tinyCaseExports.camelCase);
	  }
	  snakeCase() {
	    return this.transformKeys(tinyCaseExports.snakeCase);
	  }
	  constantCase() {
	    return this.transformKeys(key => tinyCaseExports.snakeCase(key).toUpperCase());
	  }
	  describe(options) {
	    const next = (options ? this.resolve(options) : this).clone();
	    const base = super.describe(options);
	    base.fields = {};
	    for (const [key, value] of Object.entries(next.fields)) {
	      var _innerOptions2;
	      let innerOptions = options;
	      if ((_innerOptions2 = innerOptions) != null && _innerOptions2.value) {
	        innerOptions = Object.assign({}, innerOptions, {
	          parent: innerOptions.value,
	          value: innerOptions.value[key]
	        });
	      }
	      base.fields[key] = value.describe(innerOptions);
	    }
	    return base;
	  }
	}
	create$3.prototype = ObjectSchema.prototype;

	function create$2(type) {
	  return new ArraySchema(type);
	}
	class ArraySchema extends Schema {
	  constructor(type) {
	    super({
	      type: 'array',
	      spec: {
	        types: type
	      },
	      check(v) {
	        return Array.isArray(v);
	      }
	    });

	    // `undefined` specifically means uninitialized, as opposed to "no subtype"
	    this.innerType = void 0;
	    this.innerType = type;
	  }
	  _cast(_value, _opts) {
	    const value = super._cast(_value, _opts);

	    // should ignore nulls here
	    if (!this._typeCheck(value) || !this.innerType) {
	      return value;
	    }
	    let isChanged = false;
	    const castArray = value.map((v, idx) => {
	      const castElement = this.innerType.cast(v, Object.assign({}, _opts, {
	        path: `${_opts.path || ''}[${idx}]`,
	        parent: value,
	        originalValue: v,
	        value: v,
	        index: idx
	      }));
	      if (castElement !== v) {
	        isChanged = true;
	      }
	      return castElement;
	    });
	    return isChanged ? castArray : value;
	  }
	  _validate(_value, options = {}, panic, next) {
	    var _options$recursive;
	    // let sync = options.sync;
	    // let path = options.path;
	    let innerType = this.innerType;
	    // let endEarly = options.abortEarly ?? this.spec.abortEarly;
	    let recursive = (_options$recursive = options.recursive) != null ? _options$recursive : this.spec.recursive;
	    options.originalValue != null ? options.originalValue : _value;
	    super._validate(_value, options, panic, (arrayErrors, value) => {
	      var _options$originalValu2;
	      if (!recursive || !innerType || !this._typeCheck(value)) {
	        next(arrayErrors, value);
	        return;
	      }

	      // #950 Ensure that sparse array empty slots are validated
	      let tests = new Array(value.length);
	      for (let index = 0; index < value.length; index++) {
	        var _options$originalValu;
	        tests[index] = innerType.asNestedTest({
	          options,
	          index,
	          parent: value,
	          parentPath: options.path,
	          originalParent: (_options$originalValu = options.originalValue) != null ? _options$originalValu : _value
	        });
	      }
	      this.runTests({
	        value,
	        tests,
	        originalValue: (_options$originalValu2 = options.originalValue) != null ? _options$originalValu2 : _value,
	        options
	      }, panic, innerTypeErrors => next(innerTypeErrors.concat(arrayErrors), value));
	    });
	  }
	  clone(spec) {
	    const next = super.clone(spec);
	    // @ts-expect-error readonly
	    next.innerType = this.innerType;
	    return next;
	  }

	  /** Parse an input JSON string to an object */
	  json() {
	    return this.transform(parseJson);
	  }
	  concat(schema) {
	    let next = super.concat(schema);

	    // @ts-expect-error readonly
	    next.innerType = this.innerType;
	    if (schema.innerType)
	      // @ts-expect-error readonly
	      next.innerType = next.innerType ?
	      // @ts-expect-error Lazy doesn't have concat and will break
	      next.innerType.concat(schema.innerType) : schema.innerType;
	    return next;
	  }
	  of(schema) {
	    // FIXME: this should return a new instance of array without the default to be
	    let next = this.clone();
	    if (!isSchema(schema)) throw new TypeError('`array.of()` sub-schema must be a valid yup schema not: ' + printValue(schema));

	    // @ts-expect-error readonly
	    next.innerType = schema;
	    next.spec = Object.assign({}, next.spec, {
	      types: schema
	    });
	    return next;
	  }
	  length(length, message = array.length) {
	    return this.test({
	      message,
	      name: 'length',
	      exclusive: true,
	      params: {
	        length
	      },
	      skipAbsent: true,
	      test(value) {
	        return value.length === this.resolve(length);
	      }
	    });
	  }
	  min(min, message) {
	    message = message || array.min;
	    return this.test({
	      message,
	      name: 'min',
	      exclusive: true,
	      params: {
	        min
	      },
	      skipAbsent: true,
	      // FIXME(ts): Array<typeof T>
	      test(value) {
	        return value.length >= this.resolve(min);
	      }
	    });
	  }
	  max(max, message) {
	    message = message || array.max;
	    return this.test({
	      message,
	      name: 'max',
	      exclusive: true,
	      params: {
	        max
	      },
	      skipAbsent: true,
	      test(value) {
	        return value.length <= this.resolve(max);
	      }
	    });
	  }
	  ensure() {
	    return this.default(() => []).transform((val, original) => {
	      // We don't want to return `null` for nullable schema
	      if (this._typeCheck(val)) return val;
	      return original == null ? [] : [].concat(original);
	    });
	  }
	  compact(rejector) {
	    let reject = !rejector ? v => !!v : (v, i, a) => !rejector(v, i, a);
	    return this.transform(values => values != null ? values.filter(reject) : values);
	  }
	  describe(options) {
	    const next = (options ? this.resolve(options) : this).clone();
	    const base = super.describe(options);
	    if (next.innerType) {
	      var _innerOptions;
	      let innerOptions = options;
	      if ((_innerOptions = innerOptions) != null && _innerOptions.value) {
	        innerOptions = Object.assign({}, innerOptions, {
	          parent: innerOptions.value,
	          value: innerOptions.value[0]
	        });
	      }
	      base.innerType = next.innerType.describe(innerOptions);
	    }
	    return base;
	  }
	}
	create$2.prototype = ArraySchema.prototype;

	// This file is a workaround for a bug in web browsers' "native"
	// ES6 importing system which is uncapable of importing "*.json" files.
	// https://github.com/catamphetamine/libphonenumber-js/issues/239
	var metadata = {"version":4,"country_calling_codes":{"1":["US","AG","AI","AS","BB","BM","BS","CA","DM","DO","GD","GU","JM","KN","KY","LC","MP","MS","PR","SX","TC","TT","VC","VG","VI"],"7":["RU","KZ"],"20":["EG"],"27":["ZA"],"30":["GR"],"31":["NL"],"32":["BE"],"33":["FR"],"34":["ES"],"36":["HU"],"39":["IT","VA"],"40":["RO"],"41":["CH"],"43":["AT"],"44":["GB","GG","IM","JE"],"45":["DK"],"46":["SE"],"47":["NO","SJ"],"48":["PL"],"49":["DE"],"51":["PE"],"52":["MX"],"53":["CU"],"54":["AR"],"55":["BR"],"56":["CL"],"57":["CO"],"58":["VE"],"60":["MY"],"61":["AU","CC","CX"],"62":["ID"],"63":["PH"],"64":["NZ"],"65":["SG"],"66":["TH"],"81":["JP"],"82":["KR"],"84":["VN"],"86":["CN"],"90":["TR"],"91":["IN"],"92":["PK"],"93":["AF"],"94":["LK"],"95":["MM"],"98":["IR"],"211":["SS"],"212":["MA","EH"],"213":["DZ"],"216":["TN"],"218":["LY"],"220":["GM"],"221":["SN"],"222":["MR"],"223":["ML"],"224":["GN"],"225":["CI"],"226":["BF"],"227":["NE"],"228":["TG"],"229":["BJ"],"230":["MU"],"231":["LR"],"232":["SL"],"233":["GH"],"234":["NG"],"235":["TD"],"236":["CF"],"237":["CM"],"238":["CV"],"239":["ST"],"240":["GQ"],"241":["GA"],"242":["CG"],"243":["CD"],"244":["AO"],"245":["GW"],"246":["IO"],"247":["AC"],"248":["SC"],"249":["SD"],"250":["RW"],"251":["ET"],"252":["SO"],"253":["DJ"],"254":["KE"],"255":["TZ"],"256":["UG"],"257":["BI"],"258":["MZ"],"260":["ZM"],"261":["MG"],"262":["RE","YT"],"263":["ZW"],"264":["NA"],"265":["MW"],"266":["LS"],"267":["BW"],"268":["SZ"],"269":["KM"],"290":["SH","TA"],"291":["ER"],"297":["AW"],"298":["FO"],"299":["GL"],"350":["GI"],"351":["PT"],"352":["LU"],"353":["IE"],"354":["IS"],"355":["AL"],"356":["MT"],"357":["CY"],"358":["FI","AX"],"359":["BG"],"370":["LT"],"371":["LV"],"372":["EE"],"373":["MD"],"374":["AM"],"375":["BY"],"376":["AD"],"377":["MC"],"378":["SM"],"380":["UA"],"381":["RS"],"382":["ME"],"383":["XK"],"385":["HR"],"386":["SI"],"387":["BA"],"389":["MK"],"420":["CZ"],"421":["SK"],"423":["LI"],"500":["FK"],"501":["BZ"],"502":["GT"],"503":["SV"],"504":["HN"],"505":["NI"],"506":["CR"],"507":["PA"],"508":["PM"],"509":["HT"],"590":["GP","BL","MF"],"591":["BO"],"592":["GY"],"593":["EC"],"594":["GF"],"595":["PY"],"596":["MQ"],"597":["SR"],"598":["UY"],"599":["CW","BQ"],"670":["TL"],"672":["NF"],"673":["BN"],"674":["NR"],"675":["PG"],"676":["TO"],"677":["SB"],"678":["VU"],"679":["FJ"],"680":["PW"],"681":["WF"],"682":["CK"],"683":["NU"],"685":["WS"],"686":["KI"],"687":["NC"],"688":["TV"],"689":["PF"],"690":["TK"],"691":["FM"],"692":["MH"],"850":["KP"],"852":["HK"],"853":["MO"],"855":["KH"],"856":["LA"],"880":["BD"],"886":["TW"],"960":["MV"],"961":["LB"],"962":["JO"],"963":["SY"],"964":["IQ"],"965":["KW"],"966":["SA"],"967":["YE"],"968":["OM"],"970":["PS"],"971":["AE"],"972":["IL"],"973":["BH"],"974":["QA"],"975":["BT"],"976":["MN"],"977":["NP"],"992":["TJ"],"993":["TM"],"994":["AZ"],"995":["GE"],"996":["KG"],"998":["UZ"]},"countries":{"AC":["247","00","(?:[01589]\\d|[46])\\d{4}",[5,6]],"AD":["376","00","(?:1|6\\d)\\d{7}|[135-9]\\d{5}",[6,8,9],[["(\\d{3})(\\d{3})","$1 $2",["[135-9]"]],["(\\d{4})(\\d{4})","$1 $2",["1"]],["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["6"]]]],"AE":["971","00","(?:[4-7]\\d|9[0-689])\\d{7}|800\\d{2,9}|[2-4679]\\d{7}",[5,6,7,8,9,10,11,12],[["(\\d{3})(\\d{2,9})","$1 $2",["60|8"]],["(\\d)(\\d{3})(\\d{4})","$1 $2 $3",["[236]|[479][2-8]"],"0$1"],["(\\d{3})(\\d)(\\d{5})","$1 $2 $3",["[479]"]],["(\\d{2})(\\d{3})(\\d{4})","$1 $2 $3",["5"],"0$1"]],"0"],"AF":["93","00","[2-7]\\d{8}",[9],[["(\\d{2})(\\d{3})(\\d{4})","$1 $2 $3",["[2-7]"],"0$1"]],"0"],"AG":["1","011","(?:268|[58]\\d\\d|900)\\d{7}",[10],0,"1",0,"([457]\\d{6})$|1","268$1",0,"268"],"AI":["1","011","(?:264|[58]\\d\\d|900)\\d{7}",[10],0,"1",0,"([2457]\\d{6})$|1","264$1",0,"264"],"AL":["355","00","(?:700\\d\\d|900)\\d{3}|8\\d{5,7}|(?:[2-5]|6\\d)\\d{7}",[6,7,8,9],[["(\\d{3})(\\d{3,4})","$1 $2",["80|9"],"0$1"],["(\\d)(\\d{3})(\\d{4})","$1 $2 $3",["4[2-6]"],"0$1"],["(\\d{2})(\\d{3})(\\d{3})","$1 $2 $3",["[2358][2-5]|4"],"0$1"],["(\\d{3})(\\d{5})","$1 $2",["[23578]"],"0$1"],["(\\d{2})(\\d{3})(\\d{4})","$1 $2 $3",["6"],"0$1"]],"0"],"AM":["374","00","(?:[1-489]\\d|55|60|77)\\d{6}",[8],[["(\\d{3})(\\d{2})(\\d{3})","$1 $2 $3",["[89]0"],"0 $1"],["(\\d{3})(\\d{5})","$1 $2",["2|3[12]"],"(0$1)"],["(\\d{2})(\\d{6})","$1 $2",["1|47"],"(0$1)"],["(\\d{2})(\\d{6})","$1 $2",["[3-9]"],"0$1"]],"0"],"AO":["244","00","[29]\\d{8}",[9],[["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["[29]"]]]],"AR":["54","00","(?:11|[89]\\d\\d)\\d{8}|[2368]\\d{9}",[10,11],[["(\\d{4})(\\d{2})(\\d{4})","$1 $2-$3",["2(?:2[024-9]|3[0-59]|47|6[245]|9[02-8])|3(?:3[28]|4[03-9]|5[2-46-8]|7[1-578]|8[2-9])","2(?:[23]02|6(?:[25]|4[6-8])|9(?:[02356]|4[02568]|72|8[23]))|3(?:3[28]|4(?:[04679]|3[5-8]|5[4-68]|8[2379])|5(?:[2467]|3[237]|8[2-5])|7[1-578]|8(?:[2469]|3[2578]|5[4-8]|7[36-8]|8[5-8]))|2(?:2[24-9]|3[1-59]|47)","2(?:[23]02|6(?:[25]|4(?:64|[78]))|9(?:[02356]|4(?:[0268]|5[2-6])|72|8[23]))|3(?:3[28]|4(?:[04679]|3[78]|5(?:4[46]|8)|8[2379])|5(?:[2467]|3[237]|8[23])|7[1-578]|8(?:[2469]|3[278]|5[56][46]|86[3-6]))|2(?:2[24-9]|3[1-59]|47)|38(?:[58][78]|7[378])|3(?:4[35][56]|58[45]|8(?:[38]5|54|76))[4-6]","2(?:[23]02|6(?:[25]|4(?:64|[78]))|9(?:[02356]|4(?:[0268]|5[2-6])|72|8[23]))|3(?:3[28]|4(?:[04679]|3(?:5(?:4[0-25689]|[56])|[78])|58|8[2379])|5(?:[2467]|3[237]|8(?:[23]|4(?:[45]|60)|5(?:4[0-39]|5|64)))|7[1-578]|8(?:[2469]|3[278]|54(?:4|5[13-7]|6[89])|86[3-6]))|2(?:2[24-9]|3[1-59]|47)|38(?:[58][78]|7[378])|3(?:454|85[56])[46]|3(?:4(?:36|5[56])|8(?:[38]5|76))[4-6]"],"0$1",1],["(\\d{2})(\\d{4})(\\d{4})","$1 $2-$3",["1"],"0$1",1],["(\\d{3})(\\d{3})(\\d{4})","$1-$2-$3",["[68]"],"0$1"],["(\\d{3})(\\d{3})(\\d{4})","$1 $2-$3",["[23]"],"0$1",1],["(\\d)(\\d{4})(\\d{2})(\\d{4})","$2 15-$3-$4",["9(?:2[2-469]|3[3-578])","9(?:2(?:2[024-9]|3[0-59]|47|6[245]|9[02-8])|3(?:3[28]|4[03-9]|5[2-46-8]|7[1-578]|8[2-9]))","9(?:2(?:[23]02|6(?:[25]|4[6-8])|9(?:[02356]|4[02568]|72|8[23]))|3(?:3[28]|4(?:[04679]|3[5-8]|5[4-68]|8[2379])|5(?:[2467]|3[237]|8[2-5])|7[1-578]|8(?:[2469]|3[2578]|5[4-8]|7[36-8]|8[5-8])))|92(?:2[24-9]|3[1-59]|47)","9(?:2(?:[23]02|6(?:[25]|4(?:64|[78]))|9(?:[02356]|4(?:[0268]|5[2-6])|72|8[23]))|3(?:3[28]|4(?:[04679]|3[78]|5(?:4[46]|8)|8[2379])|5(?:[2467]|3[237]|8[23])|7[1-578]|8(?:[2469]|3[278]|5(?:[56][46]|[78])|7[378]|8(?:6[3-6]|[78]))))|92(?:2[24-9]|3[1-59]|47)|93(?:4[35][56]|58[45]|8(?:[38]5|54|76))[4-6]","9(?:2(?:[23]02|6(?:[25]|4(?:64|[78]))|9(?:[02356]|4(?:[0268]|5[2-6])|72|8[23]))|3(?:3[28]|4(?:[04679]|3(?:5(?:4[0-25689]|[56])|[78])|5(?:4[46]|8)|8[2379])|5(?:[2467]|3[237]|8(?:[23]|4(?:[45]|60)|5(?:4[0-39]|5|64)))|7[1-578]|8(?:[2469]|3[278]|5(?:4(?:4|5[13-7]|6[89])|[56][46]|[78])|7[378]|8(?:6[3-6]|[78]))))|92(?:2[24-9]|3[1-59]|47)|93(?:4(?:36|5[56])|8(?:[38]5|76))[4-6]"],"0$1",0,"$1 $2 $3-$4"],["(\\d)(\\d{2})(\\d{4})(\\d{4})","$2 15-$3-$4",["91"],"0$1",0,"$1 $2 $3-$4"],["(\\d{3})(\\d{3})(\\d{5})","$1-$2-$3",["8"],"0$1"],["(\\d)(\\d{3})(\\d{3})(\\d{4})","$2 15-$3-$4",["9"],"0$1",0,"$1 $2 $3-$4"]],"0",0,"0?(?:(11|2(?:2(?:02?|[13]|2[13-79]|4[1-6]|5[2457]|6[124-8]|7[1-4]|8[13-6]|9[1267])|3(?:02?|1[467]|2[03-6]|3[13-8]|[49][2-6]|5[2-8]|[67])|4(?:7[3-578]|9)|6(?:[0136]|2[24-6]|4[6-8]?|5[15-8])|80|9(?:0[1-3]|[19]|2\\d|3[1-6]|4[02568]?|5[2-4]|6[2-46]|72?|8[23]?))|3(?:3(?:2[79]|6|8[2578])|4(?:0[0-24-9]|[12]|3[5-8]?|4[24-7]|5[4-68]?|6[02-9]|7[126]|8[2379]?|9[1-36-8])|5(?:1|2[1245]|3[237]?|4[1-46-9]|6[2-4]|7[1-6]|8[2-5]?)|6[24]|7(?:[069]|1[1568]|2[15]|3[145]|4[13]|5[14-8]|7[2-57]|8[126])|8(?:[01]|2[15-7]|3[2578]?|4[13-6]|5[4-8]?|6[1-357-9]|7[36-8]?|8[5-8]?|9[124])))15)?","9$1"],"AS":["1","011","(?:[58]\\d\\d|684|900)\\d{7}",[10],0,"1",0,"([267]\\d{6})$|1","684$1",0,"684"],"AT":["43","00","1\\d{3,12}|2\\d{6,12}|43(?:(?:0\\d|5[02-9])\\d{3,9}|2\\d{4,5}|[3467]\\d{4}|8\\d{4,6}|9\\d{4,7})|5\\d{4,12}|8\\d{7,12}|9\\d{8,12}|(?:[367]\\d|4[0-24-9])\\d{4,11}",[4,5,6,7,8,9,10,11,12,13],[["(\\d)(\\d{3,12})","$1 $2",["1(?:11|[2-9])"],"0$1"],["(\\d{3})(\\d{2})","$1 $2",["517"],"0$1"],["(\\d{2})(\\d{3,5})","$1 $2",["5[079]"],"0$1"],["(\\d{3})(\\d{3,10})","$1 $2",["(?:31|4)6|51|6(?:48|5[0-3579]|[6-9])|7(?:20|32|8)|[89]","(?:31|4)6|51|6(?:485|5[0-3579]|[6-9])|7(?:20|32|8)|[89]"],"0$1"],["(\\d{4})(\\d{3,9})","$1 $2",["[2-467]|5[2-6]"],"0$1"],["(\\d{2})(\\d{3})(\\d{3,4})","$1 $2 $3",["5"],"0$1"],["(\\d{2})(\\d{4})(\\d{4,7})","$1 $2 $3",["5"],"0$1"]],"0"],"AU":["61","001[14-689]|14(?:1[14]|34|4[17]|[56]6|7[47]|88)0011","1(?:[0-79]\\d{7}(?:\\d(?:\\d{2})?)?|8[0-24-9]\\d{7})|[2-478]\\d{8}|1\\d{4,7}",[5,6,7,8,9,10,12],[["(\\d{2})(\\d{3,4})","$1 $2",["16"],"0$1"],["(\\d{2})(\\d{3})(\\d{2,4})","$1 $2 $3",["16"],"0$1"],["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["14|4"],"0$1"],["(\\d)(\\d{4})(\\d{4})","$1 $2 $3",["[2378]"],"(0$1)"],["(\\d{4})(\\d{3})(\\d{3})","$1 $2 $3",["1(?:30|[89])"]]],"0",0,"(183[12])|0",0,0,0,[["(?:(?:2(?:(?:[0-26-9]\\d|3[0-8]|5[0135-9])\\d|4(?:[02-9]\\d|10))|3(?:(?:[0-3589]\\d|6[1-9]|7[0-35-9])\\d|4(?:[0-578]\\d|90))|7(?:[013-57-9]\\d|2[0-8])\\d)\\d\\d|8(?:51(?:0(?:0[03-9]|[12479]\\d|3[2-9]|5[0-8]|6[1-9]|8[0-7])|1(?:[0235689]\\d|1[0-69]|4[0-589]|7[0-47-9])|2(?:0[0-79]|[18][13579]|2[14-9]|3[0-46-9]|[4-6]\\d|7[89]|9[0-4])|[34]\\d\\d)|(?:6[0-8]|[78]\\d)\\d{3}|9(?:[02-9]\\d{3}|1(?:(?:[0-58]\\d|6[0135-9])\\d|7(?:0[0-24-9]|[1-9]\\d)|9(?:[0-46-9]\\d|5[0-79])))))\\d{3}",[9]],["4(?:79[01]|83[0-389]|94[0-478])\\d{5}|4(?:[0-36]\\d|4[047-9]|[58][0-24-9]|7[02-8]|9[0-37-9])\\d{6}",[9]],["180(?:0\\d{3}|2)\\d{3}",[7,10]],["190[0-26]\\d{6}",[10]],0,0,0,["163\\d{2,6}",[5,6,7,8,9]],["14(?:5(?:1[0458]|[23][458])|71\\d)\\d{4}",[9]],["13(?:00\\d{6}(?:\\d{2})?|45[0-4]\\d{3})|13\\d{4}",[6,8,10,12]]],"0011"],"AW":["297","00","(?:[25-79]\\d\\d|800)\\d{4}",[7],[["(\\d{3})(\\d{4})","$1 $2",["[25-9]"]]]],"AX":["358","00|99(?:[01469]|5(?:[14]1|3[23]|5[59]|77|88|9[09]))","2\\d{4,9}|35\\d{4,5}|(?:60\\d\\d|800)\\d{4,6}|7\\d{5,11}|(?:[14]\\d|3[0-46-9]|50)\\d{4,8}",[5,6,7,8,9,10,11,12],0,"0",0,0,0,0,"18",0,"00"],"AZ":["994","00","365\\d{6}|(?:[124579]\\d|60|88)\\d{7}",[9],[["(\\d{3})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["90"],"0$1"],["(\\d{2})(\\d{3})(\\d{2})(\\d{2})","$1 $2 $3 $4",["1[28]|2|365|46","1[28]|2|365[45]|46","1[28]|2|365(?:4|5[02])|46"],"(0$1)"],["(\\d{2})(\\d{3})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[13-9]"],"0$1"]],"0"],"BA":["387","00","6\\d{8}|(?:[35689]\\d|49|70)\\d{6}",[8,9],[["(\\d{2})(\\d{3})(\\d{3})","$1 $2 $3",["6[1-3]|[7-9]"],"0$1"],["(\\d{2})(\\d{3})(\\d{3})","$1 $2-$3",["[3-5]|6[56]"],"0$1"],["(\\d{2})(\\d{2})(\\d{2})(\\d{3})","$1 $2 $3 $4",["6"],"0$1"]],"0"],"BB":["1","011","(?:246|[58]\\d\\d|900)\\d{7}",[10],0,"1",0,"([2-9]\\d{6})$|1","246$1",0,"246"],"BD":["880","00","[1-469]\\d{9}|8[0-79]\\d{7,8}|[2-79]\\d{8}|[2-9]\\d{7}|[3-9]\\d{6}|[57-9]\\d{5}",[6,7,8,9,10],[["(\\d{2})(\\d{4,6})","$1-$2",["31[5-8]|[459]1"],"0$1"],["(\\d{3})(\\d{3,7})","$1-$2",["3(?:[67]|8[013-9])|4(?:6[168]|7|[89][18])|5(?:6[128]|9)|6(?:[15]|28|4[14])|7[2-589]|8(?:0[014-9]|[12])|9[358]|(?:3[2-5]|4[235]|5[2-578]|6[0389]|76|8[3-7]|9[24])1|(?:44|66)[01346-9]"],"0$1"],["(\\d{4})(\\d{3,6})","$1-$2",["[13-9]|2[23]"],"0$1"],["(\\d)(\\d{7,8})","$1-$2",["2"],"0$1"]],"0"],"BE":["32","00","4\\d{8}|[1-9]\\d{7}",[8,9],[["(\\d{3})(\\d{2})(\\d{3})","$1 $2 $3",["(?:80|9)0"],"0$1"],["(\\d)(\\d{3})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[239]|4[23]"],"0$1"],["(\\d{2})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[15-8]"],"0$1"],["(\\d{3})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["4"],"0$1"]],"0"],"BF":["226","00","(?:[025-7]\\d|44)\\d{6}",[8],[["(\\d{2})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[024-7]"]]]],"BG":["359","00","00800\\d{7}|[2-7]\\d{6,7}|[89]\\d{6,8}|2\\d{5}",[6,7,8,9,12],[["(\\d)(\\d)(\\d{2})(\\d{2})","$1 $2 $3 $4",["2"],"0$1"],["(\\d{3})(\\d{4})","$1 $2",["43[1-6]|70[1-9]"],"0$1"],["(\\d)(\\d{3})(\\d{3,4})","$1 $2 $3",["2"],"0$1"],["(\\d{2})(\\d{3})(\\d{2,3})","$1 $2 $3",["[356]|4[124-7]|7[1-9]|8[1-6]|9[1-7]"],"0$1"],["(\\d{3})(\\d{2})(\\d{3})","$1 $2 $3",["(?:70|8)0"],"0$1"],["(\\d{3})(\\d{3})(\\d{2})","$1 $2 $3",["43[1-7]|7"],"0$1"],["(\\d{2})(\\d{3})(\\d{3,4})","$1 $2 $3",["[48]|9[08]"],"0$1"],["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["9"],"0$1"]],"0"],"BH":["973","00","[136-9]\\d{7}",[8],[["(\\d{4})(\\d{4})","$1 $2",["[13679]|8[02-4679]"]]]],"BI":["257","00","(?:[267]\\d|31)\\d{6}",[8],[["(\\d{2})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[2367]"]]]],"BJ":["229","00","(?:01\\d|[24-689])\\d{7}",[8,10],[["(\\d{2})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[24-689]"]],["(\\d{2})(\\d{2})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4 $5",["0"]]]],"BL":["590","00","(?:590\\d|7090)\\d{5}|(?:69|80|9\\d)\\d{7}",[9],0,"0",0,0,0,0,0,[["590(?:2[7-9]|3[3-7]|5[12]|87)\\d{4}"],["(?:69(?:0\\d\\d|1(?:2[2-9]|3[0-5])|4(?:0[89]|1[2-6]|9\\d)|6(?:1[016-9]|5[0-4]|[67]\\d))|7090[0-4])\\d{4}"],["80[0-5]\\d{6}"],0,0,0,0,0,["9(?:(?:39[5-7]|76[018])\\d|475[0-6])\\d{4}"]]],"BM":["1","011","(?:441|[58]\\d\\d|900)\\d{7}",[10],0,"1",0,"([2-9]\\d{6})$|1","441$1",0,"441"],"BN":["673","00","[2-578]\\d{6}",[7],[["(\\d{3})(\\d{4})","$1 $2",["[2-578]"]]]],"BO":["591","00(?:1\\d)?","8001\\d{5}|(?:[2-467]\\d|50)\\d{6}",[8,9],[["(\\d)(\\d{7})","$1 $2",["[235]|4[46]"]],["(\\d{8})","$1",["[67]"]],["(\\d{3})(\\d{2})(\\d{4})","$1 $2 $3",["8"]]],"0",0,"0(1\\d)?"],"BQ":["599","00","(?:[34]1|7\\d)\\d{5}",[7],0,0,0,0,0,0,"[347]"],"BR":["55","00(?:1[245]|2[1-35]|31|4[13]|[56]5|99)","[1-467]\\d{9,10}|55[0-46-9]\\d{8}|[34]\\d{7}|55\\d{7,8}|(?:5[0-46-9]|[89]\\d)\\d{7,9}",[8,9,10,11],[["(\\d{4})(\\d{4})","$1-$2",["300|4(?:0[02]|37|86)","300|4(?:0(?:0|20)|370|864)"]],["(\\d{3})(\\d{2,3})(\\d{4})","$1 $2 $3",["(?:[358]|90)0"],"0$1"],["(\\d{2})(\\d{4})(\\d{4})","$1 $2-$3",["(?:[14689][1-9]|2[12478]|3[1-578]|5[13-5]|7[13-579])[2-57]"],"($1)"],["(\\d{2})(\\d{5})(\\d{4})","$1 $2-$3",["[16][1-9]|[2-57-9]"],"($1)"]],"0",0,"(?:0|90)(?:(1[245]|2[1-35]|31|4[13]|[56]5|99)(\\d{10,11}))?","$2"],"BS":["1","011","(?:242|[58]\\d\\d|900)\\d{7}",[10],0,"1",0,"([3-8]\\d{6})$|1","242$1",0,"242"],"BT":["975","00","[178]\\d{7}|[2-8]\\d{6}",[7,8],[["(\\d)(\\d{3})(\\d{3})","$1 $2 $3",["[2-6]|7[246]|8[2-4]"]],["(\\d{2})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["1[67]|[78]"]]]],"BW":["267","00","(?:0800|(?:[37]|800)\\d)\\d{6}|(?:[2-6]\\d|90)\\d{5}",[7,8,10],[["(\\d{2})(\\d{5})","$1 $2",["90"]],["(\\d{3})(\\d{4})","$1 $2",["[24-6]|3[15-9]"]],["(\\d{2})(\\d{3})(\\d{3})","$1 $2 $3",["[37]"]],["(\\d{4})(\\d{3})(\\d{3})","$1 $2 $3",["0"]],["(\\d{3})(\\d{4})(\\d{3})","$1 $2 $3",["8"]]]],"BY":["375","810","(?:[12]\\d|33|44|902)\\d{7}|8(?:0[0-79]\\d{5,7}|[1-7]\\d{9})|8(?:1[0-489]|[5-79]\\d)\\d{7}|8[1-79]\\d{6,7}|8[0-79]\\d{5}|8\\d{5}",[6,7,8,9,10,11],[["(\\d{3})(\\d{3})","$1 $2",["800"],"8 $1"],["(\\d{3})(\\d{2})(\\d{2,4})","$1 $2 $3",["800"],"8 $1"],["(\\d{4})(\\d{2})(\\d{3})","$1 $2-$3",["1(?:5[169]|6[3-5]|7[179])|2(?:1[35]|2[34]|3[3-5])","1(?:5[169]|6(?:3[1-3]|4|5[125])|7(?:1[3-9]|7[0-24-6]|9[2-7]))|2(?:1[35]|2[34]|3[3-5])"],"8 0$1"],["(\\d{3})(\\d{2})(\\d{2})(\\d{2})","$1 $2-$3-$4",["1(?:[56]|7[467])|2[1-3]"],"8 0$1"],["(\\d{2})(\\d{3})(\\d{2})(\\d{2})","$1 $2-$3-$4",["[1-4]"],"8 0$1"],["(\\d{3})(\\d{3,4})(\\d{4})","$1 $2 $3",["[89]"],"8 $1"]],"8",0,"0|80?",0,0,0,0,"8~10"],"BZ":["501","00","(?:0800\\d|[2-8])\\d{6}",[7,11],[["(\\d{3})(\\d{4})","$1-$2",["[2-8]"]],["(\\d)(\\d{3})(\\d{4})(\\d{3})","$1-$2-$3-$4",["0"]]]],"CA":["1","011","[2-9]\\d{9}|3\\d{6}",[7,10],0,"1",0,0,0,0,0,[["(?:2(?:04|[23]6|[48]9|5[07]|63)|3(?:06|43|54|6[578]|82)|4(?:03|1[68]|[26]8|3[178]|50|74)|5(?:06|1[49]|48|79|8[147])|6(?:04|[18]3|39|47|72)|7(?:0[59]|42|53|78|8[02])|8(?:[06]7|19|25|7[39])|9(?:0[25]|42))[2-9]\\d{6}",[10]],["",[10]],["8(?:00|33|44|55|66|77|88)[2-9]\\d{6}",[10]],["900[2-9]\\d{6}",[10]],["52(?:3(?:[2-46-9][02-9]\\d|5(?:[02-46-9]\\d|5[0-46-9]))|4(?:[2-478][02-9]\\d|5(?:[034]\\d|2[024-9]|5[0-46-9])|6(?:0[1-9]|[2-9]\\d)|9(?:[05-9]\\d|2[0-5]|49)))\\d{4}|52[34][2-9]1[02-9]\\d{4}|(?:5(?:2[125-9]|33|44|66|77|88)|6(?:22|33))[2-9]\\d{6}",[10]],0,["310\\d{4}",[7]],0,["600[2-9]\\d{6}",[10]]]],"CC":["61","001[14-689]|14(?:1[14]|34|4[17]|[56]6|7[47]|88)0011","1(?:[0-79]\\d{8}(?:\\d{2})?|8[0-24-9]\\d{7})|[148]\\d{8}|1\\d{5,7}",[6,7,8,9,10,12],0,"0",0,"([59]\\d{7})$|0","8$1",0,0,[["8(?:51(?:0(?:02|31|60|89)|1(?:18|76)|223)|91(?:0(?:1[0-2]|29)|1(?:[28]2|50|79)|2(?:10|64)|3(?:[06]8|22)|4[29]8|62\\d|70[23]|959))\\d{3}",[9]],["4(?:79[01]|83[0-389]|94[0-478])\\d{5}|4(?:[0-36]\\d|4[047-9]|[58][0-24-9]|7[02-8]|9[0-37-9])\\d{6}",[9]],["180(?:0\\d{3}|2)\\d{3}",[7,10]],["190[0-26]\\d{6}",[10]],0,0,0,0,["14(?:5(?:1[0458]|[23][458])|71\\d)\\d{4}",[9]],["13(?:00\\d{6}(?:\\d{2})?|45[0-4]\\d{3})|13\\d{4}",[6,8,10,12]]],"0011"],"CD":["243","00","(?:(?:[189]|5\\d)\\d|2)\\d{7}|[1-68]\\d{6}",[7,8,9,10],[["(\\d{2})(\\d{2})(\\d{3})","$1 $2 $3",["88"],"0$1"],["(\\d{2})(\\d{5})","$1 $2",["[1-6]"],"0$1"],["(\\d{2})(\\d{2})(\\d{4})","$1 $2 $3",["2"],"0$1"],["(\\d{2})(\\d{3})(\\d{4})","$1 $2 $3",["1"],"0$1"],["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["[89]"],"0$1"],["(\\d{2})(\\d{2})(\\d{3})(\\d{3})","$1 $2 $3 $4",["5"],"0$1"]],"0"],"CF":["236","00","(?:[27]\\d{3}|8776)\\d{4}",[8],[["(\\d{2})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[278]"]]]],"CG":["242","00","222\\d{6}|(?:0\\d|80)\\d{7}",[9],[["(\\d)(\\d{4})(\\d{4})","$1 $2 $3",["8"]],["(\\d{2})(\\d{3})(\\d{4})","$1 $2 $3",["[02]"]]]],"CH":["41","00","8\\d{11}|[2-9]\\d{8}",[9,12],[["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["8[047]|90"],"0$1"],["(\\d{2})(\\d{3})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[2-79]|81"],"0$1"],["(\\d{3})(\\d{2})(\\d{3})(\\d{2})(\\d{2})","$1 $2 $3 $4 $5",["8"],"0$1"]],"0"],"CI":["225","00","[02]\\d{9}",[10],[["(\\d{2})(\\d{2})(\\d)(\\d{5})","$1 $2 $3 $4",["2"]],["(\\d{2})(\\d{2})(\\d{2})(\\d{4})","$1 $2 $3 $4",["0"]]]],"CK":["682","00","[2-578]\\d{4}",[5],[["(\\d{2})(\\d{3})","$1 $2",["[2-578]"]]]],"CL":["56","(?:0|1(?:1[0-69]|2[02-5]|5[13-58]|69|7[0167]|8[018]))0","12300\\d{6}|6\\d{9,10}|[2-9]\\d{8}",[9,10,11],[["(\\d{5})(\\d{4})","$1 $2",["219","2196"],"($1)"],["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["60|809"]],["(\\d{2})(\\d{3})(\\d{4})","$1 $2 $3",["44"]],["(\\d)(\\d{4})(\\d{4})","$1 $2 $3",["2[1-36]"],"($1)"],["(\\d)(\\d{4})(\\d{4})","$1 $2 $3",["9(?:10|[2-9])"]],["(\\d{2})(\\d{3})(\\d{4})","$1 $2 $3",["3[2-5]|[47]|5[1-3578]|6[13-57]|8(?:0[1-8]|[1-9])"],"($1)"],["(\\d{3})(\\d{3})(\\d{3,4})","$1 $2 $3",["60|8"]],["(\\d{4})(\\d{3})(\\d{4})","$1 $2 $3",["1"]],["(\\d{3})(\\d{3})(\\d{2})(\\d{3})","$1 $2 $3 $4",["60"]]]],"CM":["237","00","[26]\\d{8}|88\\d{6,7}",[8,9],[["(\\d{2})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["88"]],["(\\d)(\\d{2})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4 $5",["[26]|88"]]]],"CN":["86","00|1(?:[12]\\d|79)\\d\\d00","(?:(?:1[03-689]|2\\d)\\d\\d|6)\\d{8}|1\\d{10}|[126]\\d{6}(?:\\d(?:\\d{2})?)?|86\\d{5,6}|(?:[3-579]\\d|8[0-57-9])\\d{5,9}",[7,8,9,10,11,12],[["(\\d{2})(\\d{5,6})","$1 $2",["(?:10|2[0-57-9])[19]|3(?:[157]|35|49|9[1-68])|4(?:1[124-9]|2[179]|6[47-9]|7|8[23])|5(?:[1357]|2[37]|4[36]|6[1-46]|80)|6(?:3[1-5]|6[0238]|9[12])|7(?:01|[1579]|2[248]|3[014-9]|4[3-6]|6[023689])|8(?:07|1[236-8]|2[5-7]|[37]|8[36-8]|9[1-8])|9(?:0[1-3689]|1[1-79]|3|4[13]|5[1-5]|7[0-79]|9[0-35-9])|(?:4[35]|59|85)[1-9]","(?:10|2[0-57-9])(?:1[02]|9[56])|8078|(?:3(?:[157]\\d|35|49|9[1-68])|4(?:1[124-9]|2[179]|[35][1-9]|6[47-9]|7\\d|8[23])|5(?:[1357]\\d|2[37]|4[36]|6[1-46]|80|9[1-9])|6(?:3[1-5]|6[0238]|9[12])|7(?:01|[1579]\\d|2[248]|3[014-9]|4[3-6]|6[023689])|8(?:1[236-8]|2[5-7]|[37]\\d|5[1-9]|8[36-8]|9[1-8])|9(?:0[1-3689]|1[1-79]|3\\d|4[13]|5[1-5]|7[0-79]|9[0-35-9]))1","10(?:1(?:0|23)|9[56])|2[0-57-9](?:1(?:00|23)|9[56])|80781|(?:3(?:[157]\\d|35|49|9[1-68])|4(?:1[124-9]|2[179]|[35][1-9]|6[47-9]|7\\d|8[23])|5(?:[1357]\\d|2[37]|4[36]|6[1-46]|80|9[1-9])|6(?:3[1-5]|6[0238]|9[12])|7(?:01|[1579]\\d|2[248]|3[014-9]|4[3-6]|6[023689])|8(?:1[236-8]|2[5-7]|[37]\\d|5[1-9]|8[36-8]|9[1-8])|9(?:0[1-3689]|1[1-79]|3\\d|4[13]|5[1-5]|7[0-79]|9[0-35-9]))12","10(?:1(?:0|23)|9[56])|2[0-57-9](?:1(?:00|23)|9[56])|807812|(?:3(?:[157]\\d|35|49|9[1-68])|4(?:1[124-9]|2[179]|[35][1-9]|6[47-9]|7\\d|8[23])|5(?:[1357]\\d|2[37]|4[36]|6[1-46]|80|9[1-9])|6(?:3[1-5]|6[0238]|9[12])|7(?:01|[1579]\\d|2[248]|3[014-9]|4[3-6]|6[023689])|8(?:1[236-8]|2[5-7]|[37]\\d|5[1-9]|8[36-8]|9[1-8])|9(?:0[1-3689]|1[1-79]|3\\d|4[13]|5[1-5]|7[0-79]|9[0-35-9]))123","10(?:1(?:0|23)|9[56])|2[0-57-9](?:1(?:00|23)|9[56])|(?:3(?:[157]\\d|35|49|9[1-68])|4(?:1[124-9]|2[179]|[35][1-9]|6[47-9]|7\\d|8[23])|5(?:[1357]\\d|2[37]|4[36]|6[1-46]|80|9[1-9])|6(?:3[1-5]|6[0238]|9[12])|7(?:01|[1579]\\d|2[248]|3[014-9]|4[3-6]|6[023689])|8(?:078|1[236-8]|2[5-7]|[37]\\d|5[1-9]|8[36-8]|9[1-8])|9(?:0[1-3689]|1[1-79]|3\\d|4[13]|5[1-5]|7[0-79]|9[0-35-9]))123"],"0$1"],["(\\d{3})(\\d{5,6})","$1 $2",["3(?:[157]|35|49|9[1-68])|4(?:[17]|2[179]|6[47-9]|8[23])|5(?:[1357]|2[37]|4[36]|6[1-46]|80)|6(?:3[1-5]|6[0238]|9[12])|7(?:01|[1579]|2[248]|3[014-9]|4[3-6]|6[023689])|8(?:1[236-8]|2[5-7]|[37]|8[36-8]|9[1-8])|9(?:0[1-3689]|1[1-79]|[379]|4[13]|5[1-5])|(?:4[35]|59|85)[1-9]","(?:3(?:[157]\\d|35|49|9[1-68])|4(?:[17]\\d|2[179]|[35][1-9]|6[47-9]|8[23])|5(?:[1357]\\d|2[37]|4[36]|6[1-46]|80|9[1-9])|6(?:3[1-5]|6[0238]|9[12])|7(?:01|[1579]\\d|2[248]|3[014-9]|4[3-6]|6[023689])|8(?:1[236-8]|2[5-7]|[37]\\d|5[1-9]|8[36-8]|9[1-8])|9(?:0[1-3689]|1[1-79]|[379]\\d|4[13]|5[1-5]))[19]","85[23](?:10|95)|(?:3(?:[157]\\d|35|49|9[1-68])|4(?:[17]\\d|2[179]|[35][1-9]|6[47-9]|8[23])|5(?:[1357]\\d|2[37]|4[36]|6[1-46]|80|9[1-9])|6(?:3[1-5]|6[0238]|9[12])|7(?:01|[1579]\\d|2[248]|3[014-9]|4[3-6]|6[023689])|8(?:1[236-8]|2[5-7]|[37]\\d|5[14-9]|8[36-8]|9[1-8])|9(?:0[1-3689]|1[1-79]|[379]\\d|4[13]|5[1-5]))(?:10|9[56])","85[23](?:100|95)|(?:3(?:[157]\\d|35|49|9[1-68])|4(?:[17]\\d|2[179]|[35][1-9]|6[47-9]|8[23])|5(?:[1357]\\d|2[37]|4[36]|6[1-46]|80|9[1-9])|6(?:3[1-5]|6[0238]|9[12])|7(?:01|[1579]\\d|2[248]|3[014-9]|4[3-6]|6[023689])|8(?:1[236-8]|2[5-7]|[37]\\d|5[14-9]|8[36-8]|9[1-8])|9(?:0[1-3689]|1[1-79]|[379]\\d|4[13]|5[1-5]))(?:100|9[56])"],"0$1"],["(\\d{3})(\\d{3})(\\d{4})","$1 $2 $3",["(?:4|80)0"]],["(\\d{2})(\\d{4})(\\d{4})","$1 $2 $3",["10|2(?:[02-57-9]|1[1-9])","10|2(?:[02-57-9]|1[1-9])","10[0-79]|2(?:[02-57-9]|1[1-79])|(?:10|21)8(?:0[1-9]|[1-9])"],"0$1",1],["(\\d{3})(\\d{3})(\\d{4})","$1 $2 $3",["3(?:[3-59]|7[02-68])|4(?:[26-8]|3[3-9]|5[2-9])|5(?:3[03-9]|[468]|7[028]|9[2-46-9])|6|7(?:[0-247]|3[04-9]|5[0-4689]|6[2368])|8(?:[1-358]|9[1-7])|9(?:[013479]|5[1-5])|(?:[34]1|55|79|87)[02-9]"],"0$1",1],["(\\d{3})(\\d{7,8})","$1 $2",["9"]],["(\\d{4})(\\d{3})(\\d{4})","$1 $2 $3",["80"],"0$1",1],["(\\d{3})(\\d{4})(\\d{4})","$1 $2 $3",["[3-578]"],"0$1",1],["(\\d{3})(\\d{4})(\\d{4})","$1 $2 $3",["1[3-9]"]],["(\\d{2})(\\d{3})(\\d{3})(\\d{4})","$1 $2 $3 $4",["[12]"],"0$1",1]],"0",0,"(1(?:[12]\\d|79)\\d\\d)|0",0,0,0,0,"00"],"CO":["57","00(?:4(?:[14]4|56)|[579])","(?:46|60\\d\\d)\\d{6}|(?:1\\d|[39])\\d{9}",[8,10,11],[["(\\d{4})(\\d{4})","$1 $2",["46"]],["(\\d{3})(\\d{7})","$1 $2",["6|90"],"($1)"],["(\\d{3})(\\d{7})","$1 $2",["3[0-357]|9[14]"]],["(\\d)(\\d{3})(\\d{7})","$1-$2-$3",["1"],"0$1",0,"$1 $2 $3"]],"0",0,"0([3579]|4(?:[14]4|56))?"],"CR":["506","00","(?:8\\d|90)\\d{8}|(?:[24-8]\\d{3}|3005)\\d{4}",[8,10],[["(\\d{4})(\\d{4})","$1 $2",["[2-7]|8[3-9]"]],["(\\d{3})(\\d{3})(\\d{4})","$1-$2-$3",["[89]"]]],0,0,"(19(?:0[0-2468]|1[09]|20|66|77|99))"],"CU":["53","119","(?:[2-7]|8\\d\\d)\\d{7}|[2-47]\\d{6}|[34]\\d{5}",[6,7,8,10],[["(\\d{2})(\\d{4,6})","$1 $2",["2[1-4]|[34]"],"(0$1)"],["(\\d)(\\d{6,7})","$1 $2",["7"],"(0$1)"],["(\\d)(\\d{7})","$1 $2",["[56]"],"0$1"],["(\\d{3})(\\d{7})","$1 $2",["8"],"0$1"]],"0"],"CV":["238","0","(?:[2-59]\\d\\d|800)\\d{4}",[7],[["(\\d{3})(\\d{2})(\\d{2})","$1 $2 $3",["[2-589]"]]]],"CW":["599","00","(?:[34]1|60|(?:7|9\\d)\\d)\\d{5}",[7,8],[["(\\d{3})(\\d{4})","$1 $2",["[3467]"]],["(\\d)(\\d{3})(\\d{4})","$1 $2 $3",["9[4-8]"]]],0,0,0,0,0,"[69]"],"CX":["61","001[14-689]|14(?:1[14]|34|4[17]|[56]6|7[47]|88)0011","1(?:[0-79]\\d{8}(?:\\d{2})?|8[0-24-9]\\d{7})|[148]\\d{8}|1\\d{5,7}",[6,7,8,9,10,12],0,"0",0,"([59]\\d{7})$|0","8$1",0,0,[["8(?:51(?:0(?:01|30|59|88)|1(?:17|46|75)|2(?:22|35))|91(?:00[6-9]|1(?:[28]1|49|78)|2(?:09|63)|3(?:12|26|75)|4(?:56|97)|64\\d|7(?:0[01]|1[0-2])|958))\\d{3}",[9]],["4(?:79[01]|83[0-389]|94[0-478])\\d{5}|4(?:[0-36]\\d|4[047-9]|[58][0-24-9]|7[02-8]|9[0-37-9])\\d{6}",[9]],["180(?:0\\d{3}|2)\\d{3}",[7,10]],["190[0-26]\\d{6}",[10]],0,0,0,0,["14(?:5(?:1[0458]|[23][458])|71\\d)\\d{4}",[9]],["13(?:00\\d{6}(?:\\d{2})?|45[0-4]\\d{3})|13\\d{4}",[6,8,10,12]]],"0011"],"CY":["357","00","(?:[279]\\d|[58]0)\\d{6}",[8],[["(\\d{2})(\\d{6})","$1 $2",["[257-9]"]]]],"CZ":["420","00","(?:[2-578]\\d|60)\\d{7}|9\\d{8,11}",[9,10,11,12],[["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["[2-8]|9[015-7]"]],["(\\d{2})(\\d{3})(\\d{3})(\\d{2})","$1 $2 $3 $4",["96"]],["(\\d{2})(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3 $4",["9"]],["(\\d{3})(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3 $4",["9"]]]],"DE":["49","00","[2579]\\d{5,14}|49(?:[34]0|69|8\\d)\\d\\d?|49(?:37|49|60|7[089]|9\\d)\\d{1,3}|49(?:2[024-9]|3[2-689]|7[1-7])\\d{1,8}|(?:1|[368]\\d|4[0-8])\\d{3,13}|49(?:[015]\\d|2[13]|31|[46][1-8])\\d{1,9}",[4,5,6,7,8,9,10,11,12,13,14,15],[["(\\d{2})(\\d{3,13})","$1 $2",["3[02]|40|[68]9"],"0$1"],["(\\d{3})(\\d{3,12})","$1 $2",["2(?:0[1-389]|1[124]|2[18]|3[14])|3(?:[35-9][15]|4[015])|906|(?:2[4-9]|4[2-9]|[579][1-9]|[68][1-8])1","2(?:0[1-389]|12[0-8])|3(?:[35-9][15]|4[015])|906|2(?:[13][14]|2[18])|(?:2[4-9]|4[2-9]|[579][1-9]|[68][1-8])1"],"0$1"],["(\\d{4})(\\d{2,11})","$1 $2",["[24-6]|3(?:[3569][02-46-9]|4[2-4679]|7[2-467]|8[2-46-8])|70[2-8]|8(?:0[2-9]|[1-8])|90[7-9]|[79][1-9]","[24-6]|3(?:3(?:0[1-467]|2[127-9]|3[124578]|7[1257-9]|8[1256]|9[145])|4(?:2[135]|4[13578]|9[1346])|5(?:0[14]|2[1-3589]|6[1-4]|7[13468]|8[13568])|6(?:2[1-489]|3[124-6]|6[13]|7[12579]|8[1-356]|9[135])|7(?:2[1-7]|4[145]|6[1-5]|7[1-4])|8(?:21|3[1468]|6|7[1467]|8[136])|9(?:0[12479]|2[1358]|4[134679]|6[1-9]|7[136]|8[147]|9[1468]))|70[2-8]|8(?:0[2-9]|[1-8])|90[7-9]|[79][1-9]|3[68]4[1347]|3(?:47|60)[1356]|3(?:3[46]|46|5[49])[1246]|3[4579]3[1357]"],"0$1"],["(\\d{3})(\\d{4})","$1 $2",["138"],"0$1"],["(\\d{5})(\\d{2,10})","$1 $2",["3"],"0$1"],["(\\d{3})(\\d{5,11})","$1 $2",["181"],"0$1"],["(\\d{3})(\\d)(\\d{4,10})","$1 $2 $3",["1(?:3|80)|9"],"0$1"],["(\\d{3})(\\d{7,8})","$1 $2",["1[67]"],"0$1"],["(\\d{3})(\\d{7,12})","$1 $2",["8"],"0$1"],["(\\d{5})(\\d{6})","$1 $2",["185","1850","18500"],"0$1"],["(\\d{3})(\\d{4})(\\d{4})","$1 $2 $3",["7"],"0$1"],["(\\d{4})(\\d{7})","$1 $2",["18[68]"],"0$1"],["(\\d{4})(\\d{7})","$1 $2",["15[1279]"],"0$1"],["(\\d{5})(\\d{6})","$1 $2",["15[03568]","15(?:[0568]|3[13])"],"0$1"],["(\\d{3})(\\d{8})","$1 $2",["18"],"0$1"],["(\\d{3})(\\d{2})(\\d{7,8})","$1 $2 $3",["1(?:6[023]|7)"],"0$1"],["(\\d{4})(\\d{2})(\\d{7})","$1 $2 $3",["15[279]"],"0$1"],["(\\d{3})(\\d{2})(\\d{8})","$1 $2 $3",["15"],"0$1"]],"0"],"DJ":["253","00","(?:2\\d|77)\\d{6}",[8],[["(\\d{2})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[27]"]]]],"DK":["45","00","[2-9]\\d{7}",[8],[["(\\d{2})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[2-9]"]]]],"DM":["1","011","(?:[58]\\d\\d|767|900)\\d{7}",[10],0,"1",0,"([2-7]\\d{6})$|1","767$1",0,"767"],"DO":["1","011","(?:[58]\\d\\d|900)\\d{7}",[10],0,"1",0,0,0,0,"8001|8[024]9"],"DZ":["213","00","(?:[1-4]|[5-79]\\d|80)\\d{7}",[8,9],[["(\\d{2})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[1-4]"],"0$1"],["(\\d{2})(\\d{3})(\\d{2})(\\d{2})","$1 $2 $3 $4",["9"],"0$1"],["(\\d{3})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[5-8]"],"0$1"]],"0"],"EC":["593","00","1\\d{9,10}|(?:[2-7]|9\\d)\\d{7}",[8,9,10,11],[["(\\d)(\\d{3})(\\d{4})","$1 $2-$3",["[2-7]"],"(0$1)",0,"$1-$2-$3"],["(\\d{2})(\\d{3})(\\d{4})","$1 $2 $3",["9"],"0$1"],["(\\d{4})(\\d{3})(\\d{3,4})","$1 $2 $3",["1"]]],"0"],"EE":["372","00","8\\d{9}|[4578]\\d{7}|(?:[3-8]\\d|90)\\d{5}",[7,8,10],[["(\\d{3})(\\d{4})","$1 $2",["[369]|4[3-8]|5(?:[0-2]|5[0-478]|6[45])|7[1-9]|88","[369]|4[3-8]|5(?:[02]|1(?:[0-8]|95)|5[0-478]|6(?:4[0-4]|5[1-589]))|7[1-9]|88"]],["(\\d{4})(\\d{3,4})","$1 $2",["[45]|8(?:00|[1-49])","[45]|8(?:00[1-9]|[1-49])"]],["(\\d{2})(\\d{2})(\\d{4})","$1 $2 $3",["7"]],["(\\d{4})(\\d{3})(\\d{3})","$1 $2 $3",["8"]]]],"EG":["20","00","[189]\\d{8,9}|[24-6]\\d{8}|[135]\\d{7}",[8,9,10],[["(\\d)(\\d{7,8})","$1 $2",["[23]"],"0$1"],["(\\d{2})(\\d{6,7})","$1 $2",["1[35]|[4-6]|8[2468]|9[235-7]"],"0$1"],["(\\d{3})(\\d{3})(\\d{4})","$1 $2 $3",["[89]"],"0$1"],["(\\d{2})(\\d{8})","$1 $2",["1"],"0$1"]],"0"],"EH":["212","00","[5-8]\\d{8}",[9],0,"0",0,0,0,0,"528[89]"],"ER":["291","00","[178]\\d{6}",[7],[["(\\d)(\\d{3})(\\d{3})","$1 $2 $3",["[178]"],"0$1"]],"0"],"ES":["34","00","[5-9]\\d{8}",[9],[["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["[89]00"]],["(\\d{3})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[5-9]"]]]],"ET":["251","00","(?:11|[2-579]\\d)\\d{7}",[9],[["(\\d{2})(\\d{3})(\\d{4})","$1 $2 $3",["[1-579]"],"0$1"]],"0"],"FI":["358","00|99(?:[01469]|5(?:[14]1|3[23]|5[59]|77|88|9[09]))","[1-35689]\\d{4}|7\\d{10,11}|(?:[124-7]\\d|3[0-46-9])\\d{8}|[1-9]\\d{5,8}",[5,6,7,8,9,10,11,12],[["(\\d{5})","$1",["20[2-59]"],"0$1"],["(\\d{3})(\\d{3,7})","$1 $2",["(?:[1-3]0|[68])0|70[07-9]"],"0$1"],["(\\d{2})(\\d{4,8})","$1 $2",["[14]|2[09]|50|7[135]"],"0$1"],["(\\d{2})(\\d{6,10})","$1 $2",["7"],"0$1"],["(\\d)(\\d{4,9})","$1 $2",["(?:19|[2568])[1-8]|3(?:0[1-9]|[1-9])|9"],"0$1"]],"0",0,0,0,0,"1[03-79]|[2-9]",0,"00"],"FJ":["679","0(?:0|52)","45\\d{5}|(?:0800\\d|[235-9])\\d{6}",[7,11],[["(\\d{3})(\\d{4})","$1 $2",["[235-9]|45"]],["(\\d{4})(\\d{3})(\\d{4})","$1 $2 $3",["0"]]],0,0,0,0,0,0,0,"00"],"FK":["500","00","[2-7]\\d{4}",[5]],"FM":["691","00","(?:[39]\\d\\d|820)\\d{4}",[7],[["(\\d{3})(\\d{4})","$1 $2",["[389]"]]]],"FO":["298","00","[2-9]\\d{5}",[6],[["(\\d{6})","$1",["[2-9]"]]],0,0,"(10(?:01|[12]0|88))"],"FR":["33","00","[1-9]\\d{8}",[9],[["(\\d{3})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["8"],"0 $1"],["(\\d)(\\d{2})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4 $5",["[1-79]"],"0$1"]],"0"],"GA":["241","00","(?:[067]\\d|11)\\d{6}|[2-7]\\d{6}",[7,8],[["(\\d)(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[2-7]"],"0$1"],["(\\d{2})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["0"]],["(\\d{2})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["11|[67]"],"0$1"]],0,0,"0(11\\d{6}|60\\d{6}|61\\d{6}|6[256]\\d{6}|7[467]\\d{6})","$1"],"GB":["44","00","[1-357-9]\\d{9}|[18]\\d{8}|8\\d{6}",[7,9,10],[["(\\d{3})(\\d{4})","$1 $2",["800","8001","80011","800111","8001111"],"0$1"],["(\\d{3})(\\d{2})(\\d{2})","$1 $2 $3",["845","8454","84546","845464"],"0$1"],["(\\d{3})(\\d{6})","$1 $2",["800"],"0$1"],["(\\d{5})(\\d{4,5})","$1 $2",["1(?:38|5[23]|69|76|94)","1(?:(?:38|69)7|5(?:24|39)|768|946)","1(?:3873|5(?:242|39[4-6])|(?:697|768)[347]|9467)"],"0$1"],["(\\d{4})(\\d{5,6})","$1 $2",["1(?:[2-69][02-9]|[78])"],"0$1"],["(\\d{2})(\\d{4})(\\d{4})","$1 $2 $3",["[25]|7(?:0|6[02-9])","[25]|7(?:0|6(?:[03-9]|2[356]))"],"0$1"],["(\\d{4})(\\d{6})","$1 $2",["7"],"0$1"],["(\\d{3})(\\d{3})(\\d{4})","$1 $2 $3",["[1389]"],"0$1"]],"0",0,"0|180020",0,0,0,[["(?:1(?:1(?:3(?:[0-58]\\d\\d|73[0-35])|4(?:(?:[0-5]\\d|70)\\d|69[7-9])|(?:(?:5[0-26-9]|[78][0-49])\\d|6(?:[0-4]\\d|50))\\d)|(?:2(?:(?:0[024-9]|2[3-9]|3[3-79]|4[1-689]|[58][02-9]|6[0-47-9]|7[013-9]|9\\d)\\d|1(?:[0-7]\\d|8[0-3]))|(?:3(?:0\\d|1[0-8]|[25][02-9]|3[02-579]|[468][0-46-9]|7[1-35-79]|9[2-578])|4(?:0[03-9]|[137]\\d|[28][02-57-9]|4[02-69]|5[0-8]|[69][0-79])|5(?:0[1-35-9]|[16]\\d|2[024-9]|3[015689]|4[02-9]|5[03-9]|7[0-35-9]|8[0-468]|9[0-57-9])|6(?:0[034689]|1\\d|2[0-35689]|[38][013-9]|4[1-467]|5[0-69]|6[13-9]|7[0-8]|9[0-24578])|7(?:0[0246-9]|2\\d|3[0236-8]|4[03-9]|5[0-46-9]|6[013-9]|7[0-35-9]|8[024-9]|9[02-9])|8(?:0[35-9]|2[1-57-9]|3[02-578]|4[0-578]|5[124-9]|6[2-69]|7\\d|8[02-9]|9[02569])|9(?:0[02-589]|[18]\\d|2[02-689]|3[1-57-9]|4[2-9]|5[0-579]|6[2-47-9]|7[0-24578]|9[2-57]))\\d)\\d)|2(?:0[013478]|3[0189]|4[017]|8[0-46-9]|9[0-2])\\d{3})\\d{4}|1(?:2(?:0(?:46[1-4]|87[2-9])|545[1-79]|76(?:2\\d|3[1-8]|6[1-6])|9(?:7(?:2[0-4]|3[2-5])|8(?:2[2-8]|7[0-47-9]|8[3-5])))|3(?:6(?:38[2-5]|47[23])|8(?:47[04-9]|64[0157-9]))|4(?:044[1-7]|20(?:2[23]|8\\d)|6(?:0(?:30|5[2-57]|6[1-8]|7[2-8])|140)|8(?:052|87[1-3]))|5(?:2(?:4(?:3[2-79]|6\\d)|76\\d)|6(?:26[06-9]|686))|6(?:06(?:4\\d|7[4-79])|295[5-7]|35[34]\\d|47(?:24|61)|59(?:5[08]|6[67]|74)|9(?:55[0-4]|77[23]))|7(?:26(?:6[13-9]|7[0-7])|(?:442|688)\\d|50(?:2[0-3]|[3-68]2|76))|8(?:27[56]\\d|37(?:5[2-5]|8[239])|843[2-58])|9(?:0(?:0(?:6[1-8]|85)|52\\d)|3583|4(?:66[1-8]|9(?:2[01]|81))|63(?:23|3[1-4])|9561))\\d{3}",[9,10]],["7(?:457[0-57-9]|700[01]|911[028])\\d{5}|7(?:[1-3]\\d\\d|4(?:[0-46-9]\\d|5[0-689])|5(?:0[0-8]|[13-9]\\d|2[0-35-9])|7(?:0[1-9]|[1-7]\\d|8[02-9]|9[0-689])|8(?:[014-9]\\d|[23][0-8])|9(?:[024-9]\\d|1[02-9]|3[0-689]))\\d{6}",[10]],["80[08]\\d{7}|800\\d{6}|8001111"],["(?:8(?:4[2-5]|7[0-3])|9(?:[01]\\d|8[2-49]))\\d{7}|845464\\d",[7,10]],["70\\d{8}",[10]],0,["(?:3[0347]|55)\\d{8}",[10]],["76(?:464|652)\\d{5}|76(?:0[0-28]|2[356]|34|4[01347]|5[49]|6[0-369]|77|8[14]|9[139])\\d{6}",[10]],["56\\d{8}",[10]]],0," x"],"GD":["1","011","(?:473|[58]\\d\\d|900)\\d{7}",[10],0,"1",0,"([2-9]\\d{6})$|1","473$1",0,"473"],"GE":["995","00","(?:[3-57]\\d\\d|800)\\d{6}",[9],[["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["70"],"0$1"],["(\\d{2})(\\d{3})(\\d{2})(\\d{2})","$1 $2 $3 $4",["32"],"0$1"],["(\\d{3})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[57]"]],["(\\d{3})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[348]"],"0$1"]],"0"],"GF":["594","00","(?:[56]94\\d|7093)\\d{5}|(?:80|9\\d)\\d{7}",[9],[["(\\d{3})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[5-7]|9[47]"],"0$1"],["(\\d{3})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[89]"],"0$1"]],"0"],"GG":["44","00","(?:1481|[357-9]\\d{3})\\d{6}|8\\d{6}(?:\\d{2})?",[7,9,10],0,"0",0,"([25-9]\\d{5})$|0|180020","1481$1",0,0,[["1481[25-9]\\d{5}",[10]],["7(?:(?:781|839)\\d|911[17])\\d{5}",[10]],["80[08]\\d{7}|800\\d{6}|8001111"],["(?:8(?:4[2-5]|7[0-3])|9(?:[01]\\d|8[0-3]))\\d{7}|845464\\d",[7,10]],["70\\d{8}",[10]],0,["(?:3[0347]|55)\\d{8}",[10]],["76(?:464|652)\\d{5}|76(?:0[0-28]|2[356]|34|4[01347]|5[49]|6[0-369]|77|8[14]|9[139])\\d{6}",[10]],["56\\d{8}",[10]]]],"GH":["233","00","(?:[235]\\d{3}|800)\\d{5}",[8,9],[["(\\d{3})(\\d{5})","$1 $2",["8"],"0$1"],["(\\d{2})(\\d{3})(\\d{4})","$1 $2 $3",["[235]"],"0$1"]],"0"],"GI":["350","00","(?:[25]\\d|60)\\d{6}",[8],[["(\\d{3})(\\d{5})","$1 $2",["2"]]]],"GL":["299","00","(?:19|[2-689]\\d|70)\\d{4}",[6],[["(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3",["19|[2-9]"]]]],"GM":["220","00","[2-9]\\d{6}",[7],[["(\\d{3})(\\d{4})","$1 $2",["[2-9]"]]]],"GN":["224","00","722\\d{6}|(?:3|6\\d)\\d{7}",[8,9],[["(\\d{2})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["3"]],["(\\d{3})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[67]"]]]],"GP":["590","00","(?:590\\d|7090)\\d{5}|(?:69|80|9\\d)\\d{7}",[9],[["(\\d{3})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[5-79]"],"0$1"],["(\\d{3})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["8"],"0$1"]],"0",0,0,0,0,0,[["590(?:0[1-68]|[14][0-24-9]|2[0-68]|3[1-9]|5[3-579]|[68][0-689]|7[08]|9\\d)\\d{4}"],["(?:69(?:0\\d\\d|1(?:2[2-9]|3[0-5])|4(?:0[89]|1[2-6]|9\\d)|6(?:1[016-9]|5[0-4]|[67]\\d))|7090[0-4])\\d{4}"],["80[0-5]\\d{6}"],0,0,0,0,0,["9(?:(?:39[5-7]|76[018])\\d|475[0-6])\\d{4}"]]],"GQ":["240","00","222\\d{6}|(?:3\\d|55|[89]0)\\d{7}",[9],[["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["[235]"]],["(\\d{3})(\\d{6})","$1 $2",["[89]"]]]],"GR":["30","00","5005000\\d{3}|8\\d{9,11}|(?:[269]\\d|70)\\d{8}",[10,11,12],[["(\\d{2})(\\d{4})(\\d{4})","$1 $2 $3",["21|7"]],["(\\d{4})(\\d{6})","$1 $2",["2(?:2|3[2-57-9]|4[2-469]|5[2-59]|6[2-9]|7[2-69]|8[2-49])|5"]],["(\\d{3})(\\d{3})(\\d{4})","$1 $2 $3",["[2689]"]],["(\\d{3})(\\d{3,4})(\\d{5})","$1 $2 $3",["8"]]]],"GT":["502","00","80\\d{6}|(?:1\\d{3}|[2-7])\\d{7}",[8,11],[["(\\d{4})(\\d{4})","$1 $2",["[2-8]"]],["(\\d{4})(\\d{3})(\\d{4})","$1 $2 $3",["1"]]]],"GU":["1","011","(?:[58]\\d\\d|671|900)\\d{7}",[10],0,"1",0,"([2-9]\\d{6})$|1","671$1",0,"671"],"GW":["245","00","[49]\\d{8}|4\\d{6}",[7,9],[["(\\d{3})(\\d{4})","$1 $2",["40"]],["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["[49]"]]]],"GY":["592","001","(?:[2-8]\\d{3}|9008)\\d{3}",[7],[["(\\d{3})(\\d{4})","$1 $2",["[2-9]"]]]],"HK":["852","00(?:30|5[09]|[126-9]?)","8[0-46-9]\\d{6,7}|9\\d{4,7}|(?:[2-7]|9\\d{3})\\d{7}",[5,6,7,8,9,11],[["(\\d{3})(\\d{2,5})","$1 $2",["900","9003"]],["(\\d{4})(\\d{4})","$1 $2",["[2-7]|8[1-4]|9(?:0[1-9]|[1-8])"]],["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["8"]],["(\\d{3})(\\d{2})(\\d{3})(\\d{3})","$1 $2 $3 $4",["9"]]],0,0,0,0,0,0,0,"00"],"HN":["504","00","8\\d{10}|[237-9]\\d{7}",[8,11],[["(\\d{4})(\\d{4})","$1-$2",["[237-9]"]]]],"HR":["385","00","[2-69]\\d{8}|80\\d{5,7}|[1-79]\\d{7}|6\\d{6}",[7,8,9],[["(\\d{2})(\\d{2})(\\d{3})","$1 $2 $3",["6[01]"],"0$1"],["(\\d{3})(\\d{2})(\\d{2,3})","$1 $2 $3",["8"],"0$1"],["(\\d)(\\d{4})(\\d{3})","$1 $2 $3",["1"],"0$1"],["(\\d{2})(\\d{3})(\\d{3,4})","$1 $2 $3",["6|7[245]"],"0$1"],["(\\d{2})(\\d{3})(\\d{3,4})","$1 $2 $3",["9"],"0$1"],["(\\d{2})(\\d{3})(\\d{3,4})","$1 $2 $3",["[2-57]"],"0$1"],["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["8"],"0$1"]],"0"],"HT":["509","00","[2-589]\\d{7}",[8],[["(\\d{2})(\\d{2})(\\d{4})","$1 $2 $3",["[2-589]"]]]],"HU":["36","00","[235-7]\\d{8}|[1-9]\\d{7}",[8,9],[["(\\d)(\\d{3})(\\d{4})","$1 $2 $3",["1"],"(06 $1)"],["(\\d{2})(\\d{3})(\\d{3})","$1 $2 $3",["[27][2-9]|3[2-7]|4[24-9]|5[2-79]|6|8[2-57-9]|9[2-69]"],"(06 $1)"],["(\\d{2})(\\d{3})(\\d{3,4})","$1 $2 $3",["[2-9]"],"06 $1"]],"06"],"ID":["62","00[89]","00[1-9]\\d{9,14}|(?:[1-36]|8\\d{5})\\d{6}|00\\d{9}|[1-9]\\d{8,10}|[2-9]\\d{7}",[7,8,9,10,11,12,13,14,15,16,17],[["(\\d)(\\d{3})(\\d{3})","$1 $2 $3",["15"]],["(\\d{2})(\\d{5,9})","$1 $2",["2[124]|[36]1"],"(0$1)"],["(\\d{3})(\\d{5,7})","$1 $2",["800"],"0$1"],["(\\d{3})(\\d{5,8})","$1 $2",["[2-79]"],"(0$1)"],["(\\d{3})(\\d{3,4})(\\d{3})","$1-$2-$3",["8[1-35-9]"],"0$1"],["(\\d{3})(\\d{6,8})","$1 $2",["1"],"0$1"],["(\\d{3})(\\d{3})(\\d{4})","$1 $2 $3",["804"],"0$1"],["(\\d{3})(\\d)(\\d{3})(\\d{3})","$1 $2 $3 $4",["80"],"0$1"],["(\\d{3})(\\d{4})(\\d{4,5})","$1-$2-$3",["8"],"0$1"]],"0"],"IE":["353","00","(?:1\\d|[2569])\\d{6,8}|4\\d{6,9}|7\\d{8}|8\\d{8,9}",[7,8,9,10],[["(\\d{2})(\\d{5})","$1 $2",["2[24-9]|47|58|6[237-9]|9[35-9]"],"(0$1)"],["(\\d{3})(\\d{5})","$1 $2",["[45]0"],"(0$1)"],["(\\d)(\\d{3,4})(\\d{4})","$1 $2 $3",["1"],"(0$1)"],["(\\d{2})(\\d{3})(\\d{3,4})","$1 $2 $3",["[2569]|4[1-69]|7[14]"],"(0$1)"],["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["70"],"0$1"],["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["81"],"(0$1)"],["(\\d{2})(\\d{3})(\\d{4})","$1 $2 $3",["[78]"],"0$1"],["(\\d{4})(\\d{3})(\\d{3})","$1 $2 $3",["1"]],["(\\d{2})(\\d{4})(\\d{4})","$1 $2 $3",["4"],"(0$1)"],["(\\d{2})(\\d)(\\d{3})(\\d{4})","$1 $2 $3 $4",["8"],"0$1"]],"0"],"IL":["972","0(?:0|1[2-9])","1\\d{6}(?:\\d{3,5})?|[57]\\d{8}|[1-489]\\d{7}",[7,8,9,10,11,12],[["(\\d{4})(\\d{3})","$1-$2",["125"]],["(\\d{4})(\\d{2})(\\d{2})","$1-$2-$3",["121"]],["(\\d)(\\d{3})(\\d{4})","$1-$2-$3",["[2-489]"],"0$1"],["(\\d{2})(\\d{3})(\\d{4})","$1-$2-$3",["[57]"],"0$1"],["(\\d{4})(\\d{3})(\\d{3})","$1-$2-$3",["12"]],["(\\d{4})(\\d{6})","$1-$2",["159"]],["(\\d)(\\d{3})(\\d{3})(\\d{3})","$1-$2-$3-$4",["1[7-9]"]],["(\\d{3})(\\d{1,2})(\\d{3})(\\d{4})","$1-$2 $3-$4",["15"]]],"0"],"IM":["44","00","1624\\d{6}|(?:[3578]\\d|90)\\d{8}",[10],0,"0",0,"([25-8]\\d{5})$|0|180020","1624$1",0,"74576|(?:16|7[56])24"],"IN":["91","00","(?:000800|[2-9]\\d\\d)\\d{7}|1\\d{7,12}",[8,9,10,11,12,13],[["(\\d{8})","$1",["5(?:0|2[23]|3[03]|[67]1|88)","5(?:0|2(?:21|3)|3(?:0|3[23])|616|717|888)","5(?:0|2(?:21|3)|3(?:0|3[23])|616|717|8888)"],0,1],["(\\d{4})(\\d{4,5})","$1 $2",["180","1800"],0,1],["(\\d{3})(\\d{3})(\\d{4})","$1 $2 $3",["140"],0,1],["(\\d{2})(\\d{4})(\\d{4})","$1 $2 $3",["11|2[02]|33|4[04]|79[1-7]|80[2-46]","11|2[02]|33|4[04]|79(?:[1-6]|7[19])|80(?:[2-4]|6[0-589])","11|2[02]|33|4[04]|79(?:[124-6]|3(?:[02-9]|1[0-24-9])|7(?:1|9[1-6]))|80(?:[2-4]|6[0-589])"],"0$1",1],["(\\d{3})(\\d{3})(\\d{4})","$1 $2 $3",["1(?:2[0-249]|3[0-25]|4[145]|[68]|7[1257])|2(?:1[257]|3[013]|4[01]|5[0137]|6[0158]|78|8[1568])|3(?:26|4[1-3]|5[34]|6[01489]|7[02-46]|8[159])|4(?:1[36]|2[1-47]|5[12]|6[0-26-9]|7[0-24-9]|8[013-57]|9[014-7])|5(?:1[025]|22|[36][25]|4[28]|5[12]|[78]1)|6(?:12|[2-4]1|5[17]|6[13]|80)|7(?:12|3[134]|4[47]|61|88)|8(?:16|2[014]|3[126]|6[136]|7[078]|8[34]|91)|(?:43|59|75)[15]|(?:1[59]|29|67|72)[14]","1(?:2[0-24]|3[0-25]|4[145]|[59][14]|6[1-9]|7[1257]|8[1-57-9])|2(?:1[257]|3[013]|4[01]|5[0137]|6[058]|78|8[1568]|9[14])|3(?:26|4[1-3]|5[34]|6[01489]|7[02-46]|8[159])|4(?:1[36]|2[1-47]|3[15]|5[12]|6[0-26-9]|7[0-24-9]|8[013-57]|9[014-7])|5(?:1[025]|22|[36][25]|4[28]|[578]1|9[15])|674|7(?:(?:2[14]|3[34]|5[15])[2-6]|61[346]|88[0-8])|8(?:70[2-6]|84[235-7]|91[3-7])|(?:1(?:29|60|8[06])|261|552|6(?:12|[2-47]1|5[17]|6[13]|80)|7(?:12|31|4[47])|8(?:16|2[014]|3[126]|6[136]|7[78]|83))[2-7]","1(?:2[0-24]|3[0-25]|4[145]|[59][14]|6[1-9]|7[1257]|8[1-57-9])|2(?:1[257]|3[013]|4[01]|5[0137]|6[058]|78|8[1568]|9[14])|3(?:26|4[1-3]|5[34]|6[01489]|7[02-46]|8[159])|4(?:1[36]|2[1-47]|3[15]|5[12]|6[0-26-9]|7[0-24-9]|8[013-57]|9[014-7])|5(?:1[025]|22|[36][25]|4[28]|[578]1|9[15])|6(?:12(?:[2-6]|7[0-8])|74[2-7])|7(?:(?:2[14]|5[15])[2-6]|3171|61[346]|88(?:[2-7]|82))|8(?:70[2-6]|84(?:[2356]|7[19])|91(?:[3-6]|7[19]))|73[134][2-6]|(?:74[47]|8(?:16|2[014]|3[126]|6[136]|7[78]|83))(?:[2-6]|7[19])|(?:1(?:29|60|8[06])|261|552|6(?:[2-4]1|5[17]|6[13]|7(?:1|4[0189])|80)|7(?:12|88[01]))[2-7]"],"0$1",1],["(\\d{4})(\\d{3})(\\d{3})","$1 $2 $3",["1(?:[2-479]|5[0235-9])|[2-5]|6(?:1[1358]|2[2457-9]|3[2-5]|4[235-7]|5[2-689]|6[24578]|7[235689]|8[1-6])|7(?:1[013-9]|28|3[129]|4[1-35689]|5[29]|6[02-5]|70)|807","1(?:[2-479]|5[0235-9])|[2-5]|6(?:1[1358]|2(?:[2457]|84|95)|3(?:[2-4]|55)|4[235-7]|5[2-689]|6[24578]|7[235689]|8[1-6])|7(?:1(?:[013-8]|9[6-9])|28[6-8]|3(?:17|2[0-49]|9[2-57])|4(?:1[2-4]|[29][0-7]|3[0-8]|[56]|8[0-24-7])|5(?:2[1-3]|9[0-6])|6(?:0[5689]|2[5-9]|3[02-8]|4|5[0-367])|70[13-7])|807[19]","1(?:[2-479]|5(?:[0236-9]|5[013-9]))|[2-5]|6(?:2(?:84|95)|355|83)|73179|807(?:1|9[1-3])|(?:1552|6(?:1[1358]|2[2457]|3[2-4]|4[235-7]|5[2-689]|6[24578]|7[235689]|8[124-6])\\d|7(?:1(?:[013-8]\\d|9[6-9])|28[6-8]|3(?:2[0-49]|9[2-57])|4(?:1[2-4]|[29][0-7]|3[0-8]|[56]\\d|8[0-24-7])|5(?:2[1-3]|9[0-6])|6(?:0[5689]|2[5-9]|3[02-8]|4\\d|5[0-367])|70[13-7]))[2-7]"],"0$1",1],["(\\d{5})(\\d{5})","$1 $2",["[6-9]"],"0$1",1],["(\\d{4})(\\d{2,4})(\\d{4})","$1 $2 $3",["1(?:6|8[06])","1(?:6|8[06]0)"],0,1],["(\\d{4})(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3 $4",["18"],0,1]],"0"],"IO":["246","00","3\\d{6}",[7],[["(\\d{3})(\\d{4})","$1 $2",["3"]]]],"IQ":["964","00","(?:1|7\\d\\d)\\d{7}|[2-6]\\d{7,8}",[8,9,10],[["(\\d)(\\d{3})(\\d{4})","$1 $2 $3",["1"],"0$1"],["(\\d{2})(\\d{3})(\\d{3,4})","$1 $2 $3",["[2-6]"],"0$1"],["(\\d{3})(\\d{3})(\\d{4})","$1 $2 $3",["7"],"0$1"]],"0"],"IR":["98","00","[1-9]\\d{9}|(?:[1-8]\\d\\d|9)\\d{3,4}",[4,5,6,7,10],[["(\\d{4,5})","$1",["96"],"0$1"],["(\\d{2})(\\d{4,5})","$1 $2",["(?:1[137]|2[13-68]|3[1458]|4[145]|5[1468]|6[16]|7[1467]|8[13467])[12689]"],"0$1"],["(\\d{3})(\\d{3})(\\d{3,4})","$1 $2 $3",["9"],"0$1"],["(\\d{2})(\\d{4})(\\d{4})","$1 $2 $3",["[1-8]"],"0$1"]],"0"],"IS":["354","00|1(?:0(?:01|[12]0)|100)","(?:38\\d|[4-9])\\d{6}",[7,9],[["(\\d{3})(\\d{4})","$1 $2",["[4-9]"]],["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["3"]]],0,0,0,0,0,0,0,"00"],"IT":["39","00","0\\d{5,11}|1\\d{8,10}|3(?:[0-8]\\d{7,10}|9\\d{7,8})|(?:43|55|70)\\d{8}|8\\d{5}(?:\\d{2,4})?",[6,7,8,9,10,11,12],[["(\\d{2})(\\d{4,6})","$1 $2",["0[26]"]],["(\\d{3})(\\d{3,6})","$1 $2",["0[13-57-9][0159]|8(?:03|4[17]|9[2-5])","0[13-57-9][0159]|8(?:03|4[17]|9(?:2|3[04]|[45][0-4]))"]],["(\\d{4})(\\d{2,6})","$1 $2",["0(?:[13-579][2-46-8]|8[236-8])"]],["(\\d{4})(\\d{4})","$1 $2",["894"]],["(\\d{2})(\\d{3,4})(\\d{4})","$1 $2 $3",["0[26]|5"]],["(\\d{3})(\\d{3})(\\d{3,4})","$1 $2 $3",["1(?:44|[679])|[378]|43"]],["(\\d{3})(\\d{3,4})(\\d{4})","$1 $2 $3",["0[13-57-9][0159]|14"]],["(\\d{2})(\\d{4})(\\d{5})","$1 $2 $3",["0[26]"]],["(\\d{4})(\\d{3})(\\d{4})","$1 $2 $3",["0"]],["(\\d{3})(\\d{4})(\\d{4,5})","$1 $2 $3",["[03]"]]],0,0,0,0,0,0,[["0(?:669[0-79]\\d{1,6}|831\\d{2,8})|0(?:1(?:[0159]\\d|[27][1-5]|31|4[1-4]|6[1356]|8[2-57])|2\\d\\d|3(?:[0159]\\d|2[1-4]|3[12]|[48][1-6]|6[2-59]|7[1-7])|4(?:[0159]\\d|[23][1-9]|4[245]|6[1-5]|7[1-4]|81)|5(?:[0159]\\d|2[1-5]|3[2-6]|4[1-79]|6[4-6]|7[1-578]|8[3-8])|6(?:[0-57-9]\\d|6[0-8])|7(?:[0159]\\d|2[12]|3[1-7]|4[2-46]|6[13569]|7[13-6]|8[1-59])|8(?:[0159]\\d|2[3-578]|3[2356]|[6-8][1-5])|9(?:[0159]\\d|[238][1-5]|4[12]|6[1-8]|7[1-6]))\\d{2,7}"],["3[2-9]\\d{7,8}|(?:31|43)\\d{8}",[9,10]],["80(?:0\\d{3}|3)\\d{3}",[6,9]],["(?:0878\\d{3}|89(?:2\\d|3[04]|4(?:[0-4]|[5-9]\\d\\d)|5[0-4]))\\d\\d|(?:1(?:44|6[346])|89(?:38|5[5-9]|9))\\d{6}",[6,8,9,10]],["1(?:78\\d|99)\\d{6}",[9,10]],["3[2-8]\\d{9,10}",[11,12]],0,0,["55\\d{8}",[10]],["84(?:[08]\\d{3}|[17])\\d{3}",[6,9]]]],"JE":["44","00","1534\\d{6}|(?:[3578]\\d|90)\\d{8}",[10],0,"0",0,"([0-24-8]\\d{5})$|0|180020","1534$1",0,0,[["1534[0-24-8]\\d{5}"],["7(?:(?:(?:50|82)9|937)\\d|7(?:00[378]|97\\d))\\d{5}"],["80(?:07(?:35|81)|8901)\\d{4}"],["(?:8(?:4(?:4(?:4(?:05|42|69)|703)|5(?:041|800))|7(?:0002|1206))|90(?:066[59]|1810|71(?:07|55)))\\d{4}"],["701511\\d{4}"],0,["(?:3(?:0(?:07(?:35|81)|8901)|3\\d{4}|4(?:4(?:4(?:05|42|69)|703)|5(?:041|800))|7(?:0002|1206))|55\\d{4})\\d{4}"],["76(?:464|652)\\d{5}|76(?:0[0-28]|2[356]|34|4[01347]|5[49]|6[0-369]|77|8[14]|9[139])\\d{6}"],["56\\d{8}"]]],"JM":["1","011","(?:[58]\\d\\d|658|900)\\d{7}",[10],0,"1",0,0,0,0,"658|876"],"JO":["962","00","(?:(?:[2689]|7\\d)\\d|32|427|53)\\d{6}",[8,9],[["(\\d)(\\d{3})(\\d{4})","$1 $2 $3",["[2356]|87"],"(0$1)"],["(\\d{3})(\\d{5,6})","$1 $2",["[89]"],"0$1"],["(\\d{2})(\\d{7})","$1 $2",["70"],"0$1"],["(\\d)(\\d{4})(\\d{4})","$1 $2 $3",["[47]"],"0$1"]],"0"],"JP":["81","010","00[1-9]\\d{6,14}|[25-9]\\d{9}|(?:00|[1-9]\\d\\d)\\d{6}",[8,9,10,11,12,13,14,15,16,17],[["(\\d{3})(\\d{3})(\\d{3})","$1-$2-$3",["(?:12|57|99)0"],"0$1"],["(\\d{4})(\\d)(\\d{4})","$1-$2-$3",["1(?:26|3[79]|4[56]|5[4-68]|6[3-5])|499|5(?:76|97)|746|8(?:3[89]|47|51)|9(?:80|9[16])","1(?:267|3(?:7[247]|9[278])|466|5(?:47|58|64)|6(?:3[245]|48|5[4-68]))|499[2468]|5(?:76|97)9|7468|8(?:3(?:8[7-9]|96)|477|51[2-9])|9(?:802|9(?:1[23]|69))|1(?:45|58)[67]","1(?:267|3(?:7[247]|9[278])|466|5(?:47|58|64)|6(?:3[245]|48|5[4-68]))|499[2468]|5(?:769|979[2-69])|7468|8(?:3(?:8[7-9]|96[2457-9])|477|51[2-9])|9(?:802|9(?:1[23]|69))|1(?:45|58)[67]"],"0$1"],["(\\d{2})(\\d{3})(\\d{4})","$1-$2-$3",["60"],"0$1"],["(\\d)(\\d{4})(\\d{4})","$1-$2-$3",["3|4(?:2[09]|7[01])|6[1-9]","3|4(?:2(?:0|9[02-69])|7(?:0[019]|1))|6[1-9]"],"0$1"],["(\\d{2})(\\d{3})(\\d{4})","$1-$2-$3",["1(?:1|5[45]|77|88|9[69])|2(?:2[1-37]|3[0-269]|4[59]|5|6[24]|7[1-358]|8[1369]|9[0-38])|4(?:[28][1-9]|3[0-57]|[45]|6[248]|7[2-579]|9[29])|5(?:2|3[0459]|4[0-369]|5[29]|8[02389]|9[0-389])|7(?:2[02-46-9]|34|[58]|6[0249]|7[57]|9[2-6])|8(?:2[124589]|3[26-9]|49|51|6|7[0-468]|8[68]|9[019])|9(?:[23][1-9]|4[15]|5[138]|6[1-3]|7[156]|8[189]|9[1-489])","1(?:1|5(?:4[018]|5[017])|77|88|9[69])|2(?:2(?:[127]|3[014-9])|3[0-269]|4[59]|5(?:[1-3]|5[0-69]|9[19])|62|7(?:[1-35]|8[0189])|8(?:[16]|3[0134]|9[0-5])|9(?:[028]|17))|4(?:2(?:[13-79]|8[014-6])|3[0-57]|[45]|6[248]|7[2-47]|8[1-9]|9[29])|5(?:2|3(?:[045]|9[0-8])|4[0-369]|5[29]|8[02389]|9[0-3])|7(?:2[02-46-9]|34|[58]|6[0249]|7[57]|9(?:[23]|4[0-59]|5[01569]|6[0167]))|8(?:2(?:[1258]|4[0-39]|9[0-2469])|3(?:[29]|60)|49|51|6(?:[0-24]|36|5[0-3589]|7[23]|9[01459])|7[0-468]|8[68])|9(?:[23][1-9]|4[15]|5[138]|6[1-3]|7[156]|8[189]|9(?:[1289]|3[34]|4[0178]))|(?:264|837)[016-9]|2(?:57|93)[015-9]|(?:25[0468]|422|838)[01]|(?:47[59]|59[89]|8(?:6[68]|9))[019]","1(?:1|5(?:4[018]|5[017])|77|88|9[69])|2(?:2[127]|3[0-269]|4[59]|5(?:[1-3]|5[0-69]|9(?:17|99))|6(?:2|4[016-9])|7(?:[1-35]|8[0189])|8(?:[16]|3[0134]|9[0-5])|9(?:[028]|17))|4(?:2(?:[13-79]|8[014-6])|3[0-57]|[45]|6[248]|7[2-47]|9[29])|5(?:2|3(?:[045]|9(?:[0-58]|6[4-9]|7[0-35689]))|4[0-369]|5[29]|8[02389]|9[0-3])|7(?:2[02-46-9]|34|[58]|6[0249]|7[57]|9(?:[23]|4[0-59]|5[01569]|6[0167]))|8(?:2(?:[1258]|4[0-39]|9[0169])|3(?:[29]|60|7(?:[017-9]|6[6-8]))|49|51|6(?:[0-24]|36[2-57-9]|5(?:[0-389]|5[23])|6(?:[01]|9[178])|7(?:2[2-468]|3[78])|9[0145])|7[0-468]|8[68])|9(?:4[15]|5[138]|7[156]|8[189]|9(?:[1289]|3(?:31|4[357])|4[0178]))|(?:8294|96)[1-3]|2(?:57|93)[015-9]|(?:223|8699)[014-9]|(?:25[0468]|422|838)[01]|(?:48|8292|9[23])[1-9]|(?:47[59]|59[89]|8(?:68|9))[019]"],"0$1"],["(\\d{3})(\\d{2})(\\d{4})","$1-$2-$3",["[14]|[289][2-9]|5[3-9]|7[2-4679]"],"0$1"],["(\\d{3})(\\d{3})(\\d{4})","$1-$2-$3",["800"],"0$1"],["(\\d{2})(\\d{4})(\\d{4})","$1-$2-$3",["[25-9]"],"0$1"]],"0",0,"(000[2569]\\d{4,6})$|(?:(?:003768)0?)|0","$1"],"KE":["254","000","(?:[17]\\d\\d|900)\\d{6}|(?:2|80)0\\d{6,7}|[4-6]\\d{6,8}",[7,8,9,10],[["(\\d{2})(\\d{5,7})","$1 $2",["[24-6]"],"0$1"],["(\\d{3})(\\d{6})","$1 $2",["[17]"],"0$1"],["(\\d{3})(\\d{3})(\\d{3,4})","$1 $2 $3",["[89]"],"0$1"]],"0"],"KG":["996","00","8\\d{9}|[235-9]\\d{8}",[9,10],[["(\\d{4})(\\d{5})","$1 $2",["3(?:1[346]|[24-79])"],"0$1"],["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["[235-79]|88"],"0$1"],["(\\d{3})(\\d{3})(\\d)(\\d{2,3})","$1 $2 $3 $4",["8"],"0$1"]],"0"],"KH":["855","00[14-9]","1\\d{9}|[1-9]\\d{7,8}",[8,9,10],[["(\\d{2})(\\d{3})(\\d{3,4})","$1 $2 $3",["[1-9]"],"0$1"],["(\\d{4})(\\d{3})(\\d{3})","$1 $2 $3",["1"]]],"0"],"KI":["686","00","(?:[37]\\d|6[0-79])\\d{6}|(?:[2-48]\\d|50)\\d{3}",[5,8],0,"0"],"KM":["269","00","[3478]\\d{6}",[7],[["(\\d{3})(\\d{2})(\\d{2})","$1 $2 $3",["[3478]"]]]],"KN":["1","011","(?:[58]\\d\\d|900)\\d{7}",[10],0,"1",0,"([2-7]\\d{6})$|1","869$1",0,"869"],"KP":["850","00|99","85\\d{6}|(?:19\\d|[2-7])\\d{7}",[8,10],[["(\\d{2})(\\d{3})(\\d{3})","$1 $2 $3",["8"],"0$1"],["(\\d)(\\d{3})(\\d{4})","$1 $2 $3",["[2-7]"],"0$1"],["(\\d{3})(\\d{3})(\\d{4})","$1 $2 $3",["1"],"0$1"]],"0"],"KR":["82","00(?:[125689]|3(?:[46]5|91)|7(?:00|27|3|55|6[126]))","00[1-9]\\d{8,11}|(?:[12]|5\\d{3})\\d{7}|[13-6]\\d{9}|(?:[1-6]\\d|80)\\d{7}|[3-6]\\d{4,5}|(?:00|7)0\\d{8}",[5,6,8,9,10,11,12,13,14],[["(\\d{2})(\\d{3,4})","$1-$2",["(?:3[1-3]|[46][1-4]|5[1-5])1"],"0$1"],["(\\d{4})(\\d{4})","$1-$2",["1"]],["(\\d)(\\d{3,4})(\\d{4})","$1-$2-$3",["2"],"0$1"],["(\\d{2})(\\d{3})(\\d{4})","$1-$2-$3",["[36]0|8"],"0$1"],["(\\d{2})(\\d{3,4})(\\d{4})","$1-$2-$3",["[1346]|5[1-5]"],"0$1"],["(\\d{2})(\\d{4})(\\d{4})","$1-$2-$3",["[57]"],"0$1"],["(\\d{2})(\\d{5})(\\d{4})","$1-$2-$3",["5"],"0$1"]],"0",0,"0(8(?:[1-46-8]|5\\d\\d))?"],"KW":["965","00","18\\d{5}|(?:[2569]\\d|41)\\d{6}",[7,8],[["(\\d{4})(\\d{3,4})","$1 $2",["[169]|2(?:[235]|4[1-35-9])|52"]],["(\\d{3})(\\d{5})","$1 $2",["[245]"]]]],"KY":["1","011","(?:345|[58]\\d\\d|900)\\d{7}",[10],0,"1",0,"([2-9]\\d{6})$|1","345$1",0,"345"],"KZ":["7","810","(?:33622|8\\d{8})\\d{5}|[78]\\d{9}",[10,14],0,"8",0,0,0,0,"33622|7",0,"8~10"],"LA":["856","00","[23]\\d{9}|3\\d{8}|(?:[235-8]\\d|41)\\d{6}",[8,9,10],[["(\\d{2})(\\d{3})(\\d{3})","$1 $2 $3",["2[13]|3[14]|[4-8]"],"0$1"],["(\\d{2})(\\d{2})(\\d{2})(\\d{3})","$1 $2 $3 $4",["3"],"0$1"],["(\\d{2})(\\d{2})(\\d{3})(\\d{3})","$1 $2 $3 $4",["[23]"],"0$1"]],"0"],"LB":["961","00","[27-9]\\d{7}|[13-9]\\d{6}",[7,8],[["(\\d)(\\d{3})(\\d{3})","$1 $2 $3",["[13-69]|7(?:[2-57]|62|8[0-6]|9[04-9])|8[02-9]"],"0$1"],["(\\d{2})(\\d{3})(\\d{3})","$1 $2 $3",["[27-9]"]]],"0"],"LC":["1","011","(?:[58]\\d\\d|758|900)\\d{7}",[10],0,"1",0,"([2-8]\\d{6})$|1","758$1",0,"758"],"LI":["423","00","[68]\\d{8}|(?:[2378]\\d|90)\\d{5}",[7,9],[["(\\d{3})(\\d{2})(\\d{2})","$1 $2 $3",["[2379]|8(?:0[09]|7)","[2379]|8(?:0(?:02|9)|7)"]],["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["8"]],["(\\d{2})(\\d{3})(\\d{4})","$1 $2 $3",["69"]],["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["6"]]],"0",0,"(1001)|0"],"LK":["94","00","[1-9]\\d{8}",[9],[["(\\d{2})(\\d{3})(\\d{4})","$1 $2 $3",["7"],"0$1"],["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["[1-689]"],"0$1"]],"0"],"LR":["231","00","(?:[2457]\\d|33|88)\\d{7}|(?:2\\d|[4-6])\\d{6}",[7,8,9],[["(\\d)(\\d{3})(\\d{3})","$1 $2 $3",["4[67]|[56]"],"0$1"],["(\\d{2})(\\d{3})(\\d{3})","$1 $2 $3",["2"],"0$1"],["(\\d{2})(\\d{3})(\\d{4})","$1 $2 $3",["[2-578]"],"0$1"]],"0"],"LS":["266","00","(?:[256]\\d\\d|800)\\d{5}",[8],[["(\\d{4})(\\d{4})","$1 $2",["[2568]"]]]],"LT":["370","00","(?:[3469]\\d|52|[78]0)\\d{6}",[8],[["(\\d)(\\d{3})(\\d{4})","$1 $2 $3",["52[0-7]"],"(0-$1)",1],["(\\d{3})(\\d{2})(\\d{3})","$1 $2 $3",["[7-9]"],"0 $1",1],["(\\d{2})(\\d{6})","$1 $2",["37|4(?:[15]|6[1-8])"],"(0-$1)",1],["(\\d{3})(\\d{5})","$1 $2",["[3-6]"],"(0-$1)",1]],"0",0,"[08]"],"LU":["352","00","35[013-9]\\d{4,8}|6\\d{8}|35\\d{2,4}|(?:[2457-9]\\d|3[0-46-9])\\d{2,9}",[4,5,6,7,8,9,10,11],[["(\\d{2})(\\d{3})","$1 $2",["2(?:0[2-689]|[2-9])|[3-57]|8(?:0[2-9]|[13-9])|9(?:0[89]|[2-579])"]],["(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3",["2(?:0[2-689]|[2-9])|[3-57]|8(?:0[2-9]|[13-9])|9(?:0[89]|[2-579])"]],["(\\d{2})(\\d{2})(\\d{3})","$1 $2 $3",["20[2-689]"]],["(\\d{2})(\\d{2})(\\d{2})(\\d{1,2})","$1 $2 $3 $4",["2(?:[0367]|4[3-8])"]],["(\\d{3})(\\d{2})(\\d{3})","$1 $2 $3",["80[01]|90[015]"]],["(\\d{2})(\\d{2})(\\d{2})(\\d{3})","$1 $2 $3 $4",["20"]],["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["6"]],["(\\d{2})(\\d{2})(\\d{2})(\\d{2})(\\d{1,2})","$1 $2 $3 $4 $5",["2(?:[0367]|4[3-8])"]],["(\\d{2})(\\d{2})(\\d{2})(\\d{1,5})","$1 $2 $3 $4",["[3-57]|8[13-9]|9(?:0[89]|[2-579])|(?:2|80)[2-9]"]]],0,0,"(15(?:0[06]|1[12]|[35]5|4[04]|6[26]|77|88|99)\\d)"],"LV":["371","00","(?:[268]\\d|78|90)\\d{6}",[8],[["(\\d{2})(\\d{3})(\\d{3})","$1 $2 $3",["[2679]|8[01]"]]]],"LY":["218","00","[2-9]\\d{8}",[9],[["(\\d{2})(\\d{7})","$1-$2",["[2-9]"],"0$1"]],"0"],"MA":["212","00","[5-8]\\d{8}",[9],[["(\\d{3})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["5[45]"],"0$1"],["(\\d{4})(\\d{5})","$1-$2",["5(?:2[2-46-9]|3[3-9]|9)|8(?:0[89]|92)"],"0$1"],["(\\d{2})(\\d{7})","$1-$2",["8"],"0$1"],["(\\d{3})(\\d{6})","$1-$2",["[5-7]"],"0$1"]],"0",0,0,0,0,0,[["5(?:2(?:[0-25-79]\\d|3[1-578]|4[02-46-8]|8[0235-7])|3(?:[0-47]\\d|5[02-9]|6[02-8]|8[014-9]|9[3-9])|(?:4[067]|5[03])\\d)\\d{5}"],["(?:6(?:[0-79]\\d|8[0-247-9])|7(?:[0167]\\d|2[0-8]|5[0-5]|8[0-7]))\\d{6}"],["80[0-7]\\d{6}"],["89\\d{7}"],0,0,0,0,["(?:592(?:4[0-2]|93)|80[89]\\d\\d)\\d{4}"]]],"MC":["377","00","(?:[3489]|6\\d)\\d{7}",[8,9],[["(\\d{2})(\\d{3})(\\d{3})","$1 $2 $3",["4"],"0$1"],["(\\d{2})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[389]"]],["(\\d)(\\d{2})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4 $5",["6"],"0$1"]],"0"],"MD":["373","00","(?:[235-7]\\d|[89]0)\\d{6}",[8],[["(\\d{3})(\\d{5})","$1 $2",["[89]"],"0$1"],["(\\d{2})(\\d{3})(\\d{3})","$1 $2 $3",["22|3"],"0$1"],["(\\d{3})(\\d{2})(\\d{3})","$1 $2 $3",["[25-7]"],"0$1"]],"0"],"ME":["382","00","(?:20|[3-79]\\d)\\d{6}|80\\d{6,7}",[8,9],[["(\\d{2})(\\d{3})(\\d{3,4})","$1 $2 $3",["[2-9]"],"0$1"]],"0"],"MF":["590","00","(?:590\\d|7090)\\d{5}|(?:69|80|9\\d)\\d{7}",[9],0,"0",0,0,0,0,0,[["590(?:0[079]|[14]3|[27][79]|3[03-7]|5[0-268]|87)\\d{4}"],["(?:69(?:0\\d\\d|1(?:2[2-9]|3[0-5])|4(?:0[89]|1[2-6]|9\\d)|6(?:1[016-9]|5[0-4]|[67]\\d))|7090[0-4])\\d{4}"],["80[0-5]\\d{6}"],0,0,0,0,0,["9(?:(?:39[5-7]|76[018])\\d|475[0-6])\\d{4}"]]],"MG":["261","00","[23]\\d{8}",[9],[["(\\d{2})(\\d{2})(\\d{3})(\\d{2})","$1 $2 $3 $4",["[23]"],"0$1"]],"0",0,"([24-9]\\d{6})$|0","20$1"],"MH":["692","011","329\\d{4}|(?:[256]\\d|45)\\d{5}",[7],[["(\\d{3})(\\d{4})","$1-$2",["[2-6]"]]],"1"],"MK":["389","00","[2-578]\\d{7}",[8],[["(\\d)(\\d{3})(\\d{4})","$1 $2 $3",["2|34[47]|4(?:[37]7|5[47]|64)"],"0$1"],["(\\d{2})(\\d{3})(\\d{3})","$1 $2 $3",["[347]"],"0$1"],["(\\d{3})(\\d)(\\d{2})(\\d{2})","$1 $2 $3 $4",["[58]"],"0$1"]],"0"],"ML":["223","00","[24-9]\\d{7}",[8],[["(\\d{2})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[24-9]"]]]],"MM":["95","00","1\\d{5,7}|95\\d{6}|(?:[4-7]|9[0-46-9])\\d{6,8}|(?:2|8\\d)\\d{5,8}",[6,7,8,9,10],[["(\\d)(\\d{2})(\\d{3})","$1 $2 $3",["16|2"],"0$1"],["(\\d{2})(\\d{2})(\\d{3})","$1 $2 $3",["4(?:[2-46]|5[3-5])|5|6(?:[1-689]|7[235-7])|7(?:[0-4]|5[2-7])|8[1-5]|(?:60|86)[23]"],"0$1"],["(\\d)(\\d{3})(\\d{3,4})","$1 $2 $3",["[12]|452|678|86","[12]|452|6788|86"],"0$1"],["(\\d{2})(\\d{3})(\\d{3,4})","$1 $2 $3",["[4-7]|8[1-35]"],"0$1"],["(\\d)(\\d{3})(\\d{4,6})","$1 $2 $3",["9(?:2[0-4]|[35-9]|4[137-9])"],"0$1"],["(\\d)(\\d{4})(\\d{4})","$1 $2 $3",["2"],"0$1"],["(\\d{3})(\\d{3})(\\d{4})","$1 $2 $3",["8"],"0$1"],["(\\d)(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3 $4",["92"],"0$1"],["(\\d)(\\d{5})(\\d{4})","$1 $2 $3",["9"],"0$1"]],"0"],"MN":["976","001","[12]\\d{7,9}|[5-9]\\d{7}",[8,9,10],[["(\\d{2})(\\d{2})(\\d{4})","$1 $2 $3",["[12]1"],"0$1"],["(\\d{4})(\\d{4})","$1 $2",["[5-9]"]],["(\\d{3})(\\d{5,6})","$1 $2",["[12]2[1-3]"],"0$1"],["(\\d{4})(\\d{5,6})","$1 $2",["[12](?:27|3[2-8]|4[2-68]|5[1-4689])","[12](?:27|3[2-8]|4[2-68]|5[1-4689])[0-3]"],"0$1"],["(\\d{5})(\\d{4,5})","$1 $2",["[12]"],"0$1"]],"0"],"MO":["853","00","0800\\d{3}|(?:28|[68]\\d)\\d{6}",[7,8],[["(\\d{4})(\\d{3})","$1 $2",["0"]],["(\\d{4})(\\d{4})","$1 $2",["[268]"]]]],"MP":["1","011","[58]\\d{9}|(?:67|90)0\\d{7}",[10],0,"1",0,"([2-9]\\d{6})$|1","670$1",0,"670"],"MQ":["596","00","(?:596\\d|7091)\\d{5}|(?:69|[89]\\d)\\d{7}",[9],[["(\\d{3})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[5-79]|8(?:0[6-9]|[36])"],"0$1"],["(\\d{3})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["8"],"0$1"]],"0"],"MR":["222","00","(?:[2-4]\\d\\d|800)\\d{5}",[8],[["(\\d{2})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[2-48]"]]]],"MS":["1","011","(?:[58]\\d\\d|664|900)\\d{7}",[10],0,"1",0,"([34]\\d{6})$|1","664$1",0,"664"],"MT":["356","00","3550\\d{4}|(?:[2579]\\d\\d|800)\\d{5}",[8],[["(\\d{4})(\\d{4})","$1 $2",["[2357-9]"]]]],"MU":["230","0(?:0|[24-7]0|3[03])","(?:[57]|8\\d\\d)\\d{7}|[2-468]\\d{6}",[7,8,10],[["(\\d{3})(\\d{4})","$1 $2",["[2-46]|8[013]"]],["(\\d{4})(\\d{4})","$1 $2",["[57]"]],["(\\d{5})(\\d{5})","$1 $2",["8"]]],0,0,0,0,0,0,0,"020"],"MV":["960","0(?:0|19)","(?:800|9[0-57-9]\\d)\\d{7}|[34679]\\d{6}",[7,10],[["(\\d{3})(\\d{4})","$1-$2",["[34679]"]],["(\\d{3})(\\d{3})(\\d{4})","$1 $2 $3",["[89]"]]],0,0,0,0,0,0,0,"00"],"MW":["265","00","(?:[1289]\\d|31|77)\\d{7}|1\\d{6}",[7,9],[["(\\d)(\\d{3})(\\d{3})","$1 $2 $3",["1[2-9]"],"0$1"],["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["2"],"0$1"],["(\\d{3})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[137-9]"],"0$1"]],"0"],"MX":["52","0[09]","[2-9]\\d{9}",[10],[["(\\d{2})(\\d{4})(\\d{4})","$1 $2 $3",["33|5[56]|81"]],["(\\d{3})(\\d{3})(\\d{4})","$1 $2 $3",["[2-9]"]]],0,0,0,0,0,0,0,"00"],"MY":["60","00","1\\d{8,9}|(?:3\\d|[4-9])\\d{7}",[8,9,10],[["(\\d)(\\d{3})(\\d{4})","$1-$2 $3",["[4-79]"],"0$1"],["(\\d{2})(\\d{3})(\\d{3,4})","$1-$2 $3",["1(?:[02469]|[378][1-9]|53)|8","1(?:[02469]|[37][1-9]|53|8(?:[1-46-9]|5[7-9]))|8"],"0$1"],["(\\d)(\\d{4})(\\d{4})","$1-$2 $3",["3"],"0$1"],["(\\d)(\\d{3})(\\d{2})(\\d{4})","$1-$2-$3-$4",["1(?:[367]|80)"]],["(\\d{3})(\\d{3})(\\d{4})","$1-$2 $3",["15"],"0$1"],["(\\d{2})(\\d{4})(\\d{4})","$1-$2 $3",["1"],"0$1"]],"0"],"MZ":["258","00","(?:2|8\\d)\\d{7}",[8,9],[["(\\d{2})(\\d{3})(\\d{3,4})","$1 $2 $3",["2|8[2-79]"]],["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["8"]]]],"NA":["264","00","[68]\\d{7,8}",[8,9],[["(\\d{2})(\\d{3})(\\d{3})","$1 $2 $3",["88"],"0$1"],["(\\d{2})(\\d{3})(\\d{3,4})","$1 $2 $3",["6"],"0$1"],["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["87"],"0$1"],["(\\d{2})(\\d{3})(\\d{4})","$1 $2 $3",["8"],"0$1"]],"0"],"NC":["687","00","(?:050|[2-57-9]\\d\\d)\\d{3}",[6],[["(\\d{2})(\\d{2})(\\d{2})","$1.$2.$3",["[02-57-9]"]]]],"NE":["227","00","[027-9]\\d{7}",[8],[["(\\d{2})(\\d{3})(\\d{3})","$1 $2 $3",["08"]],["(\\d{2})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[089]|2[013]|7[0467]"]]]],"NF":["672","00","[13]\\d{5}",[6],[["(\\d{2})(\\d{4})","$1 $2",["1[0-3]"]],["(\\d)(\\d{5})","$1 $2",["[13]"]]],0,0,"([0-258]\\d{4})$","3$1"],"NG":["234","009","(?:20|9\\d)\\d{8}|[78]\\d{9,13}",[10,11,12,13,14],[["(\\d{3})(\\d{3})(\\d{3,4})","$1 $2 $3",["[7-9]"],"0$1"],["(\\d{3})(\\d{3})(\\d{4})","$1 $2 $3",["20[129]"],"0$1"],["(\\d{4})(\\d{2})(\\d{4})","$1 $2 $3",["2"],"0$1"],["(\\d{3})(\\d{4})(\\d{4,5})","$1 $2 $3",["[78]"],"0$1"],["(\\d{3})(\\d{5})(\\d{5,6})","$1 $2 $3",["[78]"],"0$1"]],"0"],"NI":["505","00","(?:1800|[25-8]\\d{3})\\d{4}",[8],[["(\\d{4})(\\d{4})","$1 $2",["[125-8]"]]]],"NL":["31","00","(?:[124-7]\\d\\d|3(?:[02-9]\\d|1[0-8]))\\d{6}|8\\d{6,9}|9\\d{6,10}|1\\d{4,5}",[5,6,7,8,9,10,11],[["(\\d{3})(\\d{4,7})","$1 $2",["[89]0"],"0$1"],["(\\d{2})(\\d{7})","$1 $2",["66"],"0$1"],["(\\d)(\\d{8})","$1 $2",["6"],"0$1"],["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["1[16-8]|2[259]|3[124]|4[17-9]|5[124679]"],"0$1"],["(\\d{2})(\\d{3})(\\d{4})","$1 $2 $3",["[1-578]|91"],"0$1"],["(\\d{3})(\\d{3})(\\d{5})","$1 $2 $3",["9"],"0$1"]],"0"],"NO":["47","00","(?:0|[2-9]\\d{3})\\d{4}",[5,8],[["(\\d{3})(\\d{2})(\\d{3})","$1 $2 $3",["8"]],["(\\d{2})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[2-79]"]]],0,0,0,0,0,"[02-689]|7[0-8]"],"NP":["977","00","(?:1\\d|9)\\d{9}|[1-9]\\d{7}",[8,10,11],[["(\\d)(\\d{7})","$1-$2",["1[2-6]"],"0$1"],["(\\d{2})(\\d{6})","$1-$2",["1[01]|[2-8]|9(?:[1-59]|[67][2-6])"],"0$1"],["(\\d{3})(\\d{7})","$1-$2",["9"]]],"0"],"NR":["674","00","(?:222|444|(?:55|8\\d)\\d|666|777|999)\\d{4}",[7],[["(\\d{3})(\\d{4})","$1 $2",["[24-9]"]]]],"NU":["683","00","(?:[4-7]|888\\d)\\d{3}",[4,7],[["(\\d{3})(\\d{4})","$1 $2",["8"]]]],"NZ":["64","0(?:0|161)","[1289]\\d{9}|50\\d{5}(?:\\d{2,3})?|[27-9]\\d{7,8}|(?:[34]\\d|6[0-35-9])\\d{6}|8\\d{4,6}",[5,6,7,8,9,10],[["(\\d{2})(\\d{3,8})","$1 $2",["8[1-79]"],"0$1"],["(\\d{3})(\\d{2})(\\d{2,3})","$1 $2 $3",["50[036-8]|8|90","50(?:[0367]|88)|8|90"],"0$1"],["(\\d)(\\d{3})(\\d{4})","$1 $2 $3",["24|[346]|7[2-57-9]|9[2-9]"],"0$1"],["(\\d{3})(\\d{3})(\\d{3,4})","$1 $2 $3",["2(?:10|74)|[589]"],"0$1"],["(\\d{2})(\\d{3,4})(\\d{4})","$1 $2 $3",["1|2[028]"],"0$1"],["(\\d{2})(\\d{3})(\\d{3,5})","$1 $2 $3",["2(?:[169]|7[0-35-9])|7"],"0$1"]],"0",0,0,0,0,0,0,"00"],"OM":["968","00","(?:1505|[279]\\d{3}|500)\\d{4}|800\\d{5,6}",[7,8,9],[["(\\d{3})(\\d{4,6})","$1 $2",["[58]"]],["(\\d{2})(\\d{6})","$1 $2",["2"]],["(\\d{4})(\\d{4})","$1 $2",["[179]"]]]],"PA":["507","00","(?:00800|8\\d{3})\\d{6}|[68]\\d{7}|[1-57-9]\\d{6}",[7,8,10,11],[["(\\d{3})(\\d{4})","$1-$2",["[1-57-9]"]],["(\\d{4})(\\d{4})","$1-$2",["[68]"]],["(\\d{3})(\\d{3})(\\d{4})","$1 $2 $3",["8"]]]],"PE":["51","00|19(?:1[124]|77|90)00","(?:[14-8]|9\\d)\\d{7}",[8,9],[["(\\d{3})(\\d{5})","$1 $2",["80"],"(0$1)"],["(\\d)(\\d{7})","$1 $2",["1"],"(0$1)"],["(\\d{2})(\\d{6})","$1 $2",["[4-8]"],"(0$1)"],["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["9"]]],"0",0,0,0,0,0,0,"00"," Anexo "],"PF":["689","00","4\\d{5}(?:\\d{2})?|8\\d{7,8}",[6,8,9],[["(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3",["44"]],["(\\d{2})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["4|8[7-9]"]],["(\\d{3})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["8"]]]],"PG":["675","00|140[1-3]","(?:180|[78]\\d{3})\\d{4}|(?:[2-589]\\d|64)\\d{5}",[7,8],[["(\\d{3})(\\d{4})","$1 $2",["18|[2-69]|85"]],["(\\d{4})(\\d{4})","$1 $2",["[78]"]]],0,0,0,0,0,0,0,"00"],"PH":["63","00","(?:[2-7]|9\\d)\\d{8}|2\\d{5}|(?:1800|8)\\d{7,9}",[6,8,9,10,11,12,13],[["(\\d)(\\d{5})","$1 $2",["2"],"(0$1)"],["(\\d{4})(\\d{4,6})","$1 $2",["3(?:23|39|46)|4(?:2[3-6]|[35]9|4[26]|76)|544|88[245]|(?:52|64|86)2","3(?:230|397|461)|4(?:2(?:35|[46]4|51)|396|4(?:22|63)|59[347]|76[15])|5(?:221|446)|642[23]|8(?:622|8(?:[24]2|5[13]))"],"(0$1)"],["(\\d{5})(\\d{4})","$1 $2",["346|4(?:27|9[35])|883","3469|4(?:279|9(?:30|56))|8834"],"(0$1)"],["(\\d)(\\d{4})(\\d{4})","$1 $2 $3",["2"],"(0$1)"],["(\\d{2})(\\d{3})(\\d{4})","$1 $2 $3",["[3-7]|8[2-8]"],"(0$1)"],["(\\d{3})(\\d{3})(\\d{4})","$1 $2 $3",["[89]"],"0$1"],["(\\d{4})(\\d{3})(\\d{4})","$1 $2 $3",["1"]],["(\\d{4})(\\d{1,2})(\\d{3})(\\d{4})","$1 $2 $3 $4",["1"]]],"0"],"PK":["92","00","122\\d{6}|[24-8]\\d{10,11}|9(?:[013-9]\\d{8,10}|2(?:[01]\\d\\d|2(?:[06-8]\\d|1[01]))\\d{7})|(?:[2-8]\\d{3}|92(?:[0-7]\\d|8[1-9]))\\d{6}|[24-9]\\d{8}|[89]\\d{7}",[8,9,10,11,12],[["(\\d{3})(\\d{3})(\\d{2,7})","$1 $2 $3",["[89]0"],"0$1"],["(\\d{4})(\\d{5})","$1 $2",["1"]],["(\\d{3})(\\d{6,7})","$1 $2",["2(?:3[2358]|4[2-4]|9[2-8])|45[3479]|54[2-467]|60[468]|72[236]|8(?:2[2-689]|3[23578]|4[3478]|5[2356])|9(?:2[2-8]|3[27-9]|4[2-6]|6[3569]|9[25-8])","9(?:2[3-8]|98)|(?:2(?:3[2358]|4[2-4]|9[2-8])|45[3479]|54[2-467]|60[468]|72[236]|8(?:2[2-689]|3[23578]|4[3478]|5[2356])|9(?:22|3[27-9]|4[2-6]|6[3569]|9[25-7]))[2-9]"],"(0$1)"],["(\\d{2})(\\d{7,8})","$1 $2",["(?:2[125]|4[0-246-9]|5[1-35-7]|6[1-8]|7[14]|8[16]|91)[2-9]"],"(0$1)"],["(\\d{5})(\\d{5})","$1 $2",["58"],"(0$1)"],["(\\d{3})(\\d{7})","$1 $2",["3"],"0$1"],["(\\d{2})(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3 $4",["2[125]|4[0-246-9]|5[1-35-7]|6[1-8]|7[14]|8[16]|91"],"(0$1)"],["(\\d{3})(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3 $4",["[24-9]"],"(0$1)"]],"0"],"PL":["48","00","(?:6|8\\d\\d)\\d{7}|[1-9]\\d{6}(?:\\d{2})?|[26]\\d{5}",[6,7,8,9,10],[["(\\d{5})","$1",["19"]],["(\\d{3})(\\d{3})","$1 $2",["11|20|64"]],["(\\d{2})(\\d{2})(\\d{3})","$1 $2 $3",["(?:1[2-8]|2[2-69]|3[2-4]|4[1-468]|5[24-689]|6[1-3578]|7[14-7]|8[1-79]|9[145])1","(?:1[2-8]|2[2-69]|3[2-4]|4[1-468]|5[24-689]|6[1-3578]|7[14-7]|8[1-79]|9[145])19"]],["(\\d{3})(\\d{2})(\\d{2,3})","$1 $2 $3",["64"]],["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["21|39|45|5[0137]|6[0469]|7[02389]|8(?:0[14]|8)"]],["(\\d{2})(\\d{3})(\\d{2})(\\d{2})","$1 $2 $3 $4",["1[2-8]|[2-7]|8[1-79]|9[145]"]],["(\\d{3})(\\d{3})(\\d{3,4})","$1 $2 $3",["8"]]]],"PM":["508","00","[45]\\d{5}|(?:708|8\\d\\d)\\d{6}",[6,9],[["(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3",["[45]"],"0$1"],["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["7"]],["(\\d{3})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["8"],"0$1"]],"0"],"PR":["1","011","(?:[589]\\d\\d|787)\\d{7}",[10],0,"1",0,0,0,0,"787|939"],"PS":["970","00","[2489]2\\d{6}|(?:1\\d|5)\\d{8}",[8,9,10],[["(\\d)(\\d{3})(\\d{4})","$1 $2 $3",["[2489]"],"0$1"],["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["5"],"0$1"],["(\\d{4})(\\d{3})(\\d{3})","$1 $2 $3",["1"]]],"0"],"PT":["351","00","1693\\d{5}|(?:[26-9]\\d|30)\\d{7}",[9],[["(\\d{2})(\\d{3})(\\d{4})","$1 $2 $3",["2[12]"]],["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["16|[236-9]"]]]],"PW":["680","01[12]","(?:[24-8]\\d\\d|345|900)\\d{4}",[7],[["(\\d{3})(\\d{4})","$1 $2",["[2-9]"]]]],"PY":["595","00","59\\d{4,6}|9\\d{5,10}|(?:[2-46-8]\\d|5[0-8])\\d{4,7}",[6,7,8,9,10,11],[["(\\d{3})(\\d{3,6})","$1 $2",["[2-9]0"],"0$1"],["(\\d{2})(\\d{5})","$1 $2",["[26]1|3[289]|4[1246-8]|7[1-3]|8[1-36]"],"(0$1)"],["(\\d{3})(\\d{4,5})","$1 $2",["2[279]|3[13-5]|4[359]|5|6(?:[34]|7[1-46-8])|7[46-8]|85"],"(0$1)"],["(\\d{2})(\\d{3})(\\d{3,4})","$1 $2 $3",["2[14-68]|3[26-9]|4[1246-8]|6(?:1|75)|7[1-35]|8[1-36]"],"(0$1)"],["(\\d{2})(\\d{3})(\\d{4})","$1 $2 $3",["87"]],["(\\d{3})(\\d{6})","$1 $2",["9(?:[5-79]|8[1-7])"],"0$1"],["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["[2-8]"],"0$1"],["(\\d{4})(\\d{3})(\\d{4})","$1 $2 $3",["9"]]],"0"],"QA":["974","00","800\\d{4}|(?:2|800)\\d{6}|(?:0080|[3-7])\\d{7}",[7,8,9,11],[["(\\d{3})(\\d{4})","$1 $2",["2[136]|8"]],["(\\d{4})(\\d{4})","$1 $2",["[3-7]"]]]],"RE":["262","00","709\\d{6}|(?:26|[689]\\d)\\d{7}",[9],[["(\\d{3})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[26-9]"],"0$1"]],"0",0,0,0,0,0,[["26(?:2\\d\\d|3(?:0\\d|1[0-6]))\\d{4}"],["(?:69(?:2\\d\\d|3(?:[06][0-6]|1[0-3]|2[0-2]|3[0-39]|4\\d|5[0-5]|7[0-37]|8[0-8]|9[0-479]))|7092[0-3])\\d{4}"],["80\\d{7}"],["89[1-37-9]\\d{6}"],0,0,0,0,["9(?:399[0-3]|479[0-6]|76(?:2[278]|3[0-37]))\\d{4}"],["8(?:1[019]|2[0156]|84|90)\\d{6}"]]],"RO":["40","00","(?:[236-8]\\d|90)\\d{7}|[23]\\d{5}",[6,9],[["(\\d{3})(\\d{3})","$1 $2",["2[3-6]","2[3-6]\\d9"],"0$1"],["(\\d{2})(\\d{4})","$1 $2",["219|31"],"0$1"],["(\\d{2})(\\d{3})(\\d{4})","$1 $2 $3",["[23]1"],"0$1"],["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["[236-9]"],"0$1"]],"0",0,0,0,0,0,0,0," int "],"RS":["381","00","38[02-9]\\d{6,9}|6\\d{7,9}|90\\d{4,8}|38\\d{5,6}|(?:7\\d\\d|800)\\d{3,9}|(?:[12]\\d|3[0-79])\\d{5,10}",[6,7,8,9,10,11,12],[["(\\d{3})(\\d{3,9})","$1 $2",["(?:2[389]|39)0|[7-9]"],"0$1"],["(\\d{2})(\\d{5,10})","$1 $2",["[1-36]"],"0$1"]],"0"],"RU":["7","810","8\\d{13}|[347-9]\\d{9}",[10,14],[["(\\d{4})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["7(?:1[0-8]|2[1-9])","7(?:1(?:[0-356]2|4[29]|7|8[27])|2(?:1[23]|[2-9]2))","7(?:1(?:[0-356]2|4[29]|7|8[27])|2(?:13[03-69]|62[013-9]))|72[1-57-9]2"],"8 ($1)",1],["(\\d{5})(\\d)(\\d{2})(\\d{2})","$1 $2 $3 $4",["7(?:1[0-68]|2[1-9])","7(?:1(?:[06][3-6]|[18]|2[35]|[3-5][3-5])|2(?:[13][3-5]|[24-689]|7[457]))","7(?:1(?:0(?:[356]|4[023])|[18]|2(?:3[013-9]|5)|3[45]|43[013-79]|5(?:3[1-8]|4[1-7]|5)|6(?:3[0-35-9]|[4-6]))|2(?:1(?:3[178]|[45])|[24-689]|3[35]|7[457]))|7(?:14|23)4[0-8]|71(?:33|45)[1-79]"],"8 ($1)",1],["(\\d{3})(\\d{3})(\\d{4})","$1 $2 $3",["7"],"8 ($1)",1],["(\\d{3})(\\d{3})(\\d{2})(\\d{2})","$1 $2-$3-$4",["[349]|8(?:[02-7]|1[1-8])"],"8 ($1)",1],["(\\d{4})(\\d{4})(\\d{3})(\\d{3})","$1 $2 $3 $4",["8"],"8 ($1)"]],"8",0,0,0,0,0,[["336(?:[013-9]\\d|2[013-9])\\d{5}|(?:3(?:0[12]|4[1-35-79]|5[1-3]|65|8[1-58]|9[0145])|4(?:01|1[1356]|2[13467]|7[1-5]|8[1-7]|9[1-689])|8(?:1[1-8]|2[01]|3[13-6]|4[0-8]|5[15-7]|6[0-35-79]|7[1-37-9]))\\d{7}",[10]],["9\\d{9}",[10]],["8(?:0[04]|108\\d{3})\\d{7}"],["80[39]\\d{7}",[10]],["808\\d{7}",[10]]],"8~10"],"RW":["250","00","(?:06|[27]\\d\\d|[89]00)\\d{6}",[8,9],[["(\\d{2})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["0"]],["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["2"]],["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["[7-9]"],"0$1"]],"0"],"SA":["966","00","(?:[15]\\d|800|92)\\d{7}",[9,10],[["(\\d{4})(\\d{5})","$1 $2",["9"]],["(\\d{2})(\\d{3})(\\d{4})","$1 $2 $3",["1"],"0$1"],["(\\d{2})(\\d{3})(\\d{4})","$1 $2 $3",["5"],"0$1"],["(\\d{3})(\\d{3})(\\d{4})","$1 $2 $3",["8"]]],"0"],"SB":["677","0[01]","[6-9]\\d{6}|[1-6]\\d{4}",[5,7],[["(\\d{2})(\\d{5})","$1 $2",["6[89]|7|8[4-9]|9(?:[1-8]|9[0-8])"]]]],"SC":["248","010|0[0-2]","(?:[2489]\\d|64)\\d{5}",[7],[["(\\d)(\\d{3})(\\d{3})","$1 $2 $3",["[246]|9[57]"]]],0,0,0,0,0,0,0,"00"],"SD":["249","00","[19]\\d{8}",[9],[["(\\d{2})(\\d{3})(\\d{4})","$1 $2 $3",["[19]"],"0$1"]],"0"],"SE":["46","00","(?:[26]\\d\\d|9)\\d{9}|[1-9]\\d{8}|[1-689]\\d{7}|[1-4689]\\d{6}|2\\d{5}",[6,7,8,9,10,12],[["(\\d{2})(\\d{2,3})(\\d{2})","$1-$2 $3",["20"],"0$1",0,"$1 $2 $3"],["(\\d{3})(\\d{4})","$1-$2",["9(?:00|39|44|9)"],"0$1",0,"$1 $2"],["(\\d{2})(\\d{3})(\\d{2})","$1-$2 $3",["[12][136]|3[356]|4[0246]|6[03]|90[1-9]"],"0$1",0,"$1 $2 $3"],["(\\d)(\\d{2,3})(\\d{2})(\\d{2})","$1-$2 $3 $4",["8"],"0$1",0,"$1 $2 $3 $4"],["(\\d{3})(\\d{2,3})(\\d{2})","$1-$2 $3",["1[2457]|2(?:[247-9]|5[0138])|3[0247-9]|4[1357-9]|5[0-35-9]|6(?:[125689]|4[02-57]|7[0-2])|9(?:[125-8]|3[02-5]|4[0-3])"],"0$1",0,"$1 $2 $3"],["(\\d{3})(\\d{2,3})(\\d{3})","$1-$2 $3",["9(?:00|39|44)"],"0$1",0,"$1 $2 $3"],["(\\d{2})(\\d{2,3})(\\d{2})(\\d{2})","$1-$2 $3 $4",["1[13689]|2[0136]|3[1356]|4[0246]|54|6[03]|90[1-9]"],"0$1",0,"$1 $2 $3 $4"],["(\\d{2})(\\d{3})(\\d{2})(\\d{2})","$1-$2 $3 $4",["10|7"],"0$1",0,"$1 $2 $3 $4"],["(\\d)(\\d{3})(\\d{3})(\\d{2})","$1-$2 $3 $4",["8"],"0$1",0,"$1 $2 $3 $4"],["(\\d{3})(\\d{2})(\\d{2})(\\d{2})","$1-$2 $3 $4",["[13-5]|2(?:[247-9]|5[0138])|6(?:[124-689]|7[0-2])|9(?:[125-8]|3[02-5]|4[0-3])"],"0$1",0,"$1 $2 $3 $4"],["(\\d{3})(\\d{2})(\\d{2})(\\d{3})","$1-$2 $3 $4",["9"],"0$1",0,"$1 $2 $3 $4"],["(\\d{3})(\\d{2})(\\d{3})(\\d{2})(\\d{2})","$1-$2 $3 $4 $5",["[26]"],"0$1",0,"$1 $2 $3 $4 $5"]],"0"],"SG":["65","0[0-3]\\d","(?:(?:1\\d|8)\\d\\d|7000)\\d{7}|[3689]\\d{7}",[8,10,11],[["(\\d{4})(\\d{4})","$1 $2",["[369]|8(?:0[1-9]|[1-9])"]],["(\\d{3})(\\d{3})(\\d{4})","$1 $2 $3",["8"]],["(\\d{4})(\\d{4})(\\d{3})","$1 $2 $3",["7"]],["(\\d{4})(\\d{3})(\\d{4})","$1 $2 $3",["1"]]]],"SH":["290","00","(?:[256]\\d|8)\\d{3}",[4,5],0,0,0,0,0,0,"[256]"],"SI":["386","00|10(?:22|66|88|99)","[1-7]\\d{7}|8\\d{4,7}|90\\d{4,6}",[5,6,7,8],[["(\\d{2})(\\d{3,6})","$1 $2",["8[09]|9"],"0$1"],["(\\d{3})(\\d{5})","$1 $2",["59|8"],"0$1"],["(\\d{2})(\\d{3})(\\d{3})","$1 $2 $3",["[37][01]|4[0139]|51|6"],"0$1"],["(\\d)(\\d{3})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[1-57]"],"(0$1)"]],"0",0,0,0,0,0,0,"00"],"SJ":["47","00","0\\d{4}|(?:[489]\\d|79)\\d{6}",[5,8],0,0,0,0,0,0,"79"],"SK":["421","00","[2-689]\\d{8}|[2-59]\\d{6}|[2-5]\\d{5}",[6,7,9],[["(\\d)(\\d{2})(\\d{3,4})","$1 $2 $3",["21"],"0$1"],["(\\d{2})(\\d{2})(\\d{2,3})","$1 $2 $3",["[3-5][1-8]1","[3-5][1-8]1[67]"],"0$1"],["(\\d)(\\d{3})(\\d{3})(\\d{2})","$1/$2 $3 $4",["2"],"0$1"],["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["[689]"],"0$1"],["(\\d{2})(\\d{3})(\\d{2})(\\d{2})","$1/$2 $3 $4",["[3-5]"],"0$1"]],"0"],"SL":["232","00","(?:[237-9]\\d|66)\\d{6}",[8],[["(\\d{2})(\\d{6})","$1 $2",["[236-9]"],"(0$1)"]],"0"],"SM":["378","00","(?:0549|[5-7]\\d)\\d{6}",[8,10],[["(\\d{2})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[5-7]"]],["(\\d{4})(\\d{6})","$1 $2",["0"]]],0,0,"([89]\\d{5})$","0549$1"],"SN":["221","00","(?:[378]\\d|93)\\d{7}",[9],[["(\\d{3})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["8"]],["(\\d{2})(\\d{3})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[379]"]]]],"SO":["252","00","[346-9]\\d{8}|[12679]\\d{7}|[1-5]\\d{6}|[1348]\\d{5}",[6,7,8,9],[["(\\d{2})(\\d{4})","$1 $2",["8[125]"]],["(\\d{6})","$1",["[134]"]],["(\\d)(\\d{6})","$1 $2",["[15]|2[0-79]|3[0-46-8]|4[0-7]"]],["(\\d)(\\d{7})","$1 $2",["(?:2|90)4|[67]"]],["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["[348]|64|79|90"]],["(\\d{2})(\\d{5,7})","$1 $2",["1|28|6[0-35-9]|7[67]|9[2-9]"]]],"0"],"SR":["597","00","(?:[2-5]|[6-8]\\d|90)\\d{5}",[6,7],[["(\\d{2})(\\d{2})(\\d{2})","$1-$2-$3",["56"]],["(\\d{3})(\\d{3})","$1-$2",["[2-5]"]],["(\\d{3})(\\d{4})","$1-$2",["[6-9]"]]]],"SS":["211","00","[19]\\d{8}",[9],[["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["[19]"],"0$1"]],"0"],"ST":["239","00","(?:22|9\\d)\\d{5}",[7],[["(\\d{3})(\\d{4})","$1 $2",["[29]"]]]],"SV":["503","00","[267]\\d{7}|(?:80\\d|900)\\d{4}(?:\\d{4})?",[7,8,11],[["(\\d{3})(\\d{4})","$1 $2",["[89]"]],["(\\d{4})(\\d{4})","$1 $2",["[267]"]],["(\\d{3})(\\d{4})(\\d{4})","$1 $2 $3",["[89]"]]]],"SX":["1","011","7215\\d{6}|(?:[58]\\d\\d|900)\\d{7}",[10],0,"1",0,"(5\\d{6})$|1","721$1",0,"721"],"SY":["963","00","[1-359]\\d{8}|[1-5]\\d{7}",[8,9],[["(\\d{2})(\\d{3})(\\d{3,4})","$1 $2 $3",["[1-4]|5[1-3]"],"0$1",1],["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["[59]"],"0$1",1]],"0"],"SZ":["268","00","0800\\d{4}|(?:[237]\\d|900)\\d{6}",[8,9],[["(\\d{4})(\\d{4})","$1 $2",["[0237]"]],["(\\d{5})(\\d{4})","$1 $2",["9"]]]],"TA":["290","00","8\\d{3}",[4],0,0,0,0,0,0,"8"],"TC":["1","011","(?:[58]\\d\\d|649|900)\\d{7}",[10],0,"1",0,"([2-479]\\d{6})$|1","649$1",0,"649"],"TD":["235","00|16","(?:22|30|[689]\\d|77)\\d{6}",[8],[["(\\d{2})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[236-9]"]]],0,0,0,0,0,0,0,"00"],"TG":["228","00","[279]\\d{7}",[8],[["(\\d{2})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[279]"]]]],"TH":["66","00[1-9]","(?:001800|[2-57]|[689]\\d)\\d{7}|1\\d{7,9}",[8,9,10,13],[["(\\d)(\\d{3})(\\d{4})","$1 $2 $3",["2"],"0$1"],["(\\d{2})(\\d{3})(\\d{3,4})","$1 $2 $3",["[13-9]"],"0$1"],["(\\d{4})(\\d{3})(\\d{3})","$1 $2 $3",["1"]]],"0"],"TJ":["992","810","[0-57-9]\\d{8}",[9],[["(\\d{6})(\\d)(\\d{2})","$1 $2 $3",["331","3317"]],["(\\d{3})(\\d{2})(\\d{4})","$1 $2 $3",["44[02-479]|[34]7"]],["(\\d{4})(\\d)(\\d{4})","$1 $2 $3",["3(?:[1245]|3[12])"]],["(\\d{2})(\\d{3})(\\d{4})","$1 $2 $3",["[0-57-9]"]]],0,0,0,0,0,0,0,"8~10"],"TK":["690","00","[2-47]\\d{3,6}",[4,5,6,7]],"TL":["670","00","7\\d{7}|(?:[2-47]\\d|[89]0)\\d{5}",[7,8],[["(\\d{3})(\\d{4})","$1 $2",["[2-489]|70"]],["(\\d{4})(\\d{4})","$1 $2",["7"]]]],"TM":["993","810","(?:[1-6]\\d|71)\\d{6}",[8],[["(\\d{2})(\\d{2})(\\d{2})(\\d{2})","$1 $2-$3-$4",["12"],"(8 $1)"],["(\\d{3})(\\d)(\\d{2})(\\d{2})","$1 $2-$3-$4",["[1-5]"],"(8 $1)"],["(\\d{2})(\\d{6})","$1 $2",["[67]"],"8 $1"]],"8",0,0,0,0,0,0,"8~10"],"TN":["216","00","[2-57-9]\\d{7}",[8],[["(\\d{2})(\\d{3})(\\d{3})","$1 $2 $3",["[2-57-9]"]]]],"TO":["676","00","(?:0800|(?:[5-8]\\d\\d|999)\\d)\\d{3}|[2-8]\\d{4}",[5,7],[["(\\d{2})(\\d{3})","$1-$2",["[2-4]|50|6[09]|7[0-24-69]|8[05]"]],["(\\d{4})(\\d{3})","$1 $2",["0"]],["(\\d{3})(\\d{4})","$1 $2",["[5-9]"]]]],"TR":["90","00","4\\d{6}|8\\d{11,12}|(?:[2-58]\\d\\d|900)\\d{7}",[7,10,12,13],[["(\\d{3})(\\d{3})(\\d{4})","$1 $2 $3",["512|8[01589]|90"],"0$1",1],["(\\d{3})(\\d{3})(\\d{2})(\\d{2})","$1 $2 $3 $4",["5(?:[0-59]|61)","5(?:[0-59]|61[06])","5(?:[0-59]|61[06]1)"],"0$1",1],["(\\d{3})(\\d{3})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[24][1-8]|3[1-9]"],"(0$1)",1],["(\\d{3})(\\d{3})(\\d{6,7})","$1 $2 $3",["80"],"0$1",1]],"0"],"TT":["1","011","(?:[58]\\d\\d|900)\\d{7}",[10],0,"1",0,"([2-46-8]\\d{6})$|1","868$1",0,"868"],"TV":["688","00","(?:2|7\\d\\d|90)\\d{4}",[5,6,7],[["(\\d{2})(\\d{3})","$1 $2",["2"]],["(\\d{2})(\\d{4})","$1 $2",["90"]],["(\\d{2})(\\d{5})","$1 $2",["7"]]]],"TW":["886","0(?:0[25-79]|19)","[2-689]\\d{8}|7\\d{9,10}|[2-8]\\d{7}|2\\d{6}",[7,8,9,10,11],[["(\\d{2})(\\d)(\\d{4})","$1 $2 $3",["202"],"0$1"],["(\\d{2})(\\d{3})(\\d{3,4})","$1 $2 $3",["[258]0"],"0$1"],["(\\d)(\\d{3,4})(\\d{4})","$1 $2 $3",["[23568]|4(?:0[02-48]|[1-47-9])|7[1-9]","[23568]|4(?:0[2-48]|[1-47-9])|(?:400|7)[1-9]"],"0$1"],["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["[49]"],"0$1"],["(\\d{2})(\\d{4})(\\d{4,5})","$1 $2 $3",["7"],"0$1"]],"0",0,0,0,0,0,0,0,"#"],"TZ":["255","00[056]","(?:[25-8]\\d|41|90)\\d{7}",[9],[["(\\d{3})(\\d{2})(\\d{4})","$1 $2 $3",["[89]"],"0$1"],["(\\d{2})(\\d{3})(\\d{4})","$1 $2 $3",["[24]"],"0$1"],["(\\d{2})(\\d{7})","$1 $2",["5"]],["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["[67]"],"0$1"]],"0"],"UA":["380","00","[89]\\d{9}|[3-9]\\d{8}",[9,10],[["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["6[12][29]|(?:3[1-8]|4[136-8]|5[12457]|6[49])2|(?:56|65)[24]","6[12][29]|(?:35|4[1378]|5[12457]|6[49])2|(?:56|65)[24]|(?:3[1-46-8]|46)2[013-9]"],"0$1"],["(\\d{4})(\\d{5})","$1 $2",["3[1-8]|4(?:[1367]|[45][6-9]|8[4-6])|5(?:[1-5]|6[0135689]|7[4-6])|6(?:[12][3-7]|[459])","3[1-8]|4(?:[1367]|[45][6-9]|8[4-6])|5(?:[1-5]|6(?:[015689]|3[02389])|7[4-6])|6(?:[12][3-7]|[459])"],"0$1"],["(\\d{2})(\\d{3})(\\d{4})","$1 $2 $3",["[3-7]|89|9[1-9]"],"0$1"],["(\\d{3})(\\d{3})(\\d{3,4})","$1 $2 $3",["[89]"],"0$1"]],"0",0,0,0,0,0,0,"0~0"],"UG":["256","00[057]","800\\d{6}|(?:[29]0|[347]\\d)\\d{7}",[9],[["(\\d{4})(\\d{5})","$1 $2",["202","2024"],"0$1"],["(\\d{3})(\\d{6})","$1 $2",["[27-9]|4(?:6[45]|[7-9])"],"0$1"],["(\\d{2})(\\d{7})","$1 $2",["[34]"],"0$1"]],"0"],"US":["1","011","[2-9]\\d{9}|3\\d{6}",[10],[["(\\d{3})(\\d{4})","$1-$2",["310"],0,1],["(\\d{3})(\\d{3})(\\d{4})","($1) $2-$3",["[2-9]"],0,1,"$1-$2-$3"]],"1",0,0,0,0,0,[["3052(?:0[0-8]|[1-9]\\d)\\d{4}|(?:2742|305[3-9])\\d{6}|(?:472|983)[2-47-9]\\d{6}|(?:2(?:0[1-35-9]|1[02-9]|2[03-57-9]|3[1459]|4[08]|5[1-46]|6[0279]|7[0269]|8[13])|3(?:0[1-47-9]|1[02-9]|2[013-79]|3[0-24679]|4[167]|5[0-2]|6[01349]|8[056])|4(?:0[124-9]|1[02-579]|2[3-5]|3[0245]|4[023578]|58|6[349]|7[0589]|8[04])|5(?:0[1-57-9]|1[0235-8]|20|3[0149]|4[01]|5[179]|6[1-47]|7[0-5]|8[0256])|6(?:0[1-35-9]|1[024-9]|2[03689]|3[016]|4[0156]|5[01679]|6[0-279]|78|8[0-269])|7(?:0[1-46-8]|1[2-9]|2[04-8]|3[0-247]|4[0378]|5[47]|6[02359]|7[0-59]|8[156])|8(?:0[1-68]|1[02-8]|2[0168]|3[0-2589]|4[03578]|5[046-9]|6[02-5]|7[028])|9(?:0[1346-9]|1[02-9]|2[0589]|3[0146-8]|4[01357-9]|5[12469]|7[0-3589]|8[04-69]))[2-9]\\d{6}"],[""],["8(?:00|33|44|55|66|77|88)[2-9]\\d{6}"],["900[2-9]\\d{6}"],["52(?:3(?:[2-46-9][02-9]\\d|5(?:[02-46-9]\\d|5[0-46-9]))|4(?:[2-478][02-9]\\d|5(?:[034]\\d|2[024-9]|5[0-46-9])|6(?:0[1-9]|[2-9]\\d)|9(?:[05-9]\\d|2[0-5]|49)))\\d{4}|52[34][2-9]1[02-9]\\d{4}|5(?:00|2[125-9]|33|44|66|77|88)[2-9]\\d{6}"],0,0,0,["305209\\d{4}"]]],"UY":["598","0(?:0|1[3-9]\\d)","0004\\d{2,9}|[1249]\\d{7}|2\\d{3,4}|(?:[49]\\d|80)\\d{5}",[4,5,6,7,8,9,10,11,12,13],[["(\\d{4,5})","$1",["21"]],["(\\d{3})(\\d{3,4})","$1 $2",["0"]],["(\\d{3})(\\d{4})","$1 $2",["[49]0|8"],"0$1"],["(\\d{2})(\\d{3})(\\d{3})","$1 $2 $3",["9"],"0$1"],["(\\d{4})(\\d{4})","$1 $2",["[124]"]],["(\\d{3})(\\d{3})(\\d{2,4})","$1 $2 $3",["0"]],["(\\d{3})(\\d{3})(\\d{3})(\\d{2,4})","$1 $2 $3 $4",["0"]]],"0",0,0,0,0,0,0,"00"," int. "],"UZ":["998","00","(?:20|33|[5-9]\\d)\\d{7}",[9],[["(\\d{2})(\\d{3})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[235-9]"]]]],"VA":["39","00","0\\d{5,10}|3[0-8]\\d{7,10}|55\\d{8}|8\\d{5}(?:\\d{2,4})?|(?:1\\d|39)\\d{7,8}",[6,7,8,9,10,11,12],0,0,0,0,0,0,"06698"],"VC":["1","011","(?:[58]\\d\\d|784|900)\\d{7}",[10],0,"1",0,"([2-7]\\d{6})$|1","784$1",0,"784"],"VE":["58","00","[68]00\\d{7}|(?:[24]\\d|[59]0)\\d{8}",[10],[["(\\d{3})(\\d{7})","$1-$2",["[24-689]"],"0$1"]],"0"],"VG":["1","011","(?:284|[58]\\d\\d|900)\\d{7}",[10],0,"1",0,"([2-578]\\d{6})$|1","284$1",0,"284"],"VI":["1","011","[58]\\d{9}|(?:34|90)0\\d{7}",[10],0,"1",0,"([2-9]\\d{6})$|1","340$1",0,"340"],"VN":["84","00","[12]\\d{9}|[135-9]\\d{8}|[16]\\d{7}|[16-8]\\d{6}",[7,8,9,10],[["(\\d{2})(\\d{5})","$1 $2",["80"],"0$1",1],["(\\d{4})(\\d{4,6})","$1 $2",["1"],0,1],["(\\d{2})(\\d{3})(\\d{2})(\\d{2})","$1 $2 $3 $4",["6"],"0$1",1],["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["[357-9]"],"0$1",1],["(\\d{2})(\\d{4})(\\d{4})","$1 $2 $3",["2[48]"],"0$1",1],["(\\d{3})(\\d{4})(\\d{3})","$1 $2 $3",["2"],"0$1",1]],"0"],"VU":["678","00","[57-9]\\d{6}|(?:[238]\\d|48)\\d{3}",[5,7],[["(\\d{3})(\\d{4})","$1 $2",["[57-9]"]]]],"WF":["681","00","(?:40|72|8\\d{4})\\d{4}|[89]\\d{5}",[6,9],[["(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3",["[47-9]"]],["(\\d{3})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["8"]]]],"WS":["685","0","(?:[2-6]|8\\d{5})\\d{4}|[78]\\d{6}|[68]\\d{5}",[5,6,7,10],[["(\\d{5})","$1",["[2-5]|6[1-9]"]],["(\\d{3})(\\d{3,7})","$1 $2",["[68]"]],["(\\d{2})(\\d{5})","$1 $2",["7"]]]],"XK":["383","00","2\\d{7,8}|3\\d{7,11}|(?:4\\d\\d|[89]00)\\d{5}",[8,9,10,11,12],[["(\\d{3})(\\d{5})","$1 $2",["[89]"],"0$1"],["(\\d{2})(\\d{3})(\\d{3})","$1 $2 $3",["[2-4]"],"0$1"],["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["2|39"],"0$1"],["(\\d{2})(\\d{7,10})","$1 $2",["3"],"0$1"]],"0"],"YE":["967","00","(?:1|7\\d)\\d{7}|[1-7]\\d{6}",[7,8,9],[["(\\d)(\\d{3})(\\d{3,4})","$1 $2 $3",["[1-6]|7(?:[24-6]|8[0-7])"],"0$1"],["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["7"],"0$1"]],"0"],"YT":["262","00","7093\\d{5}|(?:80|9\\d)\\d{7}|(?:26|63)9\\d{6}",[9],0,"0",0,0,0,0,0,[["269(?:0[0-467]|15|5[0-4]|6\\d|[78]0)\\d{4}"],["(?:639(?:0[0-79]|1[019]|[267]\\d|3[09]|40|5[05-9]|9[04-79])|7093[5-7])\\d{4}"],["80\\d{7}"],0,0,0,0,0,["9(?:(?:39|47)8[01]|769\\d)\\d{4}"]]],"ZA":["27","00","[1-79]\\d{8}|8\\d{4,9}",[5,6,7,8,9,10],[["(\\d{2})(\\d{3,4})","$1 $2",["8[1-4]"],"0$1"],["(\\d{2})(\\d{3})(\\d{2,3})","$1 $2 $3",["8[1-4]"],"0$1"],["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["860"],"0$1"],["(\\d{2})(\\d{3})(\\d{4})","$1 $2 $3",["[1-9]"],"0$1"],["(\\d{3})(\\d{3})(\\d{4})","$1 $2 $3",["8"],"0$1"]],"0"],"ZM":["260","00","800\\d{6}|(?:21|[579]\\d|63)\\d{7}",[9],[["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["[28]"],"0$1"],["(\\d{2})(\\d{7})","$1 $2",["[579]"],"0$1"]],"0"],"ZW":["263","00","2(?:[0-57-9]\\d{6,8}|6[0-24-9]\\d{6,7})|[38]\\d{9}|[35-8]\\d{8}|[3-6]\\d{7}|[1-689]\\d{6}|[1-3569]\\d{5}|[1356]\\d{4}",[5,6,7,8,9,10],[["(\\d{3})(\\d{3,5})","$1 $2",["2(?:0[45]|2[278]|[49]8)|3(?:[09]8|17)|6(?:[29]8|37|75)|[23][78]|(?:33|5[15]|6[68])[78]"],"0$1"],["(\\d)(\\d{3})(\\d{2,4})","$1 $2 $3",["[49]"],"0$1"],["(\\d{3})(\\d{4})","$1 $2",["80"],"0$1"],["(\\d{2})(\\d{7})","$1 $2",["24|8[13-59]|(?:2[05-79]|39|5[45]|6[15-8])2","2(?:02[014]|4|[56]20|[79]2)|392|5(?:42|525)|6(?:[16-8]21|52[013])|8[13-59]"],"(0$1)"],["(\\d{2})(\\d{3})(\\d{4})","$1 $2 $3",["7"],"0$1"],["(\\d{3})(\\d{3})(\\d{3,4})","$1 $2 $3",["2(?:1[39]|2[0157]|[378]|[56][14])|3(?:12|29)","2(?:1[39]|2[0157]|[378]|[56][14])|3(?:123|29)"],"0$1"],["(\\d{4})(\\d{6})","$1 $2",["8"],"0$1"],["(\\d{2})(\\d{3,5})","$1 $2",["1|2(?:0[0-36-9]|12|29|[56])|3(?:1[0-689]|[24-6])|5(?:[0236-9]|1[2-4])|6(?:[013-59]|7[0-46-9])|(?:33|55|6[68])[0-69]|(?:29|3[09]|62)[0-79]"],"0$1"],["(\\d{2})(\\d{3})(\\d{3,4})","$1 $2 $3",["29[013-9]|39|54"],"0$1"],["(\\d{4})(\\d{3,5})","$1 $2",["(?:25|54)8","258|5483"],"0$1"]],"0"]},"nonGeographic":{"800":["800",0,"(?:00|[1-9]\\d)\\d{6}",[8],[["(\\d{4})(\\d{4})","$1 $2",["\\d"]]],0,0,0,0,0,0,[0,0,["(?:00|[1-9]\\d)\\d{6}"]]],"808":["808",0,"[1-9]\\d{7}",[8],[["(\\d{4})(\\d{4})","$1 $2",["[1-9]"]]],0,0,0,0,0,0,[0,0,0,0,0,0,0,0,0,["[1-9]\\d{7}"]]],"870":["870",0,"7\\d{11}|[235-7]\\d{8}",[9,12],[["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["[235-7]"]]],0,0,0,0,0,0,[0,["(?:[356]|774[45])\\d{8}|7[6-8]\\d{7}"],0,0,0,0,0,0,["2\\d{8}",[9]]]],"878":["878",0,"10\\d{10}",[12],[["(\\d{2})(\\d{5})(\\d{5})","$1 $2 $3",["1"]]],0,0,0,0,0,0,[0,0,0,0,0,0,0,0,["10\\d{10}"]]],"881":["881",0,"6\\d{9}|[0-36-9]\\d{8}",[9,10],[["(\\d)(\\d{3})(\\d{5})","$1 $2 $3",["[0-37-9]"]],["(\\d)(\\d{3})(\\d{5,6})","$1 $2 $3",["6"]]],0,0,0,0,0,0,[0,["6\\d{9}|[0-36-9]\\d{8}"]]],"882":["882",0,"[13]\\d{6}(?:\\d{2,5})?|[19]\\d{7}|(?:[25]\\d\\d|4)\\d{7}(?:\\d{2})?",[7,8,9,10,11,12],[["(\\d{2})(\\d{5})","$1 $2",["16|342"]],["(\\d{2})(\\d{6})","$1 $2",["49"]],["(\\d{2})(\\d{2})(\\d{4})","$1 $2 $3",["1[36]|9"]],["(\\d{2})(\\d{4})(\\d{3})","$1 $2 $3",["3[23]"]],["(\\d{2})(\\d{3,4})(\\d{4})","$1 $2 $3",["16"]],["(\\d{2})(\\d{4})(\\d{4})","$1 $2 $3",["10|23|3(?:[15]|4[57])|4|51"]],["(\\d{3})(\\d{4})(\\d{4})","$1 $2 $3",["34"]],["(\\d{2})(\\d{4,5})(\\d{5})","$1 $2 $3",["[1-35]"]]],0,0,0,0,0,0,[0,["342\\d{4}|(?:337|49)\\d{6}|(?:3(?:2|47|7\\d{3})|50\\d{3})\\d{7}",[7,8,9,10,12]],0,0,0,["348[57]\\d{7}",[11]],0,0,["1(?:3(?:0[0347]|[13][0139]|2[035]|4[013568]|6[0459]|7[06]|8[15-8]|9[0689])\\d{4}|6\\d{5,10})|(?:345\\d|9[89])\\d{6}|(?:10|2(?:3|85\\d)|3(?:[15]|[69]\\d\\d)|4[15-8]|51)\\d{8}"]]],"883":["883",0,"(?:[1-4]\\d|51)\\d{6,10}",[8,9,10,11,12],[["(\\d{3})(\\d{3})(\\d{2,8})","$1 $2 $3",["[14]|2[24-689]|3[02-689]|51[24-9]"]],["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["510"]],["(\\d{3})(\\d{3})(\\d{4})","$1 $2 $3",["21"]],["(\\d{4})(\\d{4})(\\d{4})","$1 $2 $3",["51[13]"]],["(\\d{3})(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3 $4",["[235]"]]],0,0,0,0,0,0,[0,0,0,0,0,0,0,0,["(?:2(?:00\\d\\d|10)|(?:370[1-9]|51\\d0)\\d)\\d{7}|51(?:00\\d{5}|[24-9]0\\d{4,7})|(?:1[0-79]|2[24-689]|3[02-689]|4[0-4])0\\d{5,9}"]]],"888":["888",0,"\\d{11}",[11],[["(\\d{3})(\\d{3})(\\d{5})","$1 $2 $3"]],0,0,0,0,0,0,[0,0,0,0,0,0,["\\d{11}"]]],"979":["979",0,"[1359]\\d{8}",[9],[["(\\d)(\\d{4})(\\d{4})","$1 $2 $3",["[1359]"]]],0,0,0,0,0,0,[0,0,0,["[1359]\\d{8}"]]]}};

	// Importing from a ".js" file is a workaround for Node.js "ES Modules"
	// importing system which is even uncapable of importing "*.json" files.

	function withMetadataArgument(func, _arguments) {
		var args = Array.prototype.slice.call(_arguments);
		args.push(metadata);
		return func.apply(this, args)
	}

	// Copy-pasted from:
	// https://github.com/substack/semver-compare/blob/master/index.js
	//
	// Inlining this function because some users reported issues with
	// importing from `semver-compare` in a browser with ES6 "native" modules.
	//
	// Fixes `semver-compare` not being able to compare versions with alpha/beta/etc "tags".
	// https://github.com/catamphetamine/libphonenumber-js/issues/381
	function compare (a, b) {
	  a = a.split('-');
	  b = b.split('-');
	  var pa = a[0].split('.');
	  var pb = b[0].split('.');
	  for (var i = 0; i < 3; i++) {
	    var na = Number(pa[i]);
	    var nb = Number(pb[i]);
	    if (na > nb) return 1;
	    if (nb > na) return -1;
	    if (!isNaN(na) && isNaN(nb)) return 1;
	    if (isNaN(na) && !isNaN(nb)) return -1;
	  }
	  if (a[1] && b[1]) {
	    return a[1] > b[1] ? 1 : a[1] < b[1] ? -1 : 0;
	  }
	  return !a[1] && b[1] ? 1 : a[1] && !b[1] ? -1 : 0;
	}

	var objectConstructor = {}.constructor;
	function isObject(object) {
	  return object !== undefined && object !== null && object.constructor === objectConstructor;
	}

	function _typeof$5(o) { "@babel/helpers - typeof"; return _typeof$5 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof$5(o); }
	function _classCallCheck$2(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
	function _defineProperties$1(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey$4(o.key), o); } }
	function _createClass$2(e, r, t) { return r && _defineProperties$1(e.prototype, r), Object.defineProperty(e, "prototype", { writable: false }), e; }
	function _toPropertyKey$4(t) { var i = _toPrimitive$4(t, "string"); return "symbol" == _typeof$5(i) ? i : i + ""; }
	function _toPrimitive$4(t, r) { if ("object" != _typeof$5(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r); if ("object" != _typeof$5(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return (String )(t); }

	// Added "idd_prefix" and "default_idd_prefix".
	var V3 = '1.2.0';

	// Moved `001` country code to "nonGeographic" section of metadata.
	var V4 = '1.7.35';
	var DEFAULT_EXT_PREFIX = ' ext. ';
	var CALLING_CODE_REG_EXP = /^\d+$/;

	/**
	 * See: https://gitlab.com/catamphetamine/libphonenumber-js/blob/master/METADATA.md
	 */
	var Metadata = /*#__PURE__*/function () {
	  function Metadata(metadata) {
	    _classCallCheck$2(this, Metadata);
	    validateMetadata(metadata);
	    this.metadata = metadata;
	    setVersion.call(this, metadata);
	  }
	  return _createClass$2(Metadata, [{
	    key: "getCountries",
	    value: function getCountries() {
	      return Object.keys(this.metadata.countries).filter(function (_) {
	        return _ !== '001';
	      });
	    }
	  }, {
	    key: "getCountryMetadata",
	    value: function getCountryMetadata(countryCode) {
	      return this.metadata.countries[countryCode];
	    }
	  }, {
	    key: "nonGeographic",
	    value: function nonGeographic() {
	      if (this.v1 || this.v2 || this.v3) return;
	      // `nonGeographical` was a typo.
	      // It's present in metadata generated from `1.7.35` to `1.7.37`.
	      // The test case could be found by searching for "nonGeographical".
	      return this.metadata.nonGeographic || this.metadata.nonGeographical;
	    }
	  }, {
	    key: "hasCountry",
	    value: function hasCountry(country) {
	      return this.getCountryMetadata(country) !== undefined;
	    }
	  }, {
	    key: "hasCallingCode",
	    value: function hasCallingCode(callingCode) {
	      if (this.getCountryCodesForCallingCode(callingCode)) {
	        return true;
	      }
	      if (this.nonGeographic()) {
	        if (this.nonGeographic()[callingCode]) {
	          return true;
	        }
	      } else {
	        // A hacky workaround for old custom metadata (generated before V4).
	        var countryCodes = this.countryCallingCodes()[callingCode];
	        if (countryCodes && countryCodes.length === 1 && countryCodes[0] === '001') {
	          return true;
	        }
	      }
	    }
	  }, {
	    key: "isNonGeographicCallingCode",
	    value: function isNonGeographicCallingCode(callingCode) {
	      if (this.nonGeographic()) {
	        return this.nonGeographic()[callingCode] ? true : false;
	      } else {
	        return this.getCountryCodesForCallingCode(callingCode) ? false : true;
	      }
	    }

	    // Deprecated.
	  }, {
	    key: "country",
	    value: function country(countryCode) {
	      return this.selectNumberingPlan(countryCode);
	    }
	  }, {
	    key: "selectNumberingPlan",
	    value: function selectNumberingPlan(countryCode, callingCode) {
	      // Supports just passing `callingCode` as the first argument.
	      if (countryCode && CALLING_CODE_REG_EXP.test(countryCode)) {
	        callingCode = countryCode;
	        countryCode = null;
	      }
	      if (countryCode && countryCode !== '001') {
	        if (!this.hasCountry(countryCode)) {
	          throw new Error("Unknown country: ".concat(countryCode));
	        }
	        this.numberingPlan = new NumberingPlan(this.getCountryMetadata(countryCode), this);
	      } else if (callingCode) {
	        if (!this.hasCallingCode(callingCode)) {
	          throw new Error("Unknown calling code: ".concat(callingCode));
	        }
	        this.numberingPlan = new NumberingPlan(this.getNumberingPlanMetadata(callingCode), this);
	      } else {
	        this.numberingPlan = undefined;
	      }
	      return this;
	    }
	  }, {
	    key: "getCountryCodesForCallingCode",
	    value: function getCountryCodesForCallingCode(callingCode) {
	      var countryCodes = this.countryCallingCodes()[callingCode];
	      if (countryCodes) {
	        // Metadata before V4 included "non-geographic entity" calling codes
	        // inside `country_calling_codes` (for example, `"881":["001"]`).
	        // Now the semantics of `country_calling_codes` has changed:
	        // it's specifically for "countries" now.
	        // Older versions of custom metadata will simply skip parsing
	        // "non-geographic entity" phone numbers with new versions
	        // of this library: it's not considered a bug,
	        // because such numbers are extremely rare,
	        // and developers extremely rarely use custom metadata.
	        if (countryCodes.length === 1 && countryCodes[0].length === 3) {
	          return;
	        }
	        return countryCodes;
	      }
	    }
	  }, {
	    key: "getCountryCodeForCallingCode",
	    value: function getCountryCodeForCallingCode(callingCode) {
	      var countryCodes = this.getCountryCodesForCallingCode(callingCode);
	      if (countryCodes) {
	        return countryCodes[0];
	      }
	    }
	  }, {
	    key: "getNumberingPlanMetadata",
	    value: function getNumberingPlanMetadata(callingCode) {
	      var countryCode = this.getCountryCodeForCallingCode(callingCode);
	      if (countryCode) {
	        return this.getCountryMetadata(countryCode);
	      }
	      if (this.nonGeographic()) {
	        var metadata = this.nonGeographic()[callingCode];
	        if (metadata) {
	          return metadata;
	        }
	      } else {
	        // A hacky workaround for old custom metadata (generated before V4).
	        // In that metadata, there was no concept of "non-geographic" metadata
	        // so metadata for `001` country code was stored along with other countries.
	        // The test case can be found by searching for:
	        // "should work around `nonGeographic` metadata not existing".
	        var countryCodes = this.countryCallingCodes()[callingCode];
	        if (countryCodes && countryCodes.length === 1 && countryCodes[0] === '001') {
	          return this.metadata.countries['001'];
	        }
	      }
	    }

	    // Deprecated.
	  }, {
	    key: "countryCallingCode",
	    value: function countryCallingCode() {
	      return this.numberingPlan.callingCode();
	    }

	    // Deprecated.
	  }, {
	    key: "IDDPrefix",
	    value: function IDDPrefix() {
	      return this.numberingPlan.IDDPrefix();
	    }

	    // Deprecated.
	  }, {
	    key: "defaultIDDPrefix",
	    value: function defaultIDDPrefix() {
	      return this.numberingPlan.defaultIDDPrefix();
	    }

	    // Deprecated.
	  }, {
	    key: "nationalNumberPattern",
	    value: function nationalNumberPattern() {
	      return this.numberingPlan.nationalNumberPattern();
	    }

	    // Deprecated.
	  }, {
	    key: "possibleLengths",
	    value: function possibleLengths() {
	      return this.numberingPlan.possibleLengths();
	    }

	    // Deprecated.
	  }, {
	    key: "formats",
	    value: function formats() {
	      return this.numberingPlan.formats();
	    }

	    // Deprecated.
	  }, {
	    key: "nationalPrefixForParsing",
	    value: function nationalPrefixForParsing() {
	      return this.numberingPlan.nationalPrefixForParsing();
	    }

	    // Deprecated.
	  }, {
	    key: "nationalPrefixTransformRule",
	    value: function nationalPrefixTransformRule() {
	      return this.numberingPlan.nationalPrefixTransformRule();
	    }

	    // Deprecated.
	  }, {
	    key: "leadingDigits",
	    value: function leadingDigits() {
	      return this.numberingPlan.leadingDigits();
	    }

	    // Deprecated.
	  }, {
	    key: "hasTypes",
	    value: function hasTypes() {
	      return this.numberingPlan.hasTypes();
	    }

	    // Deprecated.
	  }, {
	    key: "type",
	    value: function type(_type) {
	      return this.numberingPlan.type(_type);
	    }

	    // Deprecated.
	  }, {
	    key: "ext",
	    value: function ext() {
	      return this.numberingPlan.ext();
	    }
	  }, {
	    key: "countryCallingCodes",
	    value: function countryCallingCodes() {
	      if (this.v1) return this.metadata.country_phone_code_to_countries;
	      return this.metadata.country_calling_codes;
	    }

	    // Deprecated.
	  }, {
	    key: "chooseCountryByCountryCallingCode",
	    value: function chooseCountryByCountryCallingCode(callingCode) {
	      return this.selectNumberingPlan(callingCode);
	    }
	  }, {
	    key: "hasSelectedNumberingPlan",
	    value: function hasSelectedNumberingPlan() {
	      return this.numberingPlan !== undefined;
	    }
	  }]);
	}();
	var NumberingPlan = /*#__PURE__*/function () {
	  function NumberingPlan(metadata, globalMetadataObject) {
	    _classCallCheck$2(this, NumberingPlan);
	    this.globalMetadataObject = globalMetadataObject;
	    this.metadata = metadata;
	    setVersion.call(this, globalMetadataObject.metadata);
	  }
	  return _createClass$2(NumberingPlan, [{
	    key: "callingCode",
	    value: function callingCode() {
	      return this.metadata[0];
	    }

	    // Formatting information for regions which share
	    // a country calling code is contained by only one region
	    // for performance reasons. For example, for NANPA region
	    // ("North American Numbering Plan Administration",
	    //  which includes USA, Canada, Cayman Islands, Bahamas, etc)
	    // it will be contained in the metadata for `US`.
	  }, {
	    key: "getDefaultCountryMetadataForRegion",
	    value: function getDefaultCountryMetadataForRegion() {
	      return this.globalMetadataObject.getNumberingPlanMetadata(this.callingCode());
	    }

	    // Is always present.
	  }, {
	    key: "IDDPrefix",
	    value: function IDDPrefix() {
	      if (this.v1 || this.v2) return;
	      return this.metadata[1];
	    }

	    // Is only present when a country supports multiple IDD prefixes.
	  }, {
	    key: "defaultIDDPrefix",
	    value: function defaultIDDPrefix() {
	      if (this.v1 || this.v2) return;
	      return this.metadata[12];
	    }
	  }, {
	    key: "nationalNumberPattern",
	    value: function nationalNumberPattern() {
	      if (this.v1 || this.v2) return this.metadata[1];
	      return this.metadata[2];
	    }

	    // "possible length" data is always present in Google's metadata.
	  }, {
	    key: "possibleLengths",
	    value: function possibleLengths() {
	      if (this.v1) return;
	      return this.metadata[this.v2 ? 2 : 3];
	    }
	  }, {
	    key: "_getFormats",
	    value: function _getFormats(metadata) {
	      return metadata[this.v1 ? 2 : this.v2 ? 3 : 4];
	    }

	    // For countries of the same region (e.g. NANPA)
	    // formats are all stored in the "main" country for that region.
	    // E.g. "RU" and "KZ", "US" and "CA".
	  }, {
	    key: "formats",
	    value: function formats() {
	      var _this = this;
	      var formats = this._getFormats(this.metadata) || this._getFormats(this.getDefaultCountryMetadataForRegion()) || [];
	      return formats.map(function (_) {
	        return new Format(_, _this);
	      });
	    }
	  }, {
	    key: "nationalPrefix",
	    value: function nationalPrefix() {
	      return this.metadata[this.v1 ? 3 : this.v2 ? 4 : 5];
	    }
	  }, {
	    key: "_getNationalPrefixFormattingRule",
	    value: function _getNationalPrefixFormattingRule(metadata) {
	      return metadata[this.v1 ? 4 : this.v2 ? 5 : 6];
	    }

	    // For countries of the same region (e.g. NANPA)
	    // national prefix formatting rule is stored in the "main" country for that region.
	    // E.g. "RU" and "KZ", "US" and "CA".
	  }, {
	    key: "nationalPrefixFormattingRule",
	    value: function nationalPrefixFormattingRule() {
	      return this._getNationalPrefixFormattingRule(this.metadata) || this._getNationalPrefixFormattingRule(this.getDefaultCountryMetadataForRegion());
	    }
	  }, {
	    key: "_nationalPrefixForParsing",
	    value: function _nationalPrefixForParsing() {
	      return this.metadata[this.v1 ? 5 : this.v2 ? 6 : 7];
	    }
	  }, {
	    key: "nationalPrefixForParsing",
	    value: function nationalPrefixForParsing() {
	      // If `national_prefix_for_parsing` is not set explicitly,
	      // then infer it from `national_prefix` (if any)
	      return this._nationalPrefixForParsing() || this.nationalPrefix();
	    }
	  }, {
	    key: "nationalPrefixTransformRule",
	    value: function nationalPrefixTransformRule() {
	      return this.metadata[this.v1 ? 6 : this.v2 ? 7 : 8];
	    }
	  }, {
	    key: "_getNationalPrefixIsOptionalWhenFormatting",
	    value: function _getNationalPrefixIsOptionalWhenFormatting() {
	      return !!this.metadata[this.v1 ? 7 : this.v2 ? 8 : 9];
	    }

	    // For countries of the same region (e.g. NANPA)
	    // "national prefix is optional when formatting" flag is
	    // stored in the "main" country for that region.
	    // E.g. "RU" and "KZ", "US" and "CA".
	  }, {
	    key: "nationalPrefixIsOptionalWhenFormattingInNationalFormat",
	    value: function nationalPrefixIsOptionalWhenFormattingInNationalFormat() {
	      return this._getNationalPrefixIsOptionalWhenFormatting(this.metadata) || this._getNationalPrefixIsOptionalWhenFormatting(this.getDefaultCountryMetadataForRegion());
	    }
	  }, {
	    key: "leadingDigits",
	    value: function leadingDigits() {
	      return this.metadata[this.v1 ? 8 : this.v2 ? 9 : 10];
	    }
	  }, {
	    key: "types",
	    value: function types() {
	      return this.metadata[this.v1 ? 9 : this.v2 ? 10 : 11];
	    }
	  }, {
	    key: "hasTypes",
	    value: function hasTypes() {
	      // Versions 1.2.0 - 1.2.4: can be `[]`.
	      /* istanbul ignore next */
	      if (this.types() && this.types().length === 0) {
	        return false;
	      }
	      // Versions <= 1.2.4: can be `undefined`.
	      // Version >= 1.2.5: can be `0`.
	      return !!this.types();
	    }
	  }, {
	    key: "type",
	    value: function type(_type2) {
	      if (this.hasTypes() && getType(this.types(), _type2)) {
	        return new Type(getType(this.types(), _type2), this);
	      }
	    }
	  }, {
	    key: "ext",
	    value: function ext() {
	      if (this.v1 || this.v2) return DEFAULT_EXT_PREFIX;
	      return this.metadata[13] || DEFAULT_EXT_PREFIX;
	    }
	  }]);
	}();
	var Format = /*#__PURE__*/function () {
	  function Format(format, metadata) {
	    _classCallCheck$2(this, Format);
	    this._format = format;
	    this.metadata = metadata;
	  }
	  return _createClass$2(Format, [{
	    key: "pattern",
	    value: function pattern() {
	      return this._format[0];
	    }
	  }, {
	    key: "format",
	    value: function format() {
	      return this._format[1];
	    }
	  }, {
	    key: "leadingDigitsPatterns",
	    value: function leadingDigitsPatterns() {
	      return this._format[2] || [];
	    }
	  }, {
	    key: "nationalPrefixFormattingRule",
	    value: function nationalPrefixFormattingRule() {
	      return this._format[3] || this.metadata.nationalPrefixFormattingRule();
	    }
	  }, {
	    key: "nationalPrefixIsOptionalWhenFormattingInNationalFormat",
	    value: function nationalPrefixIsOptionalWhenFormattingInNationalFormat() {
	      return !!this._format[4] || this.metadata.nationalPrefixIsOptionalWhenFormattingInNationalFormat();
	    }
	  }, {
	    key: "nationalPrefixIsMandatoryWhenFormattingInNationalFormat",
	    value: function nationalPrefixIsMandatoryWhenFormattingInNationalFormat() {
	      // National prefix is omitted if there's no national prefix formatting rule
	      // set for this country, or when the national prefix formatting rule
	      // contains no national prefix itself, or when this rule is set but
	      // national prefix is optional for this phone number format
	      // (and it is not enforced explicitly)
	      return this.usesNationalPrefix() && !this.nationalPrefixIsOptionalWhenFormattingInNationalFormat();
	    }

	    // Checks whether national prefix formatting rule contains national prefix.
	  }, {
	    key: "usesNationalPrefix",
	    value: function usesNationalPrefix() {
	      return this.nationalPrefixFormattingRule() &&
	      // Check that national prefix formatting rule is not a "dummy" one.
	      !FIRST_GROUP_ONLY_PREFIX_PATTERN.test(this.nationalPrefixFormattingRule())
	      // In compressed metadata, `this.nationalPrefixFormattingRule()` is `0`
	      // when `national_prefix_formatting_rule` is not present.
	      // So, `true` or `false` are returned explicitly here, so that
	      // `0` number isn't returned.
	      ? true : false;
	    }
	  }, {
	    key: "internationalFormat",
	    value: function internationalFormat() {
	      return this._format[5] || this.format();
	    }
	  }]);
	}();
	/**
	 * A pattern that is used to determine if the national prefix formatting rule
	 * has the first group only, i.e., does not start with the national prefix.
	 * Note that the pattern explicitly allows for unbalanced parentheses.
	 */
	var FIRST_GROUP_ONLY_PREFIX_PATTERN = /^\(?\$1\)?$/;
	var Type = /*#__PURE__*/function () {
	  function Type(type, metadata) {
	    _classCallCheck$2(this, Type);
	    this.type = type;
	    this.metadata = metadata;
	  }
	  return _createClass$2(Type, [{
	    key: "pattern",
	    value: function pattern() {
	      if (this.metadata.v1) return this.type;
	      return this.type[0];
	    }
	  }, {
	    key: "possibleLengths",
	    value: function possibleLengths() {
	      if (this.metadata.v1) return;
	      return this.type[1] || this.metadata.possibleLengths();
	    }
	  }]);
	}();
	function getType(types, type) {
	  switch (type) {
	    case 'FIXED_LINE':
	      return types[0];
	    case 'MOBILE':
	      return types[1];
	    case 'TOLL_FREE':
	      return types[2];
	    case 'PREMIUM_RATE':
	      return types[3];
	    case 'PERSONAL_NUMBER':
	      return types[4];
	    case 'VOICEMAIL':
	      return types[5];
	    case 'UAN':
	      return types[6];
	    case 'PAGER':
	      return types[7];
	    case 'VOIP':
	      return types[8];
	    case 'SHARED_COST':
	      return types[9];
	  }
	}
	function validateMetadata(metadata) {
	  if (!metadata) {
	    throw new Error('[libphonenumber-js] `metadata` argument not passed. Check your arguments.');
	  }

	  // `country_phone_code_to_countries` was renamed to `country_calling_codes` in `1.0.18`.
	  // For that reason, it's not used in this detection algorithm.
	  // Instead, it detects by `countries: {}` property existence.
	  if (!isObject(metadata) || !isObject(metadata.countries)) {
	    throw new Error("[libphonenumber-js] `metadata` argument was passed but it's not a valid metadata. Must be an object having `.countries` child object property. Got ".concat(isObject(metadata) ? 'an object of shape: { ' + Object.keys(metadata).join(', ') + ' }' : 'a ' + typeOf(metadata) + ': ' + metadata, "."));
	  }
	}

	// Babel transforms `typeof` into some "branches"
	// so istanbul will show this as "branch not covered".
	/* istanbul ignore next */
	var typeOf = function typeOf(_) {
	  return _typeof$5(_);
	};

	/**
	 * Returns "country calling code" for a country.
	 * Throws an error if the country doesn't exist or isn't supported by this library.
	 * @param  {string} country
	 * @param  {object} metadata
	 * @return {string}
	 * @example
	 * // Returns "44"
	 * getCountryCallingCode("GB")
	 */
	function getCountryCallingCode(country, metadata) {
	  metadata = new Metadata(metadata);
	  if (metadata.hasCountry(country)) {
	    return metadata.selectNumberingPlan(country).countryCallingCode();
	  }
	  throw new Error("Unknown country: ".concat(country));
	}
	function isSupportedCountry(country, metadata) {
	  // metadata = new Metadata(metadata)
	  // return metadata.hasCountry(country)
	  return metadata.countries.hasOwnProperty(country);
	}
	function setVersion(metadata) {
	  var version = metadata.version;
	  if (typeof version === 'number') {
	    this.v1 = version === 1;
	    this.v2 = version === 2;
	    this.v3 = version === 3;
	    this.v4 = version === 4;
	  } else {
	    if (!version) {
	      this.v1 = true;
	    } else if (compare(version, V3) === -1) {
	      this.v2 = true;
	    } else if (compare(version, V4) === -1) {
	      this.v3 = true;
	    } else {
	      this.v4 = true;
	    }
	  }
	}

	// const ISO_COUNTRY_CODE = /^[A-Z]{2}$/
	// function isCountryCode(countryCode) {
	// 	return ISO_COUNTRY_CODE.test(countryCodeOrCountryCallingCode)
	// }

	function checkNumberLength(nationalNumber, country, metadata) {
	  return checkNumberLengthForType(nationalNumber, country, undefined, metadata);
	}

	// Checks whether a number is possible for a certain `country` based on the number length.
	//
	// This function is not supported by metadata generated with ancient versions of
	// `libphonenumber-js` (before version `1.0.18`) which didn't include "possible lengths".
	//
	// There was also a known issue with `checkNumberLength()` function:
	// if a number is possible only in a certain `country` among several `countries`
	// that share the same "country calling code", that function would check
	// the possibility of the phone number only in the "main" `country` for the "country calling code"
	// and would not check if it's actually be possible in the speciifc `country`.
	//
	// For example, "+1310xxxx" numbers are valid in Canada.
	// However, they are not possible in the US due to being too short.
	// Since Canada and the US share the same country calling code  "+1" 
	// `checkNumberLength()` function used to return not "IS_POSSIBLE" for "+1310xxxx" numbers.
	//
	// In such cases, when using "/max" metadata, `isValid()` could output `true`
	// but at the same time `isPossible()` could output `false`, which was contradictory.
	//
	// See https://issuetracker.google.com/issues/335892662 for the discusson in Google's issues.
	//
	// The solution suggested by Google was implemented: an optional `country` argument
	// was added to `checkNumberLength()` function. If present, that `country` will be used
	// to check phone number length for that specific `country` rather than the "main" country
	// for the shared "country calling code".
	//
	function checkNumberLengthForType(nationalNumber, country, type, metadata) {
	  // If the exact `country` is specified, it's no necessarily already selected in `metadata`.
	  // Most likely, in cases when there're multiple countries corresponding to the same
	  // "country calling code", the "main" country for that "country calling code" will be selected.
	  if (country) {
	    metadata = new Metadata(metadata.metadata);
	    metadata.selectNumberingPlan(country);
	  }
	  var type_info = metadata.type(type);

	  // There should always be "<possiblePengths/>" set for every type element.
	  // This is declared in the XML schema.
	  // For size efficiency, where a sub-description (e.g. fixed-line)
	  // has the same "<possiblePengths/>" as the "general description", this is missing,
	  // so we fall back to the "general description". Where no numbers of the type
	  // exist at all, there is one possible length (-1) which is guaranteed
	  // not to match the length of any real phone number.
	  var possible_lengths = type_info && type_info.possibleLengths() || metadata.possibleLengths();
	  // let local_lengths = type_info && type.possibleLengthsLocal() || metadata.possibleLengthsLocal()

	  // Metadata before version `1.0.18` didn't contain `possible_lengths`.
	  if (!possible_lengths) {
	    return 'IS_POSSIBLE';
	  }
	  var actual_length = nationalNumber.length;

	  // In `libphonenumber-js` all "local-only" formats are dropped for simplicity.
	  // // This is safe because there is never an overlap beween the possible lengths
	  // // and the local-only lengths; this is checked at build time.
	  // if (local_lengths && local_lengths.indexOf(nationalNumber.length) >= 0)
	  // {
	  // 	return 'IS_POSSIBLE_LOCAL_ONLY'
	  // }

	  var minimum_length = possible_lengths[0];
	  if (minimum_length === actual_length) {
	    return 'IS_POSSIBLE';
	  }
	  if (minimum_length > actual_length) {
	    return 'TOO_SHORT';
	  }
	  if (possible_lengths[possible_lengths.length - 1] < actual_length) {
	    return 'TOO_LONG';
	  }

	  // We skip the first element since we've already checked it.
	  return possible_lengths.indexOf(actual_length, 1) >= 0 ? 'IS_POSSIBLE' : 'INVALID_LENGTH';
	}

	/**
	 * Checks if a phone number is "possible" (basically just checks its length).
	 *
	 * isPossible(phoneNumberInstance, { ..., v2: true }, metadata)
	 *
	 * isPossible({ phone: '8005553535', country: 'RU' }, { ... }, metadata)
	 * isPossible({ phone: '8005553535', country: 'RU' }, undefined, metadata)
	 *
	 * @param  {object|PhoneNumber} input  If `options.v2: true` flag is passed, the `input` should be a `PhoneNumber` instance. Otherwise, it should be an object of shape `{ phone: '...', country: '...' }`.
	 * @param  {object} [options]
	 * @param  {object} metadata
	 * @return {string}
	 */
	function isPossiblePhoneNumber(input, options, metadata) {
	  /* istanbul ignore if */
	  if (options === undefined) {
	    options = {};
	  }
	  metadata = new Metadata(metadata);
	  if (options.v2) {
	    if (!input.countryCallingCode) {
	      throw new Error('Invalid phone number object passed');
	    }
	    metadata.selectNumberingPlan(input.countryCallingCode);
	  } else {
	    if (!input.phone) {
	      return false;
	    }
	    if (input.country) {
	      if (!metadata.hasCountry(input.country)) {
	        throw new Error("Unknown country: ".concat(input.country));
	      }
	      metadata.selectNumberingPlan(input.country);
	    } else {
	      if (!input.countryCallingCode) {
	        throw new Error('Invalid phone number object passed');
	      }
	      metadata.selectNumberingPlan(input.countryCallingCode);
	    }
	  }

	  // Old metadata (< 1.0.18) had no "possible length" data.
	  if (metadata.possibleLengths()) {
	    return isPossibleNumber(input.phone || input.nationalNumber, input.country, metadata);
	  } else {
	    // There was a bug between `1.7.35` and `1.7.37` where "possible_lengths"
	    // were missing for "non-geographical" numbering plans.
	    // Just assume the number is possible in such cases:
	    // it's unlikely that anyone generated their custom metadata
	    // in that short period of time (one day).
	    // This code can be removed in some future major version update.
	    if (input.countryCallingCode && metadata.isNonGeographicCallingCode(input.countryCallingCode)) {
	      // "Non-geographic entities" did't have `possibleLengths`
	      // due to a bug in metadata generation process.
	      return true;
	    } else {
	      throw new Error('Missing "possibleLengths" in metadata. Perhaps the metadata has been generated before v1.0.18.');
	    }
	  }
	}
	function isPossibleNumber(nationalNumber, country, metadata) {
	  //, isInternational) {
	  switch (checkNumberLength(nationalNumber, country, metadata)) {
	    case 'IS_POSSIBLE':
	      return true;
	    // This library ignores "local-only" phone numbers (for simplicity).
	    // See the readme for more info on what are "local-only" phone numbers.
	    // case 'IS_POSSIBLE_LOCAL_ONLY':
	    // 	return !isInternational
	    default:
	      return false;
	  }
	}

	/**
	 * Checks whether the entire input sequence can be matched
	 * against the regular expression.
	 * @return {boolean}
	 */
	function matchesEntirely(text, regularExpressionText) {
	  // If the assigning of the `''` default value is moved to the arguments above,
	  // the code coverage would decrease for some weird reason.
	  text = text || '';
	  return new RegExp('^(?:' + regularExpressionText + ')$').test(text);
	}

	function _createForOfIteratorHelperLoose$2(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (t) return (t = t.call(r)).next.bind(t); if (Array.isArray(r) || (t = _unsupportedIterableToArray$3(r)) || e) { t && (r = t); var o = 0; return function () { return o >= r.length ? { done: true } : { done: false, value: r[o++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
	function _unsupportedIterableToArray$3(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray$3(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray$3(r, a) : void 0; } }
	function _arrayLikeToArray$3(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
	var NON_FIXED_LINE_PHONE_TYPES = ['MOBILE', 'PREMIUM_RATE', 'TOLL_FREE', 'SHARED_COST', 'VOIP', 'PERSONAL_NUMBER', 'PAGER', 'UAN', 'VOICEMAIL'];

	// Finds out national phone number type (fixed line, mobile, etc)
	function getNumberType(input, options, metadata) {
	  // If assigning the `{}` default value is moved to the arguments above,
	  // code coverage would decrease for some weird reason.
	  options = options || {};

	  // When `parse()` returns an empty object  `{}` 
	  // that means that the phone number is malformed,
	  // so it can't possibly be valid.
	  if (!input.country && !input.countryCallingCode) {
	    return;
	  }
	  metadata = new Metadata(metadata);
	  metadata.selectNumberingPlan(input.country, input.countryCallingCode);
	  var nationalNumber = options.v2 ? input.nationalNumber : input.phone;

	  // The following is copy-pasted from the original function:
	  // https://github.com/googlei18n/libphonenumber/blob/3ea547d4fbaa2d0b67588904dfa5d3f2557c27ff/javascript/i18n/phonenumbers/phonenumberutil.js#L2835

	  // Is this national number even valid for this country
	  if (!matchesEntirely(nationalNumber, metadata.nationalNumberPattern())) {
	    return;
	  }

	  // Is it fixed line number
	  if (isNumberTypeEqualTo(nationalNumber, 'FIXED_LINE', metadata)) {
	    // Because duplicate regular expressions are removed
	    // to reduce metadata size, if "mobile" pattern is ""
	    // then it means it was removed due to being a duplicate of the fixed-line pattern.
	    //
	    if (metadata.type('MOBILE') && metadata.type('MOBILE').pattern() === '') {
	      return 'FIXED_LINE_OR_MOBILE';
	    }

	    // `MOBILE` type pattern isn't included if it matched `FIXED_LINE` one.
	    // For example, for "US" country.
	    // Old metadata (< `1.0.18`) had a specific "types" data structure
	    // that happened to be `undefined` for `MOBILE` in that case.
	    // Newer metadata (>= `1.0.18`) has another data structure that is
	    // not `undefined` for `MOBILE` in that case (it's just an empty array).
	    // So this `if` is just for backwards compatibility with old metadata.
	    if (!metadata.type('MOBILE')) {
	      return 'FIXED_LINE_OR_MOBILE';
	    }

	    // Check if the number happens to qualify as both fixed line and mobile.
	    // (no such country in the minimal metadata set)
	    /* istanbul ignore if */
	    if (isNumberTypeEqualTo(nationalNumber, 'MOBILE', metadata)) {
	      return 'FIXED_LINE_OR_MOBILE';
	    }
	    return 'FIXED_LINE';
	  }
	  for (var _iterator = _createForOfIteratorHelperLoose$2(NON_FIXED_LINE_PHONE_TYPES), _step; !(_step = _iterator()).done;) {
	    var type = _step.value;
	    if (isNumberTypeEqualTo(nationalNumber, type, metadata)) {
	      return type;
	    }
	  }
	}
	function isNumberTypeEqualTo(nationalNumber, type, metadata) {
	  type = metadata.type(type);
	  if (!type || !type.pattern()) {
	    return false;
	  }
	  // Check if any possible number lengths are present;
	  // if so, we use them to avoid checking
	  // the validation pattern if they don't match.
	  // If they are absent, this means they match
	  // the general description, which we have
	  // already checked before a specific number type.
	  if (type.possibleLengths() && type.possibleLengths().indexOf(nationalNumber.length) < 0) {
	    return false;
	  }
	  return matchesEntirely(nationalNumber, type.pattern());
	}

	/**
	 * Checks if a given phone number is valid.
	 *
	 * isValid(phoneNumberInstance, { ..., v2: true }, metadata)
	 *
	 * isPossible({ phone: '8005553535', country: 'RU' }, { ... }, metadata)
	 * isPossible({ phone: '8005553535', country: 'RU' }, undefined, metadata)
	 *
	 * If the `number` is a string, it will be parsed to an object,
	 * but only if it contains only valid phone number characters (including punctuation).
	 * If the `number` is an object, it is used as is.
	 *
	 * The optional `defaultCountry` argument is the default country.
	 * I.e. it does not restrict to just that country,
	 * e.g. in those cases where several countries share
	 * the same phone numbering rules (NANPA, Britain, etc).
	 * For example, even though the number `07624 369230`
	 * belongs to the Isle of Man ("IM" country code)
	 * calling `isValidNumber('07624369230', 'GB', metadata)`
	 * still returns `true` because the country is not restricted to `GB`,
	 * it's just that `GB` is the default one for the phone numbering rules.
	 * For restricting the country see `isValidNumberForRegion()`
	 * though restricting a country might not be a good idea.
	 * https://github.com/googlei18n/libphonenumber/blob/master/FAQ.md#when-should-i-use-isvalidnumberforregion
	 *
	 * Examples:
	 *
	 * ```js
	 * isValidNumber('+78005553535', metadata)
	 * isValidNumber('8005553535', 'RU', metadata)
	 * isValidNumber('88005553535', 'RU', metadata)
	 * isValidNumber({ phone: '8005553535', country: 'RU' }, metadata)
	 * ```
	 */
	function isValidNumber(input, options, metadata) {
	  // If assigning the `{}` default value is moved to the arguments above,
	  // code coverage would decrease for some weird reason.
	  options = options || {};
	  metadata = new Metadata(metadata);
	  metadata.selectNumberingPlan(input.country, input.countryCallingCode);

	  // By default, countries only have type regexps when it's required for
	  // distinguishing different countries having the same `countryCallingCode`.
	  if (metadata.hasTypes()) {
	    return getNumberType(input, options, metadata.metadata) !== undefined;
	  }

	  // If there are no type regexps for this country in metadata then use
	  // `nationalNumberPattern` as a "better than nothing" replacement.
	  var nationalNumber = options.v2 ? input.nationalNumber : input.phone;
	  return matchesEntirely(nationalNumber, metadata.nationalNumberPattern());
	}

	/**
	 * Returns a list of countries that the phone number could potentially belong to.
	 * @param  {string} callingCode  Calling code.
	 * @param  {string} nationalNumber  National (significant) number.
	 * @param  {object} metadata  Metadata.
	 * @return {string[]} A list of possible countries.
	 */
	function getPossibleCountriesForNumber(callingCode, nationalNumber, metadata) {
	  var _metadata = new Metadata(metadata);
	  var possibleCountries = _metadata.getCountryCodesForCallingCode(callingCode);
	  if (!possibleCountries) {
	    return [];
	  }
	  return possibleCountries.filter(function (country) {
	    return couldNationalNumberBelongToCountry(nationalNumber, country, metadata);
	  });
	}
	function couldNationalNumberBelongToCountry(nationalNumber, country, metadata) {
	  var _metadata = new Metadata(metadata);
	  _metadata.selectNumberingPlan(country);
	  if (_metadata.numberingPlan.possibleLengths().indexOf(nationalNumber.length) >= 0) {
	    return true;
	  }
	  return false;
	}

	// The minimum length of the national significant number.
	var MIN_LENGTH_FOR_NSN = 2;

	// The ITU says the maximum length should be 15,
	// but one can find longer numbers in Germany.
	var MAX_LENGTH_FOR_NSN = 17;

	// The maximum length of the country calling code.
	var MAX_LENGTH_COUNTRY_CODE = 3;

	// Digits accepted in phone numbers
	// (ascii, fullwidth, arabic-indic, and eastern arabic digits).
	var VALID_DIGITS = "0-9\uFF10-\uFF19\u0660-\u0669\u06F0-\u06F9";

	// `DASHES` will be right after the opening square bracket of the "character class"
	var DASHES = "-\u2010-\u2015\u2212\u30FC\uFF0D";
	var SLASHES = "\uFF0F/";
	var DOTS = "\uFF0E.";
	var WHITESPACE = " \xA0\xAD\u200B\u2060\u3000";
	var BRACKETS = "()\uFF08\uFF09\uFF3B\uFF3D\\[\\]";
	// export const OPENING_BRACKETS = '(\uFF08\uFF3B\\\['
	var TILDES = "~\u2053\u223C\uFF5E";

	// Regular expression of acceptable punctuation found in phone numbers. This
	// excludes punctuation found as a leading character only. This consists of dash
	// characters, white space characters, full stops, slashes, square brackets,
	// parentheses and tildes. Full-width variants are also present.
	var VALID_PUNCTUATION = "".concat(DASHES).concat(SLASHES).concat(DOTS).concat(WHITESPACE).concat(BRACKETS).concat(TILDES);
	var PLUS_CHARS = "+\uFF0B";
	// const LEADING_PLUS_CHARS_PATTERN = new RegExp('^[' + PLUS_CHARS + ']+')

	var CAPTURING_DIGIT_PATTERN = new RegExp('([' + VALID_DIGITS + '])');
	function stripIddPrefix(number, country, callingCode, metadata) {
	  if (!country) {
	    return;
	  }
	  // Check if the number is IDD-prefixed.
	  var countryMetadata = new Metadata(metadata);
	  countryMetadata.selectNumberingPlan(country, callingCode);
	  var IDDPrefixPattern = new RegExp(countryMetadata.IDDPrefix());
	  if (number.search(IDDPrefixPattern) !== 0) {
	    return;
	  }
	  // Strip IDD prefix.
	  number = number.slice(number.match(IDDPrefixPattern)[0].length);
	  // If there're any digits after an IDD prefix,
	  // then those digits are a country calling code.
	  // Since no country code starts with a `0`,
	  // the code below validates that the next digit (if present) is not `0`.
	  var matchedGroups = number.match(CAPTURING_DIGIT_PATTERN);
	  if (matchedGroups && matchedGroups[1] != null && matchedGroups[1].length > 0) {
	    if (matchedGroups[1] === '0') {
	      return;
	    }
	  }
	  return number;
	}

	/**
	 * Strips any national prefix (such as 0, 1) present in a
	 * (possibly incomplete) number provided.
	 * "Carrier codes" are only used  in Colombia and Brazil,
	 * and only when dialing within those countries from a mobile phone to a fixed line number.
	 * Sometimes it won't actually strip national prefix
	 * and will instead prepend some digits to the `number`:
	 * for example, when number `2345678` is passed with `VI` country selected,
	 * it will return `{ number: "3402345678" }`, because `340` area code is prepended.
	 * @param {string} number  National number digits.
	 * @param {object} metadata  Metadata with country selected.
	 * @return {object} `{ nationalNumber: string, nationalPrefix: string? carrierCode: string? }`. Even if a national prefix was extracted, it's not necessarily present in the returned object, so don't rely on its presence in the returned object in order to find out whether a national prefix has been extracted or not.
	 */
	function extractNationalNumberFromPossiblyIncompleteNumber(number, metadata) {
	  if (number && metadata.numberingPlan.nationalPrefixForParsing()) {
	    // See METADATA.md for the description of
	    // `national_prefix_for_parsing` and `national_prefix_transform_rule`.
	    // Attempt to parse the first digits as a national prefix.
	    var prefixPattern = new RegExp('^(?:' + metadata.numberingPlan.nationalPrefixForParsing() + ')');
	    var prefixMatch = prefixPattern.exec(number);
	    if (prefixMatch) {
	      var nationalNumber;
	      var carrierCode;
	      // https://gitlab.com/catamphetamine/libphonenumber-js/-/blob/master/METADATA.md#national_prefix_for_parsing--national_prefix_transform_rule
	      // If a `national_prefix_for_parsing` has any "capturing groups"
	      // then it means that the national (significant) number is equal to
	      // those "capturing groups" transformed via `national_prefix_transform_rule`,
	      // and nothing could be said about the actual national prefix:
	      // what is it and was it even there.
	      // If a `national_prefix_for_parsing` doesn't have any "capturing groups",
	      // then everything it matches is a national prefix.
	      // To determine whether `national_prefix_for_parsing` matched any
	      // "capturing groups", the value of the result of calling `.exec()`
	      // is looked at, and if it has non-undefined values where there're
	      // "capturing groups" in the regular expression, then it means
	      // that "capturing groups" have been matched.
	      // It's not possible to tell whether there'll be any "capturing gropus"
	      // before the matching process, because a `national_prefix_for_parsing`
	      // could exhibit both behaviors.
	      var capturedGroupsCount = prefixMatch.length - 1;
	      var hasCapturedGroups = capturedGroupsCount > 0 && prefixMatch[capturedGroupsCount];
	      if (metadata.nationalPrefixTransformRule() && hasCapturedGroups) {
	        nationalNumber = number.replace(prefixPattern, metadata.nationalPrefixTransformRule());
	        // If there's more than one captured group,
	        // then carrier code is the second one.
	        if (capturedGroupsCount > 1) {
	          carrierCode = prefixMatch[1];
	        }
	      }
	      // If there're no "capturing groups",
	      // or if there're "capturing groups" but no
	      // `national_prefix_transform_rule`,
	      // then just strip the national prefix from the number,
	      // and possibly a carrier code.
	      // Seems like there could be more.
	      else {
	        // `prefixBeforeNationalNumber` is the whole substring matched by
	        // the `national_prefix_for_parsing` regular expression.
	        // There seem to be no guarantees that it's just a national prefix.
	        // For example, if there's a carrier code, it's gonna be a
	        // part of `prefixBeforeNationalNumber` too.
	        var prefixBeforeNationalNumber = prefixMatch[0];
	        nationalNumber = number.slice(prefixBeforeNationalNumber.length);
	        // If there's at least one captured group,
	        // then carrier code is the first one.
	        if (hasCapturedGroups) {
	          carrierCode = prefixMatch[1];
	        }
	      }
	      // Tries to guess whether a national prefix was present in the input.
	      // This is not something copy-pasted from Google's library:
	      // they don't seem to have an equivalent for that.
	      // So this isn't an "officially approved" way of doing something like that.
	      // But since there seems no other existing method, this library uses it.
	      var nationalPrefix;
	      if (hasCapturedGroups) {
	        var possiblePositionOfTheFirstCapturedGroup = number.indexOf(prefixMatch[1]);
	        var possibleNationalPrefix = number.slice(0, possiblePositionOfTheFirstCapturedGroup);
	        // Example: an Argentinian (AR) phone number `0111523456789`.
	        // `prefixMatch[0]` is `01115`, and `$1` is `11`,
	        // and the rest of the phone number is `23456789`.
	        // The national number is transformed via `9$1` to `91123456789`.
	        // National prefix `0` is detected being present at the start.
	        // if (possibleNationalPrefix.indexOf(metadata.numberingPlan.nationalPrefix()) === 0) {
	        if (possibleNationalPrefix === metadata.numberingPlan.nationalPrefix()) {
	          nationalPrefix = metadata.numberingPlan.nationalPrefix();
	        }
	      } else {
	        nationalPrefix = prefixMatch[0];
	      }
	      return {
	        nationalNumber: nationalNumber,
	        nationalPrefix: nationalPrefix,
	        carrierCode: carrierCode
	      };
	    }
	  }
	  return {
	    nationalNumber: number
	  };
	}

	function _createForOfIteratorHelperLoose$1(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (t) return (t = t.call(r)).next.bind(t); if (Array.isArray(r) || (t = _unsupportedIterableToArray$2(r)) || e) { t && (r = t); var o = 0; return function () { return o >= r.length ? { done: true } : { done: false, value: r[o++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
	function _unsupportedIterableToArray$2(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray$2(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray$2(r, a) : void 0; } }
	function _arrayLikeToArray$2(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }

	// Returns the exact country that the `nationalPhoneNumber` belongs to
	// in cases of ambiguity, i.e. when multiple countries share the same "country calling code".
	function getCountryByNationalNumber(nationalPhoneNumber, _ref) {
	  var countries = _ref.countries,
	    metadata = _ref.metadata;
	  // Re-create `metadata` because it will be selecting a `country`.
	  metadata = new Metadata(metadata);

	  // const matchingCountries = []

	  for (var _iterator = _createForOfIteratorHelperLoose$1(countries), _step; !(_step = _iterator()).done;) {
	    var country = _step.value;
	    metadata.selectNumberingPlan(country);
	    // "Leading digits" patterns are only defined for about 20% of all countries.
	    // By definition, matching "leading digits" is a sufficient but not a necessary
	    // condition for a phone number to belong to a country.
	    // The point of "leading digits" check is that it's the fastest one to get a match.
	    // https://gitlab.com/catamphetamine/libphonenumber-js/blob/master/METADATA.md#leading_digits
	    // I'd suppose that "leading digits" patterns are mutually exclusive for different countries
	    // because of the intended use of that feature.
	    if (metadata.leadingDigits()) {
	      if (nationalPhoneNumber && nationalPhoneNumber.search(metadata.leadingDigits()) === 0) {
	        return country;
	      }
	    }
	    // Else perform full validation with all of those
	    // fixed-line/mobile/etc regular expressions.
	    else if (getNumberType({
	      phone: nationalPhoneNumber,
	      country: country
	    }, undefined, metadata.metadata)) {
	      // When multiple countries share the same "country calling code",
	      // type patterns aren't guaranteed to be unique among them.
	      // For example, both `US` and `CA` have the same pattern for `toll_free` numbers.
	      // https://gitlab.com/catamphetamine/libphonenumber-js/-/issues/103#note_1417147572
	      //
	      // That means that this `if` condition could be `true` for multiple countries from the list.
	      // Currently, it just returns the first one, which is also the "main" country for the "country calling code".
	      // In an example with `toll_free` numbers above, `"US"` would be returned even though
	      // it could as well be `"CA"`.
	      //
	      // There was also a time when this attempted to be overly smart
	      // and kept track of all such multiple matching countries
	      // and then picked the one that matched the `defaultCountry`, if provided.
	      // For example, with `toll_free` numbers above, and with `defaultCountry: "CA"`,
	      // it would've returned `"CA"` instead of `"US"`.
	      // Later it turned out that such "overly smart" behavior turned out to be just confusing,
	      // so this "overly smart" country detection was reverted to returning the "main" country
	      // for the "country calling code".
	      // https://gitlab.com/catamphetamine/libphonenumber-js/-/issues/154
	      //
	      return country;
	      //
	      // The "overly smart" behavior code:
	      //
	      // if (defaultCountry) {
	      // 	if (country === defaultCountry) {
	      // 		return country
	      // 	} else {
	      // 		matchingCountries.push(country)
	      // 	}
	      // } else {
	      // 	return country
	      // }
	    }
	  }

	  // // Return the first ("main") one of the `matchingCountries`.
	  // if (matchingCountries.length > 0) {
	  // 	return matchingCountries[0]
	  // }
	}

	// Returns the exact country for the `nationalNumber`
	// that belongs to the specified "country calling code".
	function getCountryByCallingCode(callingCode, _ref) {
	  var nationalPhoneNumber = _ref.nationalNumber,
	    metadata = _ref.metadata;
	  var possibleCountries = metadata.getCountryCodesForCallingCode(callingCode);
	  if (!possibleCountries) {
	    return;
	  }
	  // If there's just one country corresponding to the country code,
	  // then just return it, without further phone number digits validation.
	  if (possibleCountries.length === 1) {
	    return possibleCountries[0];
	  }
	  return getCountryByNationalNumber(nationalPhoneNumber, {
	    countries: possibleCountries,
	    metadata: metadata.metadata
	  });
	}

	/**
	 * Strips national prefix and carrier code from a complete phone number.
	 * The difference from the non-"FromCompleteNumber" function is that
	 * it won't extract national prefix if the resultant number is too short
	 * to be a complete number for the selected phone numbering plan.
	 * @param  {string} number  Complete phone number digits.
	 * @param  {string?} country  Country, if known.
	 * @param  {Metadata} metadata  Metadata with a phone numbering plan selected.
	 * @return {object} `{ nationalNumber: string, carrierCode: string? }`.
	 */
	function extractNationalNumber(number, country, metadata) {
	  // Parsing national prefixes and carrier codes
	  // is only required for local phone numbers
	  // but some people don't understand that
	  // and sometimes write international phone numbers
	  // with national prefixes (or maybe even carrier codes).
	  // http://ucken.blogspot.ru/2016/03/trunk-prefixes-in-skype4b.html
	  // Google's original library forgives such mistakes
	  // and so does this library, because it has been requested:
	  // https://github.com/catamphetamine/libphonenumber-js/issues/127
	  var _extractNationalNumbe = extractNationalNumberFromPossiblyIncompleteNumber(number, metadata),
	    carrierCode = _extractNationalNumbe.carrierCode,
	    nationalNumber = _extractNationalNumbe.nationalNumber;
	  if (nationalNumber !== number) {
	    if (!shouldHaveExtractedNationalPrefix(number, nationalNumber, metadata)) {
	      // Don't strip the national prefix.
	      return {
	        nationalNumber: number
	      };
	    }
	    // Check the national (significant) number length after extracting national prefix and carrier code.
	    // Legacy generated metadata (before `1.0.18`) didn't support the "possible lengths" feature.
	    if (metadata.numberingPlan.possibleLengths()) {
	      // If an exact `country` is not specified, attempt to detect it from the assumed national number.
	      if (!country) {
	        country = getCountryByCallingCode(metadata.numberingPlan.callingCode(), {
	          nationalNumber: nationalNumber,
	          metadata: metadata
	        });
	      }

	      // The number remaining after stripping the national prefix and carrier code
	      // should be long enough to have a possible length for the country.
	      // Otherwise, don't strip the national prefix and carrier code,
	      // since the original number could be a valid number.
	      // This check has been copy-pasted "as is" from Google's original library:
	      // https://github.com/google/libphonenumber/blob/876268eb1ad6cdc1b7b5bef17fc5e43052702d57/java/libphonenumber/src/com/google/i18n/phonenumbers/PhoneNumberUtil.java#L3236-L3250
	      // It doesn't check for the "possibility" of the original `number`.
	      // I guess it's fine not checking that one. It works as is anyway.
	      if (!isPossibleIncompleteNationalNumber(nationalNumber, country, metadata)) {
	        // Don't strip the national prefix.
	        return {
	          nationalNumber: number
	        };
	      }
	    }
	  }
	  return {
	    nationalNumber: nationalNumber,
	    carrierCode: carrierCode
	  };
	}

	// In some countries, the same digit could be a national prefix
	// or a leading digit of a valid phone number.
	// For example, in Russia, national prefix is `8`,
	// and also `800 555 35 35` is a valid number
	// in which `8` is not a national prefix, but the first digit
	// of a national (significant) number.
	// Same's with Belarus:
	// `82004910060` is a valid national (significant) number,
	// but `2004910060` is not.
	// To support such cases (to prevent the code from always stripping
	// national prefix), a condition is imposed: a national prefix
	// is not extracted when the original number is "viable" and the
	// resultant number is not, a "viable" national number being the one
	// that matches `national_number_pattern`.
	function shouldHaveExtractedNationalPrefix(nationalNumberBefore, nationalNumberAfter, metadata) {
	  // The equivalent in Google's code is:
	  // https://github.com/google/libphonenumber/blob/e326fa1fc4283bb05eb35cb3c15c18f98a31af33/java/libphonenumber/src/com/google/i18n/phonenumbers/PhoneNumberUtil.java#L2969-L3004
	  if (matchesEntirely(nationalNumberBefore, metadata.nationalNumberPattern()) && !matchesEntirely(nationalNumberAfter, metadata.nationalNumberPattern())) {
	    return false;
	  }
	  // This "is possible" national number (length) check has been commented out
	  // because it's superceded by the (effectively) same check done in the
	  // `extractNationalNumber()` function after it calls `shouldHaveExtractedNationalPrefix()`.
	  // In other words, why run the same check twice if it could only be run once.
	  // // Check the national (significant) number length after extracting national prefix and carrier code.
	  // // Fixes a minor "weird behavior" bug: https://gitlab.com/catamphetamine/libphonenumber-js/-/issues/57
	  // // (Legacy generated metadata (before `1.0.18`) didn't support the "possible lengths" feature).
	  // if (metadata.possibleLengths()) {
	  // 	if (isPossibleIncompleteNationalNumber(nationalNumberBefore, metadata) &&
	  // 		!isPossibleIncompleteNationalNumber(nationalNumberAfter, metadata)) {
	  // 		return false
	  // 	}
	  // }
	  return true;
	}
	function isPossibleIncompleteNationalNumber(nationalNumber, country, metadata) {
	  switch (checkNumberLength(nationalNumber, country, metadata)) {
	    case 'TOO_SHORT':
	    case 'INVALID_LENGTH':
	      // This library ignores "local-only" phone numbers (for simplicity).
	      // See the readme for more info on what are "local-only" phone numbers.
	      // case 'IS_POSSIBLE_LOCAL_ONLY':
	      return false;
	    default:
	      return true;
	  }
	}

	/**
	 * Sometimes some people incorrectly input international phone numbers
	 * without the leading `+`. This function corrects such input.
	 * @param  {string} number  Phone number digits.
	 * @param  {string} [country] Exact country of the phone number.
	 * @param  {string} [defaultCountry]
	 * @param  {string} [defaultCallingCode]
	 * @param  {object} metadata
	 * @return {object} `{ countryCallingCode: string?, number: string }`.
	 */
	function extractCountryCallingCodeFromInternationalNumberWithoutPlusSign(number, country, defaultCountry, defaultCallingCode, metadata) {
	  var countryCallingCode = defaultCountry ? getCountryCallingCode(defaultCountry, metadata) : defaultCallingCode;
	  if (number.indexOf(countryCallingCode) === 0) {
	    metadata = new Metadata(metadata);
	    metadata.selectNumberingPlan(defaultCountry, countryCallingCode);
	    var possibleShorterNumber = number.slice(countryCallingCode.length);
	    var _extractNationalNumbe = extractNationalNumber(possibleShorterNumber, country, metadata),
	      possibleShorterNationalNumber = _extractNationalNumbe.nationalNumber;
	    var _extractNationalNumbe2 = extractNationalNumber(number, country, metadata),
	      nationalNumber = _extractNationalNumbe2.nationalNumber;

	    // If the number was not valid before but is valid now,
	    // or if it was too long before, we consider the number
	    // with the country calling code stripped to be a better result
	    // and keep that instead.
	    // For example, in Germany (+49), `49` is a valid area code,
	    // so if a number starts with `49`, it could be both a valid
	    // national German number or an international number without
	    // a leading `+`.
	    if (!matchesEntirely(nationalNumber, metadata.nationalNumberPattern()) && matchesEntirely(possibleShorterNationalNumber, metadata.nationalNumberPattern()) || checkNumberLength(nationalNumber, country, metadata) === 'TOO_LONG') {
	      return {
	        countryCallingCode: countryCallingCode,
	        number: possibleShorterNumber
	      };
	    }
	  }
	  return {
	    number: number
	  };
	}

	/**
	 * Converts a phone number digits (possibly with a `+`)
	 * into a calling code and the rest phone number digits.
	 * The "rest phone number digits" could include
	 * a national prefix, carrier code, and national
	 * (significant) number.
	 * @param  {string} number  Phone number digits (possibly with a `+`).
	 * @param  {string} [country] Country.
	 * @param  {string} [defaultCountry] Default country.
	 * @param  {string} [defaultCallingCode]  Default calling code (some phone numbering plans are non-geographic).
	 * @param  {object} metadata
	 * @return {object} `{ countryCallingCodeSource: string?, countryCallingCode: string?, number: string }`
	 * @example
	 * // Returns `{ countryCallingCode: "1", number: "2133734253" }`.
	 * extractCountryCallingCode('2133734253', null, 'US', null, metadata)
	 * extractCountryCallingCode('2133734253', null, null, '1', metadata)
	 * extractCountryCallingCode('+12133734253', null, null, null, metadata)
	 * extractCountryCallingCode('+12133734253', null, 'RU', null, metadata)
	 */
	function extractCountryCallingCode(number, country, defaultCountry, defaultCallingCode, metadata) {
	  if (!number) {
	    return {};
	  }
	  var isNumberWithIddPrefix;

	  // If this is not an international phone number,
	  // then either extract an "IDD" prefix, or extract a
	  // country calling code from a number by autocorrecting it
	  // by prepending a leading `+` in cases when it starts
	  // with the country calling code.
	  // https://wikitravel.org/en/International_dialling_prefix
	  // https://github.com/catamphetamine/libphonenumber-js/issues/376
	  if (number[0] !== '+') {
	    // Convert an "out-of-country" dialing phone number
	    // to a proper international phone number.
	    var numberWithoutIDD = stripIddPrefix(number, defaultCountry, defaultCallingCode, metadata);
	    // If an IDD prefix was stripped then
	    // convert the number to international one
	    // for subsequent parsing.
	    if (numberWithoutIDD && numberWithoutIDD !== number) {
	      isNumberWithIddPrefix = true;
	      number = '+' + numberWithoutIDD;
	    } else {
	      // Check to see if the number starts with the country calling code
	      // for the default country. If so, we remove the country calling code,
	      // and do some checks on the validity of the number before and after.
	      // https://github.com/catamphetamine/libphonenumber-js/issues/376
	      if (defaultCountry || defaultCallingCode) {
	        var _extractCountryCallin = extractCountryCallingCodeFromInternationalNumberWithoutPlusSign(number, country, defaultCountry, defaultCallingCode, metadata),
	          countryCallingCode = _extractCountryCallin.countryCallingCode,
	          shorterNumber = _extractCountryCallin.number;
	        if (countryCallingCode) {
	          return {
	            countryCallingCodeSource: 'FROM_NUMBER_WITHOUT_PLUS_SIGN',
	            countryCallingCode: countryCallingCode,
	            number: shorterNumber
	          };
	        }
	      }
	      return {
	        // No need to set it to `UNSPECIFIED`. It can be just `undefined`.
	        // countryCallingCodeSource: 'UNSPECIFIED',
	        number: number
	      };
	    }
	  }

	  // `number` can only be international at this point.

	  // Fast abortion: country codes do not begin with a '0'
	  if (number[1] === '0') {
	    return {};
	  }
	  metadata = new Metadata(metadata);

	  // The thing with country phone codes
	  // is that they are orthogonal to each other
	  // i.e. there's no such country phone code A
	  // for which country phone code B exists
	  // where B starts with A.
	  // Therefore, while scanning digits,
	  // if a valid country code is found,
	  // that means that it is the country code.
	  //
	  var i = 2;
	  while (i - 1 <= MAX_LENGTH_COUNTRY_CODE && i <= number.length) {
	    var _countryCallingCode = number.slice(1, i);
	    if (metadata.hasCallingCode(_countryCallingCode)) {
	      metadata.selectNumberingPlan(_countryCallingCode);
	      return {
	        countryCallingCodeSource: isNumberWithIddPrefix ? 'FROM_NUMBER_WITH_IDD' : 'FROM_NUMBER_WITH_PLUS_SIGN',
	        countryCallingCode: _countryCallingCode,
	        number: number.slice(i)
	      };
	    }
	    i++;
	  }
	  return {};
	}

	// The possible values for the returned `countryCallingCodeSource` are:
	//
	// Copy-pasted from:
	// https://github.com/google/libphonenumber/blob/master/resources/phonenumber.proto
	//
	// // The source from which the country_code is derived. This is not set in the
	// // general parsing method, but in the method that parses and keeps raw_input.
	// // New fields could be added upon request.
	// enum CountryCodeSource {
	//  // Default value returned if this is not set, because the phone number was
	//  // created using parse, not parseAndKeepRawInput. hasCountryCodeSource will
	//  // return false if this is the case.
	//  UNSPECIFIED = 0;
	//
	//  // The country_code is derived based on a phone number with a leading "+",
	//  // e.g. the French number "+33 1 42 68 53 00".
	//  FROM_NUMBER_WITH_PLUS_SIGN = 1;
	//
	//  // The country_code is derived based on a phone number with a leading IDD,
	//  // e.g. the French number "011 33 1 42 68 53 00", as it is dialled from US.
	//  FROM_NUMBER_WITH_IDD = 5;
	//
	//  // The country_code is derived based on a phone number without a leading
	//  // "+", e.g. the French number "33 1 42 68 53 00" when defaultCountry is
	//  // supplied as France.
	//  FROM_NUMBER_WITHOUT_PLUS_SIGN = 10;
	//
	//  // The country_code is derived NOT based on the phone number itself, but
	//  // from the defaultCountry parameter provided in the parsing function by the
	//  // clients. This happens mostly for numbers written in the national format
	//  // (without country code). For example, this would be set when parsing the
	//  // French number "01 42 68 53 00", when defaultCountry is supplied as
	//  // France.
	//  FROM_DEFAULT_COUNTRY = 20;
	// }

	// Removes brackets and replaces dashes with spaces.
	//
	// E.g. "(999) 111-22-33" -> "999 111 22 33"
	//
	// For some reason Google's metadata contains `<intlFormat/>`s with brackets and dashes.
	// Meanwhile, there's no single opinion about using punctuation in international phone numbers.
	//
	// For example, Google's `<intlFormat/>` for USA is `+1 213-373-4253`.
	// And here's a quote from WikiPedia's "North American Numbering Plan" page:
	// https://en.wikipedia.org/wiki/North_American_Numbering_Plan
	//
	// "The country calling code for all countries participating in the NANP is 1.
	// In international format, an NANP number should be listed as +1 301 555 01 00,
	// where 301 is an area code (Maryland)."
	//
	// I personally prefer the international format without any punctuation.
	// For example, brackets are remnants of the old age, meaning that the
	// phone number part in brackets (so called "area code") can be omitted
	// if dialing within the same "area".
	// And hyphens were clearly introduced for splitting local numbers into memorizable groups.
	// For example, remembering "5553535" is difficult but "555-35-35" is much simpler.
	// Imagine a man taking a bus from home to work and seeing an ad with a phone number.
	// He has a couple of seconds to memorize that number until it passes by.
	// If it were spaces instead of hyphens the man wouldn't necessarily get it,
	// but with hyphens instead of spaces the grouping is more explicit.
	// I personally think that hyphens introduce visual clutter,
	// so I prefer replacing them with spaces in international numbers.
	// In the modern age all output is done on displays where spaces are clearly distinguishable
	// so hyphens can be safely replaced with spaces without losing any legibility.
	//
	function applyInternationalSeparatorStyle(formattedNumber) {
	  return formattedNumber.replace(new RegExp("[".concat(VALID_PUNCTUATION, "]+"), 'g'), ' ').trim();
	}

	// This was originally set to $1 but there are some countries for which the
	// first group is not used in the national pattern (e.g. Argentina) so the $1
	// group does not match correctly. Therefore, we use `\d`, so that the first
	// group actually used in the pattern will be matched.
	var FIRST_GROUP_PATTERN = /(\$\d)/;
	function formatNationalNumberUsingFormat(number, format, _ref) {
	  var useInternationalFormat = _ref.useInternationalFormat,
	    withNationalPrefix = _ref.withNationalPrefix;
	  var formattedNumber = number.replace(new RegExp(format.pattern()), useInternationalFormat ? format.internationalFormat() :
	  // This library doesn't use `domestic_carrier_code_formatting_rule`,
	  // because that one is only used when formatting phone numbers
	  // for dialing from a mobile phone, and this is not a dialing library.
	  // carrierCode && format.domesticCarrierCodeFormattingRule()
	  // 	// First, replace the $CC in the formatting rule with the desired carrier code.
	  // 	// Then, replace the $FG in the formatting rule with the first group
	  // 	// and the carrier code combined in the appropriate way.
	  // 	? format.format().replace(FIRST_GROUP_PATTERN, format.domesticCarrierCodeFormattingRule().replace('$CC', carrierCode))
	  // 	: (
	  // 		withNationalPrefix && format.nationalPrefixFormattingRule()
	  // 			? format.format().replace(FIRST_GROUP_PATTERN, format.nationalPrefixFormattingRule())
	  // 			: format.format()
	  // 	)
	  withNationalPrefix && format.nationalPrefixFormattingRule() ? format.format().replace(FIRST_GROUP_PATTERN, format.nationalPrefixFormattingRule()) : format.format());
	  if (useInternationalFormat) {
	    return applyInternationalSeparatorStyle(formattedNumber);
	  }
	  return formattedNumber;
	}

	/**
	 * Pattern that makes it easy to distinguish whether a region has a single
	 * international dialing prefix or not. If a region has a single international
	 * prefix (e.g. 011 in USA), it will be represented as a string that contains
	 * a sequence of ASCII digits, and possibly a tilde, which signals waiting for
	 * the tone. If there are multiple available international prefixes in a
	 * region, they will be represented as a regex string that always contains one
	 * or more characters that are not ASCII digits or a tilde.
	 */
	var SINGLE_IDD_PREFIX_REG_EXP = /^[\d]+(?:[~\u2053\u223C\uFF5E][\d]+)?$/;

	// For regions that have multiple IDD prefixes
	// a preferred IDD prefix is returned.
	function getIddPrefix(country, callingCode, metadata) {
	  var countryMetadata = new Metadata(metadata);
	  countryMetadata.selectNumberingPlan(country, callingCode);
	  if (countryMetadata.defaultIDDPrefix()) {
	    return countryMetadata.defaultIDDPrefix();
	  }
	  if (SINGLE_IDD_PREFIX_REG_EXP.test(countryMetadata.IDDPrefix())) {
	    return countryMetadata.IDDPrefix();
	  }
	}

	// The RFC 3966 format for extensions.
	var RFC3966_EXTN_PREFIX = ';ext=';

	/**
	 * Helper method for constructing regular expressions for parsing. Creates
	 * an expression that captures up to max_length digits.
	 * @return {string} RegEx pattern to capture extension digits.
	 */
	var getExtensionDigitsPattern = function getExtensionDigitsPattern(maxLength) {
	  return "([".concat(VALID_DIGITS, "]{1,").concat(maxLength, "})");
	};

	/**
	 * Helper initialiser method to create the regular-expression pattern to match
	 * extensions.
	 * Copy-pasted from Google's `libphonenumber`:
	 * https://github.com/google/libphonenumber/blob/55b2646ec9393f4d3d6661b9c82ef9e258e8b829/javascript/i18n/phonenumbers/phonenumberutil.js#L759-L766
	 * @return {string} RegEx pattern to capture extensions.
	 */
	function createExtensionPattern(purpose) {
	  // We cap the maximum length of an extension based on the ambiguity of the way
	  // the extension is prefixed. As per ITU, the officially allowed length for
	  // extensions is actually 40, but we don't support this since we haven't seen real
	  // examples and this introduces many false interpretations as the extension labels
	  // are not standardized.
	  /** @type {string} */
	  var extLimitAfterExplicitLabel = '20';
	  /** @type {string} */
	  var extLimitAfterLikelyLabel = '15';
	  /** @type {string} */
	  var extLimitAfterAmbiguousChar = '9';
	  /** @type {string} */
	  var extLimitWhenNotSure = '6';

	  /** @type {string} */
	  var possibleSeparatorsBetweenNumberAndExtLabel = "[ \xA0\\t,]*";
	  // Optional full stop (.) or colon, followed by zero or more spaces/tabs/commas.
	  /** @type {string} */
	  var possibleCharsAfterExtLabel = "[:\\.\uFF0E]?[ \xA0\\t,-]*";
	  /** @type {string} */
	  var optionalExtnSuffix = "#?";

	  // Here the extension is called out in more explicit way, i.e mentioning it obvious
	  // patterns like "ext.".
	  /** @type {string} */
	  var explicitExtLabels = "(?:e?xt(?:ensi(?:o\u0301?|\xF3))?n?|\uFF45?\uFF58\uFF54\uFF4E?|\u0434\u043E\u0431|anexo)";
	  // One-character symbols that can be used to indicate an extension, and less
	  // commonly used or more ambiguous extension labels.
	  /** @type {string} */
	  var ambiguousExtLabels = "(?:[x\uFF58#\uFF03~\uFF5E]|int|\uFF49\uFF4E\uFF54)";
	  // When extension is not separated clearly.
	  /** @type {string} */
	  var ambiguousSeparator = "[- ]+";
	  // This is the same as possibleSeparatorsBetweenNumberAndExtLabel, but not matching
	  // comma as extension label may have it.
	  /** @type {string} */
	  var possibleSeparatorsNumberExtLabelNoComma = "[ \xA0\\t]*";
	  // ",," is commonly used for auto dialling the extension when connected. First
	  // comma is matched through possibleSeparatorsBetweenNumberAndExtLabel, so we do
	  // not repeat it here. Semi-colon works in Iphone and Android also to pop up a
	  // button with the extension number following.
	  /** @type {string} */
	  var autoDiallingAndExtLabelsFound = "(?:,{2}|;)";

	  /** @type {string} */
	  var rfcExtn = RFC3966_EXTN_PREFIX + getExtensionDigitsPattern(extLimitAfterExplicitLabel);
	  /** @type {string} */
	  var explicitExtn = possibleSeparatorsBetweenNumberAndExtLabel + explicitExtLabels + possibleCharsAfterExtLabel + getExtensionDigitsPattern(extLimitAfterExplicitLabel) + optionalExtnSuffix;
	  /** @type {string} */
	  var ambiguousExtn = possibleSeparatorsBetweenNumberAndExtLabel + ambiguousExtLabels + possibleCharsAfterExtLabel + getExtensionDigitsPattern(extLimitAfterAmbiguousChar) + optionalExtnSuffix;
	  /** @type {string} */
	  var americanStyleExtnWithSuffix = ambiguousSeparator + getExtensionDigitsPattern(extLimitWhenNotSure) + "#";

	  /** @type {string} */
	  var autoDiallingExtn = possibleSeparatorsNumberExtLabelNoComma + autoDiallingAndExtLabelsFound + possibleCharsAfterExtLabel + getExtensionDigitsPattern(extLimitAfterLikelyLabel) + optionalExtnSuffix;
	  /** @type {string} */
	  var onlyCommasExtn = possibleSeparatorsNumberExtLabelNoComma + "(?:,)+" + possibleCharsAfterExtLabel + getExtensionDigitsPattern(extLimitAfterAmbiguousChar) + optionalExtnSuffix;

	  // The first regular expression covers RFC 3966 format, where the extension is added
	  // using ";ext=". The second more generic where extension is mentioned with explicit
	  // labels like "ext:". In both the above cases we allow more numbers in extension than
	  // any other extension labels. The third one captures when single character extension
	  // labels or less commonly used labels are used. In such cases we capture fewer
	  // extension digits in order to reduce the chance of falsely interpreting two
	  // numbers beside each other as a number + extension. The fourth one covers the
	  // special case of American numbers where the extension is written with a hash
	  // at the end, such as "- 503#". The fifth one is exclusively for extension
	  // autodialling formats which are used when dialling and in this case we accept longer
	  // extensions. The last one is more liberal on the number of commas that acts as
	  // extension labels, so we have a strict cap on the number of digits in such extensions.
	  return rfcExtn + "|" + explicitExtn + "|" + ambiguousExtn + "|" + americanStyleExtnWithSuffix + "|" + autoDiallingExtn + "|" + onlyCommasExtn;
	}

	//  Regular expression of viable phone numbers. This is location independent.
	//  Checks we have at least three leading digits, and only valid punctuation,
	//  alpha characters and digits in the phone number. Does not include extension
	//  data. The symbol 'x' is allowed here as valid punctuation since it is often
	//  used as a placeholder for carrier codes, for example in Brazilian phone
	//  numbers. We also allow multiple '+' characters at the start.
	//
	//  Corresponds to the following:
	//  [digits]{minLengthNsn}|
	//  plus_sign*
	//  (([punctuation]|[star])*[digits]){3,}([punctuation]|[star]|[digits]|[alpha])*
	//
	//  The first reg-ex is to allow short numbers (two digits long) to be parsed if
	//  they are entered as "15" etc, but only if there is no punctuation in them.
	//  The second expression restricts the number of digits to three or more, but
	//  then allows them to be in international form, and to have alpha-characters
	//  and punctuation. We split up the two reg-exes here and combine them when
	//  creating the reg-ex VALID_PHONE_NUMBER_PATTERN itself so we can prefix it
	//  with ^ and append $ to each branch.
	//
	//  "Note VALID_PUNCTUATION starts with a -,
	//   so must be the first in the range" (c) Google devs.
	//  (wtf did they mean by saying that; probably nothing)
	//
	var MIN_LENGTH_PHONE_NUMBER_PATTERN = '[' + VALID_DIGITS + ']{' + MIN_LENGTH_FOR_NSN + '}';
	//
	// And this is the second reg-exp:
	// (see MIN_LENGTH_PHONE_NUMBER_PATTERN for a full description of this reg-exp)
	//
	var VALID_PHONE_NUMBER = '[' + PLUS_CHARS + ']{0,1}' + '(?:' + '[' + VALID_PUNCTUATION + ']*' + '[' + VALID_DIGITS + ']' + '){3,}' + '[' + VALID_PUNCTUATION + VALID_DIGITS + ']*';

	// This regular expression isn't present in Google's `libphonenumber`
	// and is only used to determine whether the phone number being input
	// is too short for it to even consider it a "valid" number.
	// This is just a way to differentiate between a really invalid phone
	// number like "abcde" and a valid phone number that a user has just
	// started inputting, like "+1" or "1": both these cases would be
	// considered `NOT_A_NUMBER` by Google's `libphonenumber`, but this
	// library can provide a more detailed error message  whether it's
	// really "not a number", or is it just a start of a valid phone number.
	var VALID_PHONE_NUMBER_START_REG_EXP = new RegExp('^' + '[' + PLUS_CHARS + ']{0,1}' + '(?:' + '[' + VALID_PUNCTUATION + ']*' + '[' + VALID_DIGITS + ']' + '){1,2}' + '$', 'i');
	var VALID_PHONE_NUMBER_WITH_EXTENSION = VALID_PHONE_NUMBER +
	// Phone number extensions
	'(?:' + createExtensionPattern() + ')?';

	// The combined regular expression for valid phone numbers:
	//
	var VALID_PHONE_NUMBER_PATTERN = new RegExp(
	// Either a short two-digit-only phone number
	'^' + MIN_LENGTH_PHONE_NUMBER_PATTERN + '$' + '|' +
	// Or a longer fully parsed phone number (min 3 characters)
	'^' + VALID_PHONE_NUMBER_WITH_EXTENSION + '$', 'i');

	// Checks to see if the string of characters could possibly be a phone number at
	// all. At the moment, checks to see that the string begins with at least 2
	// digits, ignoring any punctuation commonly found in phone numbers. This method
	// does not require the number to be normalized in advance - but does assume
	// that leading non-number symbols have been removed, such as by the method
	// `extract_possible_number`.
	//
	function isViablePhoneNumber(number) {
	  return number.length >= MIN_LENGTH_FOR_NSN && VALID_PHONE_NUMBER_PATTERN.test(number);
	}

	// This is just a way to differentiate between a really invalid phone
	// number like "abcde" and a valid phone number that a user has just
	// started inputting, like "+1" or "1": both these cases would be
	// considered `NOT_A_NUMBER` by Google's `libphonenumber`, but this
	// library can provide a more detailed error message  whether it's
	// really "not a number", or is it just a start of a valid phone number.
	function isViablePhoneNumberStart(number) {
	  return VALID_PHONE_NUMBER_START_REG_EXP.test(number);
	}

	/**
	 * @param  {object} - `{ ?number, ?extension }`.
	 * @return {string} Phone URI (RFC 3966).
	 */
	function formatRFC3966(_ref) {
	  var number = _ref.number,
	    ext = _ref.ext;
	  if (!number) {
	    return '';
	  }
	  if (number[0] !== '+') {
	    throw new Error("\"formatRFC3966()\" expects \"number\" to be in E.164 format.");
	  }
	  return "tel:".concat(number).concat(ext ? ';ext=' + ext : '');
	}

	// This is a port of Google Android `libphonenumber`'s
	// `phonenumberutil.js` of December 31th, 2018.
	//
	// https://github.com/googlei18n/libphonenumber/commits/master/javascript/i18n/phonenumbers/phonenumberutil.js

	var DEFAULT_OPTIONS = {
	  formatExtension: function formatExtension(formattedNumber, extension, metadata) {
	    return "".concat(formattedNumber).concat(metadata.ext()).concat(extension);
	  }
	};

	/**
	 * Formats a phone number.
	 *
	 * format(phoneNumberInstance, 'INTERNATIONAL', { ..., v2: true }, metadata)
	 * format(phoneNumberInstance, 'NATIONAL', { ..., v2: true }, metadata)
	 *
	 * format({ phone: '8005553535', country: 'RU' }, 'INTERNATIONAL', { ... }, metadata)
	 * format({ phone: '8005553535', country: 'RU' }, 'NATIONAL', undefined, metadata)
	 *
	 * @param  {object|PhoneNumber} input  If `options.v2: true` flag is passed, the `input` should be a `PhoneNumber` instance. Otherwise, it should be an object of shape `{ phone: '...', country: '...' }`.
	 * @param  {string} format
	 * @param  {object} [options]
	 * @param  {object} metadata
	 * @return {string}
	 */
	function formatNumber(input, format, options, metadata) {
	  // Apply default options.
	  if (options) {
	    // Using ES6 "rest spread" syntax here didn't work with `babel`/`istanbul`
	    // for some weird reason: this line of code would cause the code coverage
	    // to show as not 100%. That's because `babel`/`istanbul`, for some weird reason,
	    // apparently doesn't know how to properly exclude Babel polyfills from code coverage.
	    //
	    // options = { ...DEFAULT_OPTIONS, ...options }
	    //
	    options = merge({}, DEFAULT_OPTIONS, options);
	  } else {
	    options = DEFAULT_OPTIONS;
	  }
	  metadata = new Metadata(metadata);
	  if (input.country && input.country !== '001') {
	    // Validate `input.country`.
	    if (!metadata.hasCountry(input.country)) {
	      throw new Error("Unknown country: ".concat(input.country));
	    }
	    metadata.selectNumberingPlan(input.country);
	  } else if (input.countryCallingCode) {
	    metadata.selectNumberingPlan(input.countryCallingCode);
	  } else return input.phone || '';
	  var countryCallingCode = metadata.countryCallingCode();
	  var nationalNumber = options.v2 ? input.nationalNumber : input.phone;

	  // This variable should have been declared inside `case`s
	  // but Babel has a bug and it says "duplicate variable declaration".
	  var number;
	  switch (format) {
	    case 'NATIONAL':
	      // Legacy argument support.
	      // (`{ country: ..., phone: '' }`)
	      if (!nationalNumber) {
	        return '';
	      }
	      number = formatNationalNumber(nationalNumber, input.carrierCode, 'NATIONAL', metadata, options);
	      return addExtension(number, input.ext, metadata, options.formatExtension);
	    case 'INTERNATIONAL':
	      // Legacy argument support.
	      // (`{ country: ..., phone: '' }`)
	      if (!nationalNumber) {
	        return "+".concat(countryCallingCode);
	      }
	      number = formatNationalNumber(nationalNumber, null, 'INTERNATIONAL', metadata, options);
	      number = "+".concat(countryCallingCode, " ").concat(number);
	      return addExtension(number, input.ext, metadata, options.formatExtension);
	    case 'E.164':
	      // `E.164` doesn't define "phone number extensions".
	      return "+".concat(countryCallingCode).concat(nationalNumber);
	    case 'RFC3966':
	      return formatRFC3966({
	        number: "+".concat(countryCallingCode).concat(nationalNumber),
	        ext: input.ext
	      });

	    // For reference, here's Google's IDD formatter:
	    // https://github.com/google/libphonenumber/blob/32719cf74e68796788d1ca45abc85dcdc63ba5b9/java/libphonenumber/src/com/google/i18n/phonenumbers/PhoneNumberUtil.java#L1546
	    // Not saying that this IDD formatter replicates it 1:1, but it seems to work.
	    // Who would even need to format phone numbers in IDD format anyway?
	    case 'IDD':
	      if (!options.fromCountry) {
	        return;
	        // throw new Error('`fromCountry` option not passed for IDD-prefixed formatting.')
	      }
	      var formattedNumber = formatIDD(nationalNumber, input.carrierCode, countryCallingCode, options.fromCountry, metadata);
	      return addExtension(formattedNumber, input.ext, metadata, options.formatExtension);
	    default:
	      throw new Error("Unknown \"format\" argument passed to \"formatNumber()\": \"".concat(format, "\""));
	  }
	}
	function formatNationalNumber(number, carrierCode, formatAs, metadata, options) {
	  var format = chooseFormatForNumber(metadata.formats(), number);
	  if (!format) {
	    return number;
	  }
	  return formatNationalNumberUsingFormat(number, format, {
	    useInternationalFormat: formatAs === 'INTERNATIONAL',
	    withNationalPrefix: format.nationalPrefixIsOptionalWhenFormattingInNationalFormat() && options && options.nationalPrefix === false ? false : true});
	}
	function chooseFormatForNumber(availableFormats, nationalNumber) {
	  // Using a `for ... of` loop here didn't work with `babel`/`istanbul`:
	  // for some weird reason, it showed code coverage less than 100%.
	  // That's because `babel`/`istanbul`, for some weird reason,
	  // apparently doesn't know how to properly exclude Babel polyfills from code coverage.
	  //
	  // for (const format of availableFormats) { ... }
	  //
	  return pickFirstMatchingElement(availableFormats, function (format) {
	    // Validate leading digits.
	    // The test case for "else path" could be found by searching for
	    // "format.leadingDigitsPatterns().length === 0".
	    if (format.leadingDigitsPatterns().length > 0) {
	      // The last leading_digits_pattern is used here, as it is the most detailed
	      var lastLeadingDigitsPattern = format.leadingDigitsPatterns()[format.leadingDigitsPatterns().length - 1];
	      // If leading digits don't match then move on to the next phone number format
	      if (nationalNumber.search(lastLeadingDigitsPattern) !== 0) {
	        return false;
	      }
	    }
	    // Check that the national number matches the phone number format regular expression
	    return matchesEntirely(nationalNumber, format.pattern());
	  });
	}
	function addExtension(formattedNumber, ext, metadata, formatExtension) {
	  return ext ? formatExtension(formattedNumber, ext, metadata) : formattedNumber;
	}
	function formatIDD(nationalNumber, carrierCode, countryCallingCode, fromCountry, metadata) {
	  var fromCountryCallingCode = getCountryCallingCode(fromCountry, metadata.metadata);
	  // When calling within the same country calling code.
	  if (fromCountryCallingCode === countryCallingCode) {
	    var formattedNumber = formatNationalNumber(nationalNumber, carrierCode, 'NATIONAL', metadata);
	    // For NANPA regions, return the national format for these regions
	    // but prefix it with the country calling code.
	    if (countryCallingCode === '1') {
	      return countryCallingCode + ' ' + formattedNumber;
	    }
	    // If regions share a country calling code, the country calling code need
	    // not be dialled. This also applies when dialling within a region, so this
	    // if clause covers both these cases. Technically this is the case for
	    // dialling from La Reunion to other overseas departments of France (French
	    // Guiana, Martinique, Guadeloupe), but not vice versa - so we don't cover
	    // this edge case for now and for those cases return the version including
	    // country calling code. Details here:
	    // http://www.petitfute.com/voyage/225-info-pratiques-reunion
	    //
	    return formattedNumber;
	  }
	  var iddPrefix = getIddPrefix(fromCountry, undefined, metadata.metadata);
	  if (iddPrefix) {
	    return "".concat(iddPrefix, " ").concat(countryCallingCode, " ").concat(formatNationalNumber(nationalNumber, null, 'INTERNATIONAL', metadata));
	  }
	}
	function merge() {
	  var i = 1;
	  for (var _len = arguments.length, objects = new Array(_len), _key = 0; _key < _len; _key++) {
	    objects[_key] = arguments[_key];
	  }
	  while (i < objects.length) {
	    if (objects[i]) {
	      for (var key in objects[i]) {
	        objects[0][key] = objects[i][key];
	      }
	    }
	    i++;
	  }
	  return objects[0];
	}
	function pickFirstMatchingElement(elements, testFunction) {
	  var i = 0;
	  while (i < elements.length) {
	    if (testFunction(elements[i])) {
	      return elements[i];
	    }
	    i++;
	  }
	}

	function _typeof$4(o) { "@babel/helpers - typeof"; return _typeof$4 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof$4(o); }
	function ownKeys$3(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
	function _objectSpread$3(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$3(Object(t), true).forEach(function (r) { _defineProperty$3(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$3(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
	function _defineProperty$3(e, r, t) { return (r = _toPropertyKey$3(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e; }
	function _classCallCheck$1(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
	function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey$3(o.key), o); } }
	function _createClass$1(e, r, t) { return r && _defineProperties(e.prototype, r), Object.defineProperty(e, "prototype", { writable: false }), e; }
	function _toPropertyKey$3(t) { var i = _toPrimitive$3(t, "string"); return "symbol" == _typeof$4(i) ? i : i + ""; }
	function _toPrimitive$3(t, r) { if ("object" != _typeof$4(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r); if ("object" != _typeof$4(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return (String )(t); }
	var PhoneNumber = /*#__PURE__*/function () {
	  /**
	   * @param  {string} countryOrCountryCallingCode
	   * @param  {string} nationalNumber
	   * @param  {object} metadata  Metadata JSON
	   * @return {PhoneNumber}
	   */
	  function PhoneNumber(countryOrCountryCallingCode, nationalNumber, metadata) {
	    _classCallCheck$1(this, PhoneNumber);
	    // Validate `countryOrCountryCallingCode` argument.
	    if (!countryOrCountryCallingCode) {
	      throw new TypeError('First argument is required');
	    }
	    if (typeof countryOrCountryCallingCode !== 'string') {
	      throw new TypeError('First argument must be a string');
	    }

	    // In case of public API use: `constructor(number, metadata)`.
	    // Transform the arguments from `constructor(number, metadata)` to
	    // `constructor(countryOrCountryCallingCode, nationalNumber, metadata)`.
	    if (countryOrCountryCallingCode[0] === '+' && !nationalNumber) {
	      throw new TypeError('`metadata` argument not passed');
	    }
	    if (isObject(nationalNumber) && isObject(nationalNumber.countries)) {
	      metadata = nationalNumber;
	      var e164Number = countryOrCountryCallingCode;
	      if (!E164_NUMBER_REGEXP.test(e164Number)) {
	        throw new Error('Invalid `number` argument passed: must consist of a "+" followed by digits');
	      }
	      var _extractCountryCallin = extractCountryCallingCode(e164Number, undefined, undefined, undefined, metadata),
	        _countryCallingCode = _extractCountryCallin.countryCallingCode,
	        number = _extractCountryCallin.number;
	      nationalNumber = number;
	      countryOrCountryCallingCode = _countryCallingCode;
	      if (!nationalNumber) {
	        throw new Error('Invalid `number` argument passed: too short');
	      }
	    }

	    // Validate `nationalNumber` argument.
	    if (!nationalNumber) {
	      throw new TypeError('`nationalNumber` argument is required');
	    }
	    if (typeof nationalNumber !== 'string') {
	      throw new TypeError('`nationalNumber` argument must be a string');
	    }

	    // Validate `metadata` argument.
	    validateMetadata(metadata);

	    // Initialize properties.
	    var _getCountryAndCountry = getCountryAndCountryCallingCode(countryOrCountryCallingCode, metadata),
	      country = _getCountryAndCountry.country,
	      countryCallingCode = _getCountryAndCountry.countryCallingCode;
	    this.country = country;
	    this.countryCallingCode = countryCallingCode;
	    this.nationalNumber = nationalNumber;
	    this.number = '+' + this.countryCallingCode + this.nationalNumber;
	    // Exclude `metadata` property output from `PhoneNumber.toString()`
	    // so that it doesn't clutter the console output of Node.js.
	    // Previously, when Node.js did `console.log(new PhoneNumber(...))`,
	    // it would output the whole internal structure of the `metadata` object.
	    this.getMetadata = function () {
	      return metadata;
	    };
	  }
	  return _createClass$1(PhoneNumber, [{
	    key: "setExt",
	    value: function setExt(ext) {
	      this.ext = ext;
	    }
	  }, {
	    key: "getPossibleCountries",
	    value: function getPossibleCountries() {
	      if (this.country) {
	        return [this.country];
	      }
	      return getPossibleCountriesForNumber(this.countryCallingCode, this.nationalNumber, this.getMetadata());
	    }
	  }, {
	    key: "isPossible",
	    value: function isPossible() {
	      return isPossiblePhoneNumber(this, {
	        v2: true
	      }, this.getMetadata());
	    }
	  }, {
	    key: "isValid",
	    value: function isValid() {
	      return isValidNumber(this, {
	        v2: true
	      }, this.getMetadata());
	    }
	  }, {
	    key: "isNonGeographic",
	    value: function isNonGeographic() {
	      var metadata = new Metadata(this.getMetadata());
	      return metadata.isNonGeographicCallingCode(this.countryCallingCode);
	    }
	  }, {
	    key: "isEqual",
	    value: function isEqual(phoneNumber) {
	      return this.number === phoneNumber.number && this.ext === phoneNumber.ext;
	    }

	    // This function was originally meant to be an equivalent for `validatePhoneNumberLength()`,
	    // but later it was found out that it doesn't include the possible `TOO_SHORT` result
	    // returned from `parsePhoneNumberWithError()` in the original `validatePhoneNumberLength()`,
	    // so eventually I simply commented out this method from the `PhoneNumber` class
	    // and just left the `validatePhoneNumberLength()` function, even though that one would require
	    // and additional step to also validate the actual country / calling code of the phone number.
	    // validateLength() {
	    // 	const metadata = new Metadata(this.getMetadata())
	    // 	metadata.selectNumberingPlan(this.countryCallingCode)
	    // 	const result = checkNumberLength(this.nationalNumber, metadata)
	    // 	if (result !== 'IS_POSSIBLE') {
	    // 		return result
	    // 	}
	    // }
	  }, {
	    key: "getType",
	    value: function getType() {
	      return getNumberType(this, {
	        v2: true
	      }, this.getMetadata());
	    }
	  }, {
	    key: "format",
	    value: function format(_format, options) {
	      return formatNumber(this, _format, options ? _objectSpread$3(_objectSpread$3({}, options), {}, {
	        v2: true
	      }) : {
	        v2: true
	      }, this.getMetadata());
	    }
	  }, {
	    key: "formatNational",
	    value: function formatNational(options) {
	      return this.format('NATIONAL', options);
	    }
	  }, {
	    key: "formatInternational",
	    value: function formatInternational(options) {
	      return this.format('INTERNATIONAL', options);
	    }
	  }, {
	    key: "getURI",
	    value: function getURI(options) {
	      return this.format('RFC3966', options);
	    }
	  }]);
	}();
	var isCountryCode = function isCountryCode(value) {
	  return /^[A-Z]{2}$/.test(value);
	};
	function getCountryAndCountryCallingCode(countryOrCountryCallingCode, metadataJson) {
	  var country;
	  var countryCallingCode;
	  var metadata = new Metadata(metadataJson);
	  // If country code is passed then derive `countryCallingCode` from it.
	  // Also store the country code as `.country`.
	  if (isCountryCode(countryOrCountryCallingCode)) {
	    country = countryOrCountryCallingCode;
	    metadata.selectNumberingPlan(country);
	    countryCallingCode = metadata.countryCallingCode();
	  } else {
	    countryCallingCode = countryOrCountryCallingCode;
	  }
	  return {
	    country: country,
	    countryCallingCode: countryCallingCode
	  };
	}
	var E164_NUMBER_REGEXP = /^\+\d+$/;

	function _typeof$3(o) { "@babel/helpers - typeof"; return _typeof$3 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof$3(o); }
	function _createClass(e, r, t) { return Object.defineProperty(e, "prototype", { writable: false }), e; }
	function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
	function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
	function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof$3(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
	function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
	function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: true, configurable: true } }), Object.defineProperty(t, "prototype", { writable: false }), e && _setPrototypeOf(t, e); }
	function _wrapNativeSuper(t) { var r = "function" == typeof Map ? new Map() : void 0; return _wrapNativeSuper = function _wrapNativeSuper(t) { if (null === t || !_isNativeFunction(t)) return t; if ("function" != typeof t) throw new TypeError("Super expression must either be null or a function"); if (void 0 !== r) { if (r.has(t)) return r.get(t); r.set(t, Wrapper); } function Wrapper() { return _construct(t, arguments, _getPrototypeOf(this).constructor); } return Wrapper.prototype = Object.create(t.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }), _setPrototypeOf(Wrapper, t); }, _wrapNativeSuper(t); }
	function _construct(t, e, r) { if (_isNativeReflectConstruct()) return Reflect.construct.apply(null, arguments); var o = [null]; o.push.apply(o, e); var p = new (t.bind.apply(t, o))(); return r && _setPrototypeOf(p, r.prototype), p; }
	function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
	function _isNativeFunction(t) { try { return -1 !== Function.toString.call(t).indexOf("[native code]"); } catch (n) { return "function" == typeof t; } }
	function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
	function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
	// https://stackoverflow.com/a/46971044/970769
	// "Breaking changes in Typescript 2.1"
	// "Extending built-ins like Error, Array, and Map may no longer work."
	// "As a recommendation, you can manually adjust the prototype immediately after any super(...) calls."
	// https://github.com/Microsoft/TypeScript-wiki/blob/main/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work
	var ParseError = /*#__PURE__*/function (_Error) {
	  function ParseError(code) {
	    var _this;
	    _classCallCheck(this, ParseError);
	    _this = _callSuper(this, ParseError, [code]);
	    // Set the prototype explicitly.
	    // Any subclass of FooError will have to manually set the prototype as well.
	    Object.setPrototypeOf(_this, ParseError.prototype);
	    _this.name = _this.constructor.name;
	    return _this;
	  }
	  _inherits(ParseError, _Error);
	  return _createClass(ParseError);
	}(/*#__PURE__*/_wrapNativeSuper(Error));

	// Regexp of all known extension prefixes used by different regions followed by
	// 1 or more valid digits, for use when parsing.
	var EXTN_PATTERN = new RegExp('(?:' + createExtensionPattern() + ')$', 'i');

	// Strips any extension (as in, the part of the number dialled after the call is
	// connected, usually indicated with extn, ext, x or similar) from the end of
	// the number, and returns it.
	function extractExtension(number) {
	  var start = number.search(EXTN_PATTERN);
	  if (start < 0) {
	    return {};
	  }
	  // If we find a potential extension, and the number preceding this is a viable
	  // number, we assume it is an extension.
	  var numberWithoutExtension = number.slice(0, start);
	  var matches = number.match(EXTN_PATTERN);
	  var i = 1;
	  while (i < matches.length) {
	    if (matches[i]) {
	      return {
	        number: numberWithoutExtension,
	        ext: matches[i]
	      };
	    }
	    i++;
	  }
	}

	// These mappings map a character (key) to a specific digit that should
	// replace it for normalization purposes. Non-European digits that
	// may be used in phone numbers are mapped to a European equivalent.
	//
	// E.g. in Iraq they don't write `+442323234` but rather `+`.
	//
	var DIGITS = {
	  '0': '0',
	  '1': '1',
	  '2': '2',
	  '3': '3',
	  '4': '4',
	  '5': '5',
	  '6': '6',
	  '7': '7',
	  '8': '8',
	  '9': '9',
	  "\uFF10": '0',
	  // Fullwidth digit 0
	  "\uFF11": '1',
	  // Fullwidth digit 1
	  "\uFF12": '2',
	  // Fullwidth digit 2
	  "\uFF13": '3',
	  // Fullwidth digit 3
	  "\uFF14": '4',
	  // Fullwidth digit 4
	  "\uFF15": '5',
	  // Fullwidth digit 5
	  "\uFF16": '6',
	  // Fullwidth digit 6
	  "\uFF17": '7',
	  // Fullwidth digit 7
	  "\uFF18": '8',
	  // Fullwidth digit 8
	  "\uFF19": '9',
	  // Fullwidth digit 9
	  "\u0660": '0',
	  // Arabic-indic digit 0
	  "\u0661": '1',
	  // Arabic-indic digit 1
	  "\u0662": '2',
	  // Arabic-indic digit 2
	  "\u0663": '3',
	  // Arabic-indic digit 3
	  "\u0664": '4',
	  // Arabic-indic digit 4
	  "\u0665": '5',
	  // Arabic-indic digit 5
	  "\u0666": '6',
	  // Arabic-indic digit 6
	  "\u0667": '7',
	  // Arabic-indic digit 7
	  "\u0668": '8',
	  // Arabic-indic digit 8
	  "\u0669": '9',
	  // Arabic-indic digit 9
	  "\u06F0": '0',
	  // Eastern-Arabic digit 0
	  "\u06F1": '1',
	  // Eastern-Arabic digit 1
	  "\u06F2": '2',
	  // Eastern-Arabic digit 2
	  "\u06F3": '3',
	  // Eastern-Arabic digit 3
	  "\u06F4": '4',
	  // Eastern-Arabic digit 4
	  "\u06F5": '5',
	  // Eastern-Arabic digit 5
	  "\u06F6": '6',
	  // Eastern-Arabic digit 6
	  "\u06F7": '7',
	  // Eastern-Arabic digit 7
	  "\u06F8": '8',
	  // Eastern-Arabic digit 8
	  "\u06F9": '9' // Eastern-Arabic digit 9
	};
	function parseDigit(character) {
	  return DIGITS[character];
	}

	function _createForOfIteratorHelperLoose(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (t) return (t = t.call(r)).next.bind(t); if (Array.isArray(r) || (t = _unsupportedIterableToArray$1(r)) || e) { t && (r = t); var o = 0; return function () { return o >= r.length ? { done: true } : { done: false, value: r[o++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
	function _unsupportedIterableToArray$1(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray$1(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray$1(r, a) : void 0; } }
	function _arrayLikeToArray$1(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }

	/**
	 * Parses phone number characters from a string.
	 * Drops all punctuation leaving only digits and the leading `+` sign (if any).
	 * Also converts wide-ascii and arabic-indic numerals to conventional numerals.
	 * E.g. in Iraq they don't write `+442323234` but rather `+`.
	 * @param  {string} string
	 * @return {string}
	 * @example
	 * ```js
	 * // Outputs '8800555'.
	 * parseIncompletePhoneNumber('8 (800) 555')
	 * // Outputs '+7800555'.
	 * parseIncompletePhoneNumber('+7 800 555')
	 * ```
	 */
	function parseIncompletePhoneNumber(string) {
	  var result = '';
	  // Using `.split('')` here instead of normal `for ... of`
	  // because the importing application doesn't neccessarily include an ES6 polyfill.
	  // The `.split('')` approach discards "exotic" UTF-8 characters
	  // (the ones consisting of four bytes) but digits
	  // (including non-European ones) don't fall into that range
	  // so such "exotic" characters would be discarded anyway.
	  for (var _iterator = _createForOfIteratorHelperLoose(string.split('')), _step; !(_step = _iterator()).done;) {
	    var character = _step.value;
	    result += parsePhoneNumberCharacter(character, result) || '';
	  }
	  return result;
	}

	/**
	 * Parses next character while parsing phone number digits (including a `+`)
	 * from text: discards everything except `+` and digits, and `+` is only allowed
	 * at the start of a phone number.
	 * For example, is used in `react-phone-number-input` where it uses
	 * [`input-format`](https://gitlab.com/catamphetamine/input-format).
	 * @param  {string} character - Yet another character from raw input string.
	 * @param  {string?} prevParsedCharacters - Previous parsed characters.
	 * @param  {function?} eventListener - An optional "on event" function.
	 * @return {string?} The parsed character.
	 */
	function parsePhoneNumberCharacter(character, prevParsedCharacters, eventListener) {
	  // Only allow a leading `+`.
	  if (character === '+') {
	    // If this `+` is not the first parsed character
	    // then discard it.
	    if (prevParsedCharacters) {
	      return;
	    }
	    return '+';
	  }
	  // Allow digits.
	  return parseDigit(character);
	}

	// When phone numbers are written in `RFC3966` format  `"tel:+12133734253"` 
	// they can have their "calling code" part written separately in a `phone-context` parameter.
	// Example: `"tel:12133734253;phone-context=+1"`.
	// This function parses the full phone number from the local number and the `phone-context`
	// when the `phone-context` contains a `+` sign.

	var PLUS_SIGN = '+';
	var RFC3966_VISUAL_SEPARATOR_ = '[\\-\\.\\(\\)]?';
	var RFC3966_PHONE_DIGIT_ = '(' + '[' + VALID_DIGITS + ']' + '|' + RFC3966_VISUAL_SEPARATOR_ + ')';
	var RFC3966_GLOBAL_NUMBER_DIGITS_ = '^' + '\\' + PLUS_SIGN + RFC3966_PHONE_DIGIT_ + '*' + '[' + VALID_DIGITS + ']' + RFC3966_PHONE_DIGIT_ + '*' + '$';

	/**
	 * Regular expression of valid global-number-digits for the phone-context
	 * parameter, following the syntax defined in RFC3966.
	 */
	var RFC3966_GLOBAL_NUMBER_DIGITS_PATTERN_ = new RegExp(RFC3966_GLOBAL_NUMBER_DIGITS_, 'g');

	// In this port of Google's library, we don't accept alpha characters in phone numbers.
	// const ALPHANUM_ = VALID_ALPHA_ + VALID_DIGITS
	var ALPHANUM_ = VALID_DIGITS;
	var RFC3966_DOMAINLABEL_ = '[' + ALPHANUM_ + ']+((\\-)*[' + ALPHANUM_ + '])*';
	var VALID_ALPHA_ = 'a-zA-Z';
	var RFC3966_TOPLABEL_ = '[' + VALID_ALPHA_ + ']+((\\-)*[' + ALPHANUM_ + '])*';
	var RFC3966_DOMAINNAME_ = '^(' + RFC3966_DOMAINLABEL_ + '\\.)*' + RFC3966_TOPLABEL_ + '\\.?$';

	/**
	 * Regular expression of valid domainname for the phone-context parameter,
	 * following the syntax defined in RFC3966.
	 */
	var RFC3966_DOMAINNAME_PATTERN_ = new RegExp(RFC3966_DOMAINNAME_, 'g');
	var RFC3966_PREFIX_ = 'tel:';
	var RFC3966_PHONE_CONTEXT_ = ';phone-context=';
	var RFC3966_ISDN_SUBADDRESS_ = ';isub=';

	/**
	 * Extracts the value of the phone-context parameter of `numberToExtractFrom`,
	 * following the syntax defined in RFC3966.
	 *
	 * @param {string} numberToExtractFrom
	 * @return {string|null} the extracted string (possibly empty), or `null` if no phone-context parameter is found.
	 */
	function extractPhoneContext(numberToExtractFrom) {
	  var indexOfPhoneContext = numberToExtractFrom.indexOf(RFC3966_PHONE_CONTEXT_);
	  // If no phone-context parameter is present
	  if (indexOfPhoneContext < 0) {
	    return null;
	  }
	  var phoneContextStart = indexOfPhoneContext + RFC3966_PHONE_CONTEXT_.length;
	  // If phone-context parameter is empty
	  if (phoneContextStart >= numberToExtractFrom.length) {
	    return '';
	  }
	  var phoneContextEnd = numberToExtractFrom.indexOf(';', phoneContextStart);
	  // If phone-context is not the last parameter
	  if (phoneContextEnd >= 0) {
	    return numberToExtractFrom.substring(phoneContextStart, phoneContextEnd);
	  } else {
	    return numberToExtractFrom.substring(phoneContextStart);
	  }
	}

	/**
	 * Returns whether the value of phoneContext follows the syntax defined in RFC3966.
	 *
	 * @param {string|null} phoneContext
	 * @return {boolean}
	 */
	function isPhoneContextValid(phoneContext) {
	  if (phoneContext === null) {
	    return true;
	  }
	  if (phoneContext.length === 0) {
	    return false;
	  }

	  // Does phone-context value match pattern of global-number-digits or domainname.
	  return RFC3966_GLOBAL_NUMBER_DIGITS_PATTERN_.test(phoneContext) || RFC3966_DOMAINNAME_PATTERN_.test(phoneContext);
	}

	/**
	 * @param  {string} numberToParse
	 * @param  {string} nationalNumber
	 * @return {}
	 */
	function extractFormattedPhoneNumberFromPossibleRfc3966NumberUri(numberToParse, _ref) {
	  var extractFormattedPhoneNumber = _ref.extractFormattedPhoneNumber;
	  var phoneContext = extractPhoneContext(numberToParse);
	  if (!isPhoneContextValid(phoneContext)) {
	    throw new ParseError('NOT_A_NUMBER');
	  }
	  var phoneNumberString;
	  if (phoneContext === null) {
	    // Extract a possible number from the string passed in.
	    // (this strips leading characters that could not be the start of a phone number)
	    phoneNumberString = extractFormattedPhoneNumber(numberToParse) || '';
	  } else {
	    phoneNumberString = '';

	    // If the phone context contains a phone number prefix, we need to capture
	    // it, whereas domains will be ignored.
	    if (phoneContext.charAt(0) === PLUS_SIGN) {
	      phoneNumberString += phoneContext;
	    }

	    // Now append everything between the "tel:" prefix and the phone-context.
	    // This should include the national number, an optional extension or
	    // isdn-subaddress component. Note we also handle the case when "tel:" is
	    // missing, as we have seen in some of the phone number inputs.
	    // In that case, we append everything from the beginning.
	    var indexOfRfc3966Prefix = numberToParse.indexOf(RFC3966_PREFIX_);
	    var indexOfNationalNumber;
	    // RFC 3966 "tel:" prefix is preset at this stage because
	    // `isPhoneContextValid()` requires it to be present.
	    /* istanbul ignore else */
	    if (indexOfRfc3966Prefix >= 0) {
	      indexOfNationalNumber = indexOfRfc3966Prefix + RFC3966_PREFIX_.length;
	    } else {
	      indexOfNationalNumber = 0;
	    }
	    var indexOfPhoneContext = numberToParse.indexOf(RFC3966_PHONE_CONTEXT_);
	    phoneNumberString += numberToParse.substring(indexOfNationalNumber, indexOfPhoneContext);
	  }

	  // Delete the isdn-subaddress and everything after it if it is present.
	  // Note extension won't appear at the same time with isdn-subaddress
	  // according to paragraph 5.3 of the RFC3966 spec.
	  var indexOfIsdn = phoneNumberString.indexOf(RFC3966_ISDN_SUBADDRESS_);
	  if (indexOfIsdn > 0) {
	    phoneNumberString = phoneNumberString.substring(0, indexOfIsdn);
	  }
	  // If both phone context and isdn-subaddress are absent but other
	  // parameters are present, the parameters are left in nationalNumber.
	  // This is because we are concerned about deleting content from a potential
	  // number string when there is no strong evidence that the number is
	  // actually written in RFC3966.

	  if (phoneNumberString !== '') {
	    return phoneNumberString;
	  }
	}

	// This is a port of Google Android `libphonenumber`'s
	// `phonenumberutil.js` of December 31th, 2018.
	//
	// https://github.com/googlei18n/libphonenumber/commits/master/javascript/i18n/phonenumbers/phonenumberutil.js


	// We don't allow input strings for parsing to be longer than 250 chars.
	// This prevents malicious input from consuming CPU.
	var MAX_INPUT_STRING_LENGTH = 250;

	// This consists of the plus symbol, digits, and arabic-indic digits.
	var PHONE_NUMBER_START_PATTERN = new RegExp('[' + PLUS_CHARS + VALID_DIGITS + ']');

	// Regular expression of trailing characters that we want to remove.
	// A trailing `#` is sometimes used when writing phone numbers with extensions in US.
	// Example: "+1 (645) 123 1234-910#" number has extension "910".
	var AFTER_PHONE_NUMBER_END_PATTERN = new RegExp('[^' + VALID_DIGITS + '#' + ']+$');

	// Examples:
	//
	// ```js
	// parse('8 (800) 555-35-35', 'RU')
	// parse('8 (800) 555-35-35', 'RU', metadata)
	// parse('8 (800) 555-35-35', { country: { default: 'RU' } })
	// parse('8 (800) 555-35-35', { country: { default: 'RU' } }, metadata)
	// parse('+7 800 555 35 35')
	// parse('+7 800 555 35 35', metadata)
	// ```
	//

	/**
	 * Parses a phone number.
	 *
	 * parse('123456789', { defaultCountry: 'RU', v2: true }, metadata)
	 * parse('123456789', { defaultCountry: 'RU' }, metadata)
	 * parse('123456789', undefined, metadata)
	 *
	 * @param  {string} input
	 * @param  {object} [options]
	 * @param  {object} metadata
	 * @return {object|PhoneNumber?} If `options.v2: true` flag is passed, it returns a `PhoneNumber?` instance. Otherwise, returns an object of shape `{ phone: '...', country: '...' }` (or just `{}` if no phone number was parsed).
	 */
	function parse(text, options, metadata) {
	  // If assigning the `{}` default value is moved to the arguments above,
	  // code coverage would decrease for some weird reason.
	  options = options || {};
	  metadata = new Metadata(metadata);

	  // Validate `defaultCountry`.
	  if (options.defaultCountry && !metadata.hasCountry(options.defaultCountry)) {
	    if (options.v2) {
	      throw new ParseError('INVALID_COUNTRY');
	    }
	    throw new Error("Unknown country: ".concat(options.defaultCountry));
	  }

	  // Parse the phone number.
	  var _parseInput = parseInput(text, options.v2, options.extract),
	    formattedPhoneNumber = _parseInput.number,
	    ext = _parseInput.ext,
	    error = _parseInput.error;

	  // If the phone number is not viable then return nothing.
	  if (!formattedPhoneNumber) {
	    if (options.v2) {
	      if (error === 'TOO_SHORT') {
	        throw new ParseError('TOO_SHORT');
	      }
	      throw new ParseError('NOT_A_NUMBER');
	    }
	    return {};
	  }
	  var _parsePhoneNumber = parsePhoneNumber$3(formattedPhoneNumber, options.defaultCountry, options.defaultCallingCode, metadata),
	    country = _parsePhoneNumber.country,
	    nationalNumber = _parsePhoneNumber.nationalNumber,
	    countryCallingCode = _parsePhoneNumber.countryCallingCode,
	    countryCallingCodeSource = _parsePhoneNumber.countryCallingCodeSource,
	    carrierCode = _parsePhoneNumber.carrierCode;
	  if (!metadata.hasSelectedNumberingPlan()) {
	    if (options.v2) {
	      throw new ParseError('INVALID_COUNTRY');
	    }
	    return {};
	  }

	  // Validate national (significant) number length.
	  if (!nationalNumber || nationalNumber.length < MIN_LENGTH_FOR_NSN) {
	    // Won't throw here because the regexp already demands length > 1.
	    /* istanbul ignore if */
	    if (options.v2) {
	      throw new ParseError('TOO_SHORT');
	    }
	    // Google's demo just throws an error in this case.
	    return {};
	  }

	  // Validate national (significant) number length.
	  //
	  // A sidenote:
	  //
	  // They say that sometimes national (significant) numbers
	  // can be longer than `MAX_LENGTH_FOR_NSN` (e.g. in Germany).
	  // https://github.com/googlei18n/libphonenumber/blob/7e1748645552da39c4e1ba731e47969d97bdb539/resources/phonenumber.proto#L36
	  // Such numbers will just be discarded.
	  //
	  if (nationalNumber.length > MAX_LENGTH_FOR_NSN) {
	    if (options.v2) {
	      throw new ParseError('TOO_LONG');
	    }
	    // Google's demo just throws an error in this case.
	    return {};
	  }
	  if (options.v2) {
	    var phoneNumber = new PhoneNumber(countryCallingCode, nationalNumber, metadata.metadata);
	    if (country) {
	      phoneNumber.country = country;
	    }
	    if (carrierCode) {
	      phoneNumber.carrierCode = carrierCode;
	    }
	    if (ext) {
	      phoneNumber.ext = ext;
	    }
	    phoneNumber.__countryCallingCodeSource = countryCallingCodeSource;
	    return phoneNumber;
	  }

	  // Check if national phone number pattern matches the number.
	  // National number pattern is different for each country,
	  // even for those ones which are part of the "NANPA" group.
	  var valid = (options.extended ? metadata.hasSelectedNumberingPlan() : country) ? matchesEntirely(nationalNumber, metadata.nationalNumberPattern()) : false;
	  if (!options.extended) {
	    return valid ? result(country, nationalNumber, ext) : {};
	  }

	  // isInternational: countryCallingCode !== undefined

	  return {
	    country: country,
	    countryCallingCode: countryCallingCode,
	    carrierCode: carrierCode,
	    valid: valid,
	    possible: valid ? true : options.extended === true && metadata.possibleLengths() && isPossibleNumber(nationalNumber, country, metadata) ? true : false,
	    phone: nationalNumber,
	    ext: ext
	  };
	}

	/**
	 * Extracts a formatted phone number from text.
	 * Doesn't guarantee that the extracted phone number
	 * is a valid phone number (for example, doesn't validate its length).
	 * @param  {string} text
	 * @param  {boolean} [extract]  If `false`, then will parse the entire `text` as a phone number.
	 * @param  {boolean} [throwOnError]  By default, it won't throw if the text is too long.
	 * @return {string}
	 * @example
	 * // Returns "(213) 373-4253".
	 * extractFormattedPhoneNumber("Call (213) 373-4253 for assistance.")
	 */
	function _extractFormattedPhoneNumber(text, extract, throwOnError) {
	  if (!text) {
	    return;
	  }
	  if (text.length > MAX_INPUT_STRING_LENGTH) {
	    if (throwOnError) {
	      throw new ParseError('TOO_LONG');
	    }
	    return;
	  }
	  if (extract === false) {
	    return text;
	  }
	  // Attempt to extract a possible number from the string passed in
	  var startsAt = text.search(PHONE_NUMBER_START_PATTERN);
	  if (startsAt < 0) {
	    return;
	  }
	  return text
	  // Trim everything to the left of the phone number
	  .slice(startsAt)
	  // Remove trailing non-numerical characters
	  .replace(AFTER_PHONE_NUMBER_END_PATTERN, '');
	}

	/**
	 * @param  {string} text - Input.
	 * @param  {boolean} v2 - Legacy API functions don't pass `v2: true` flag.
	 * @param  {boolean} [extract] - Whether to extract a phone number from `text`, or attempt to parse the entire text as a phone number.
	 * @return {object} `{ ?number, ?ext }`.
	 */
	function parseInput(text, v2, extract) {
	  // // Parse RFC 3966 phone number URI.
	  // if (text && text.indexOf('tel:') === 0) {
	  // 	return parseRFC3966(text)
	  // }
	  // let number = extractFormattedPhoneNumber(text, extract, v2)
	  var number = extractFormattedPhoneNumberFromPossibleRfc3966NumberUri(text, {
	    extractFormattedPhoneNumber: function extractFormattedPhoneNumber(text) {
	      return _extractFormattedPhoneNumber(text, extract, v2);
	    }
	  });
	  // If the phone number is not viable, then abort.
	  if (!number) {
	    return {};
	  }
	  if (!isViablePhoneNumber(number)) {
	    if (isViablePhoneNumberStart(number)) {
	      return {
	        error: 'TOO_SHORT'
	      };
	    }
	    return {};
	  }
	  // Attempt to parse extension first, since it doesn't require region-specific
	  // data and we want to have the non-normalised number here.
	  var withExtensionStripped = extractExtension(number);
	  if (withExtensionStripped.ext) {
	    return withExtensionStripped;
	  }
	  return {
	    number: number
	  };
	}

	/**
	 * Creates `parse()` result object.
	 */
	function result(country, nationalNumber, ext) {
	  var result = {
	    country: country,
	    phone: nationalNumber
	  };
	  if (ext) {
	    result.ext = ext;
	  }
	  return result;
	}

	/**
	 * Parses a viable phone number.
	 * @param {string} formattedPhoneNumber  Example: "(213) 373-4253".
	 * @param {string} [defaultCountry]
	 * @param {string} [defaultCallingCode]
	 * @param {Metadata} metadata
	 * @return {object} Returns `{ country: string?, countryCallingCode: string?, nationalNumber: string? }`.
	 */
	function parsePhoneNumber$3(formattedPhoneNumber, defaultCountry, defaultCallingCode, metadata) {
	  // Extract calling code from phone number.
	  var _extractCountryCallin = extractCountryCallingCode(parseIncompletePhoneNumber(formattedPhoneNumber), undefined, defaultCountry, defaultCallingCode, metadata.metadata),
	    countryCallingCodeSource = _extractCountryCallin.countryCallingCodeSource,
	    countryCallingCode = _extractCountryCallin.countryCallingCode,
	    number = _extractCountryCallin.number;

	  // The exact country of the phone number
	  var country;

	  // If `formattedPhoneNumber` is passed in "international" format,
	  // choose a country by `countryCallingCode`.
	  if (countryCallingCode) {
	    metadata.selectNumberingPlan(countryCallingCode);
	  }
	  // Else, if `formattedPhoneNumber` is passed in "national" format,
	  // then `number` is defined and `countryCallingCode` is `undefined`.
	  else if (number && (defaultCountry || defaultCallingCode)) {
	    metadata.selectNumberingPlan(defaultCountry, defaultCallingCode);
	    if (defaultCountry) {
	      country = defaultCountry;
	    }
	    countryCallingCode = defaultCallingCode || getCountryCallingCode(defaultCountry, metadata.metadata);
	  } else return {};
	  if (!number) {
	    return {
	      countryCallingCodeSource: countryCallingCodeSource,
	      countryCallingCode: countryCallingCode
	    };
	  }
	  var _extractNationalNumbe = extractNationalNumber(parseIncompletePhoneNumber(number), country, metadata),
	    nationalNumber = _extractNationalNumbe.nationalNumber,
	    carrierCode = _extractNationalNumbe.carrierCode;

	  // Sometimes there are several countries
	  // corresponding to the same country phone code
	  // (e.g. NANPA countries all having `1` country phone code).
	  // Therefore, to reliably determine the exact country,
	  // national (significant) number should have been parsed first.
	  //
	  // When `metadata.json` is generated, all "ambiguous" country phone codes
	  // get their countries populated with the full set of
	  // "phone number type" regular expressions.
	  //
	  var exactCountry = getCountryByCallingCode(countryCallingCode, {
	    nationalNumber: nationalNumber,
	    metadata: metadata
	  });
	  if (exactCountry) {
	    country = exactCountry;
	    /* istanbul ignore if */
	    if (exactCountry === '001') ; else {
	      metadata.selectNumberingPlan(country);
	    }
	  }
	  return {
	    country: country,
	    countryCallingCode: countryCallingCode,
	    countryCallingCodeSource: countryCallingCodeSource,
	    nationalNumber: nationalNumber,
	    carrierCode: carrierCode
	  };
	}

	function _typeof$2(o) { "@babel/helpers - typeof"; return _typeof$2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof$2(o); }
	function ownKeys$2(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
	function _objectSpread$2(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$2(Object(t), true).forEach(function (r) { _defineProperty$2(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$2(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
	function _defineProperty$2(e, r, t) { return (r = _toPropertyKey$2(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e; }
	function _toPropertyKey$2(t) { var i = _toPrimitive$2(t, "string"); return "symbol" == _typeof$2(i) ? i : i + ""; }
	function _toPrimitive$2(t, r) { if ("object" != _typeof$2(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r); if ("object" != _typeof$2(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
	function parsePhoneNumberWithError(text, options, metadata) {
	  return parse(text, _objectSpread$2(_objectSpread$2({}, options), {}, {
	    v2: true
	  }), metadata);
	}

	function _typeof$1(o) { "@babel/helpers - typeof"; return _typeof$1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof$1(o); }
	function ownKeys$1(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
	function _objectSpread$1(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$1(Object(t), true).forEach(function (r) { _defineProperty$1(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$1(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
	function _defineProperty$1(e, r, t) { return (r = _toPropertyKey$1(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e; }
	function _toPropertyKey$1(t) { var i = _toPrimitive$1(t, "string"); return "symbol" == _typeof$1(i) ? i : i + ""; }
	function _toPrimitive$1(t, r) { if ("object" != _typeof$1(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r); if ("object" != _typeof$1(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
	function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
	function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
	function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
	function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
	function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = true, o = false; try { if (i = (t = t.call(r)).next, 0 === l) ; else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = true, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
	function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }

	// Extracts the following properties from function arguments:
	// * input `text`
	// * `options` object
	// * `metadata` JSON
	function normalizeArguments(args) {
	  var _Array$prototype$slic = Array.prototype.slice.call(args),
	    _Array$prototype$slic2 = _slicedToArray(_Array$prototype$slic, 4),
	    arg_1 = _Array$prototype$slic2[0],
	    arg_2 = _Array$prototype$slic2[1],
	    arg_3 = _Array$prototype$slic2[2],
	    arg_4 = _Array$prototype$slic2[3];
	  var text;
	  var options;
	  var metadata;

	  // If the phone number is passed as a string.
	  // `parsePhoneNumber('88005553535', ...)`.
	  if (typeof arg_1 === 'string') {
	    text = arg_1;
	  } else throw new TypeError('A text for parsing must be a string.');

	  // If "default country" argument is being passed then move it to `options`.
	  // `parsePhoneNumber('88005553535', 'RU', [options], metadata)`.
	  if (!arg_2 || typeof arg_2 === 'string') {
	    if (arg_4) {
	      options = arg_3;
	      metadata = arg_4;
	    } else {
	      options = undefined;
	      metadata = arg_3;
	    }
	    if (arg_2) {
	      options = _objectSpread$1({
	        defaultCountry: arg_2
	      }, options);
	    }
	  }
	  // `defaultCountry` is not passed.
	  // Example: `parsePhoneNumber('+78005553535', [options], metadata)`.
	  else if (isObject(arg_2)) {
	    if (arg_3) {
	      options = arg_2;
	      metadata = arg_3;
	    } else {
	      metadata = arg_2;
	    }
	  } else throw new Error("Invalid second argument: ".concat(arg_2));
	  return {
	    text: text,
	    options: options,
	    metadata: metadata
	  };
	}

	function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
	function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
	function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), true).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
	function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e; }
	function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
	function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
	function parsePhoneNumber$2(text, options, metadata) {
	  // Validate `defaultCountry`.
	  if (options && options.defaultCountry && !isSupportedCountry(options.defaultCountry, metadata)) {
	    options = _objectSpread(_objectSpread({}, options), {}, {
	      defaultCountry: undefined
	    });
	  }
	  // Parse phone number.
	  try {
	    return parsePhoneNumberWithError(text, options, metadata);
	  } catch (error) {
	    /* istanbul ignore else */
	    if (error instanceof ParseError) ; else {
	      throw error;
	    }
	  }
	}

	function parsePhoneNumber$1() {
	  var _normalizeArguments = normalizeArguments(arguments),
	    text = _normalizeArguments.text,
	    options = _normalizeArguments.options,
	    metadata = _normalizeArguments.metadata;
	  return parsePhoneNumber$2(text, options, metadata);
	}

	function parsePhoneNumber() {
		return withMetadataArgument(parsePhoneNumber$1, arguments)
	}

	/**
	 * @module constants
	 * @summary Useful constants
	 * @description
	 * Collection of useful date constants.
	 *
	 * The constants could be imported from `date-fns/constants`:
	 *
	 * ```ts
	 * import { maxTime, minTime } from "./constants/date-fns/constants";
	 *
	 * function isAllowedTime(time) {
	 *   return time <= maxTime && time >= minTime;
	 * }
	 * ```
	 */


	/**
	 * @constant
	 * @name millisecondsInWeek
	 * @summary Milliseconds in 1 week.
	 */
	const millisecondsInWeek = 604800000;

	/**
	 * @constant
	 * @name millisecondsInDay
	 * @summary Milliseconds in 1 day.
	 */
	const millisecondsInDay = 86400000;

	/**
	 * @constant
	 * @name constructFromSymbol
	 * @summary Symbol enabling Date extensions to inherit properties from the reference date.
	 *
	 * The symbol is used to enable the `constructFrom` function to construct a date
	 * using a reference date and a value. It allows to transfer extra properties
	 * from the reference date to the new date. It's useful for extensions like
	 * [`TZDate`](https://github.com/date-fns/tz) that accept a time zone as
	 * a constructor argument.
	 */
	const constructFromSymbol = Symbol.for("constructDateFrom");

	/**
	 * @name constructFrom
	 * @category Generic Helpers
	 * @summary Constructs a date using the reference date and the value
	 *
	 * @description
	 * The function constructs a new date using the constructor from the reference
	 * date and the given value. It helps to build generic functions that accept
	 * date extensions.
	 *
	 * It defaults to `Date` if the passed reference date is a number or a string.
	 *
	 * Starting from v3.7.0, it allows to construct a date using `[Symbol.for("constructDateFrom")]`
	 * enabling to transfer extra properties from the reference date to the new date.
	 * It's useful for extensions like [`TZDate`](https://github.com/date-fns/tz)
	 * that accept a time zone as a constructor argument.
	 *
	 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
	 *
	 * @param date - The reference date to take constructor from
	 * @param value - The value to create the date
	 *
	 * @returns Date initialized using the given date and value
	 *
	 * @example
	 * import { constructFrom } from "./constructFrom/date-fns";
	 *
	 * // A function that clones a date preserving the original type
	 * function cloneDate<DateType extends Date>(date: DateType): DateType {
	 *   return constructFrom(
	 *     date, // Use constructor from the given date
	 *     date.getTime() // Use the date value to create a new date
	 *   );
	 * }
	 */
	function constructFrom(date, value) {
	  if (typeof date === "function") return date(value);

	  if (date && typeof date === "object" && constructFromSymbol in date)
	    return date[constructFromSymbol](value);

	  if (date instanceof Date) return new date.constructor(value);

	  return new Date(value);
	}

	/**
	 * @name toDate
	 * @category Common Helpers
	 * @summary Convert the given argument to an instance of Date.
	 *
	 * @description
	 * Convert the given argument to an instance of Date.
	 *
	 * If the argument is an instance of Date, the function returns its clone.
	 *
	 * If the argument is a number, it is treated as a timestamp.
	 *
	 * If the argument is none of the above, the function returns Invalid Date.
	 *
	 * Starting from v3.7.0, it clones a date using `[Symbol.for("constructDateFrom")]`
	 * enabling to transfer extra properties from the reference date to the new date.
	 * It's useful for extensions like [`TZDate`](https://github.com/date-fns/tz)
	 * that accept a time zone as a constructor argument.
	 *
	 * **Note**: *all* Date arguments passed to any *date-fns* function is processed by `toDate`.
	 *
	 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
	 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
	 *
	 * @param argument - The value to convert
	 *
	 * @returns The parsed date in the local time zone
	 *
	 * @example
	 * // Clone the date:
	 * const result = toDate(new Date(2014, 1, 11, 11, 30, 30))
	 * //=> Tue Feb 11 2014 11:30:30
	 *
	 * @example
	 * // Convert the timestamp to date:
	 * const result = toDate(1392098430000)
	 * //=> Tue Feb 11 2014 11:30:30
	 */
	function toDate(argument, context) {
	  // [TODO] Get rid of `toDate` or `constructFrom`?
	  return constructFrom(context || argument, argument);
	}

	let defaultOptions = {};

	function getDefaultOptions() {
	  return defaultOptions;
	}

	/**
	 * The {@link startOfWeek} function options.
	 */

	/**
	 * @name startOfWeek
	 * @category Week Helpers
	 * @summary Return the start of a week for the given date.
	 *
	 * @description
	 * Return the start of a week for the given date.
	 * The result will be in the local timezone.
	 *
	 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
	 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
	 *
	 * @param date - The original date
	 * @param options - An object with options
	 *
	 * @returns The start of a week
	 *
	 * @example
	 * // The start of a week for 2 September 2014 11:55:00:
	 * const result = startOfWeek(new Date(2014, 8, 2, 11, 55, 0))
	 * //=> Sun Aug 31 2014 00:00:00
	 *
	 * @example
	 * // If the week starts on Monday, the start of the week for 2 September 2014 11:55:00:
	 * const result = startOfWeek(new Date(2014, 8, 2, 11, 55, 0), { weekStartsOn: 1 })
	 * //=> Mon Sep 01 2014 00:00:00
	 */
	function startOfWeek(date, options) {
	  const defaultOptions = getDefaultOptions();
	  const weekStartsOn =
	    options?.weekStartsOn ??
	    options?.locale?.options?.weekStartsOn ??
	    defaultOptions.weekStartsOn ??
	    defaultOptions.locale?.options?.weekStartsOn ??
	    0;

	  const _date = toDate(date, options?.in);
	  const day = _date.getDay();
	  const diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;

	  _date.setDate(_date.getDate() - diff);
	  _date.setHours(0, 0, 0, 0);
	  return _date;
	}

	/**
	 * The {@link startOfISOWeek} function options.
	 */

	/**
	 * @name startOfISOWeek
	 * @category ISO Week Helpers
	 * @summary Return the start of an ISO week for the given date.
	 *
	 * @description
	 * Return the start of an ISO week for the given date.
	 * The result will be in the local timezone.
	 *
	 * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date
	 *
	 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
	 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
	 *
	 * @param date - The original date
	 * @param options - An object with options
	 *
	 * @returns The start of an ISO week
	 *
	 * @example
	 * // The start of an ISO week for 2 September 2014 11:55:00:
	 * const result = startOfISOWeek(new Date(2014, 8, 2, 11, 55, 0))
	 * //=> Mon Sep 01 2014 00:00:00
	 */
	function startOfISOWeek(date, options) {
	  return startOfWeek(date, { ...options, weekStartsOn: 1 });
	}

	/**
	 * The {@link getISOWeekYear} function options.
	 */

	/**
	 * @name getISOWeekYear
	 * @category ISO Week-Numbering Year Helpers
	 * @summary Get the ISO week-numbering year of the given date.
	 *
	 * @description
	 * Get the ISO week-numbering year of the given date,
	 * which always starts 3 days before the year's first Thursday.
	 *
	 * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date
	 *
	 * @param date - The given date
	 *
	 * @returns The ISO week-numbering year
	 *
	 * @example
	 * // Which ISO-week numbering year is 2 January 2005?
	 * const result = getISOWeekYear(new Date(2005, 0, 2))
	 * //=> 2004
	 */
	function getISOWeekYear(date, options) {
	  const _date = toDate(date, options?.in);
	  const year = _date.getFullYear();

	  const fourthOfJanuaryOfNextYear = constructFrom(_date, 0);
	  fourthOfJanuaryOfNextYear.setFullYear(year + 1, 0, 4);
	  fourthOfJanuaryOfNextYear.setHours(0, 0, 0, 0);
	  const startOfNextYear = startOfISOWeek(fourthOfJanuaryOfNextYear);

	  const fourthOfJanuaryOfThisYear = constructFrom(_date, 0);
	  fourthOfJanuaryOfThisYear.setFullYear(year, 0, 4);
	  fourthOfJanuaryOfThisYear.setHours(0, 0, 0, 0);
	  const startOfThisYear = startOfISOWeek(fourthOfJanuaryOfThisYear);

	  if (_date.getTime() >= startOfNextYear.getTime()) {
	    return year + 1;
	  } else if (_date.getTime() >= startOfThisYear.getTime()) {
	    return year;
	  } else {
	    return year - 1;
	  }
	}

	/**
	 * Google Chrome as of 67.0.3396.87 introduced timezones with offset that includes seconds.
	 * They usually appear for dates that denote time before the timezones were introduced
	 * (e.g. for 'Europe/Prague' timezone the offset is GMT+00:57:44 before 1 October 1891
	 * and GMT+01:00:00 after that date)
	 *
	 * Date#getTimezoneOffset returns the offset in minutes and would return 57 for the example above,
	 * which would lead to incorrect calculations.
	 *
	 * This function returns the timezone offset in milliseconds that takes seconds in account.
	 */
	function getTimezoneOffsetInMilliseconds(date) {
	  const _date = toDate(date);
	  const utcDate = new Date(
	    Date.UTC(
	      _date.getFullYear(),
	      _date.getMonth(),
	      _date.getDate(),
	      _date.getHours(),
	      _date.getMinutes(),
	      _date.getSeconds(),
	      _date.getMilliseconds(),
	    ),
	  );
	  utcDate.setUTCFullYear(_date.getFullYear());
	  return +date - +utcDate;
	}

	function normalizeDates(context, ...dates) {
	  const normalize = constructFrom.bind(
	    null,
	    dates.find((date) => typeof date === "object"),
	  );
	  return dates.map(normalize);
	}

	/**
	 * The {@link startOfDay} function options.
	 */

	/**
	 * @name startOfDay
	 * @category Day Helpers
	 * @summary Return the start of a day for the given date.
	 *
	 * @description
	 * Return the start of a day for the given date.
	 * The result will be in the local timezone.
	 *
	 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
	 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
	 *
	 * @param date - The original date
	 * @param options - The options
	 *
	 * @returns The start of a day
	 *
	 * @example
	 * // The start of a day for 2 September 2014 11:55:00:
	 * const result = startOfDay(new Date(2014, 8, 2, 11, 55, 0))
	 * //=> Tue Sep 02 2014 00:00:00
	 */
	function startOfDay(date, options) {
	  const _date = toDate(date, options?.in);
	  _date.setHours(0, 0, 0, 0);
	  return _date;
	}

	/**
	 * The {@link differenceInCalendarDays} function options.
	 */

	/**
	 * @name differenceInCalendarDays
	 * @category Day Helpers
	 * @summary Get the number of calendar days between the given dates.
	 *
	 * @description
	 * Get the number of calendar days between the given dates. This means that the times are removed
	 * from the dates and then the difference in days is calculated.
	 *
	 * @param laterDate - The later date
	 * @param earlierDate - The earlier date
	 * @param options - The options object
	 *
	 * @returns The number of calendar days
	 *
	 * @example
	 * // How many calendar days are between
	 * // 2 July 2011 23:00:00 and 2 July 2012 00:00:00?
	 * const result = differenceInCalendarDays(
	 *   new Date(2012, 6, 2, 0, 0),
	 *   new Date(2011, 6, 2, 23, 0)
	 * )
	 * //=> 366
	 * // How many calendar days are between
	 * // 2 July 2011 23:59:00 and 3 July 2011 00:01:00?
	 * const result = differenceInCalendarDays(
	 *   new Date(2011, 6, 3, 0, 1),
	 *   new Date(2011, 6, 2, 23, 59)
	 * )
	 * //=> 1
	 */
	function differenceInCalendarDays(laterDate, earlierDate, options) {
	  const [laterDate_, earlierDate_] = normalizeDates(
	    options?.in,
	    laterDate,
	    earlierDate,
	  );

	  const laterStartOfDay = startOfDay(laterDate_);
	  const earlierStartOfDay = startOfDay(earlierDate_);

	  const laterTimestamp =
	    +laterStartOfDay - getTimezoneOffsetInMilliseconds(laterStartOfDay);
	  const earlierTimestamp =
	    +earlierStartOfDay - getTimezoneOffsetInMilliseconds(earlierStartOfDay);

	  // Round the number of days to the nearest integer because the number of
	  // milliseconds in a day is not constant (e.g. it's different in the week of
	  // the daylight saving time clock shift).
	  return Math.round((laterTimestamp - earlierTimestamp) / millisecondsInDay);
	}

	/**
	 * The {@link startOfISOWeekYear} function options.
	 */

	/**
	 * @name startOfISOWeekYear
	 * @category ISO Week-Numbering Year Helpers
	 * @summary Return the start of an ISO week-numbering year for the given date.
	 *
	 * @description
	 * Return the start of an ISO week-numbering year,
	 * which always starts 3 days before the year's first Thursday.
	 * The result will be in the local timezone.
	 *
	 * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date
	 *
	 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
	 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
	 *
	 * @param date - The original date
	 * @param options - An object with options
	 *
	 * @returns The start of an ISO week-numbering year
	 *
	 * @example
	 * // The start of an ISO week-numbering year for 2 July 2005:
	 * const result = startOfISOWeekYear(new Date(2005, 6, 2))
	 * //=> Mon Jan 03 2005 00:00:00
	 */
	function startOfISOWeekYear(date, options) {
	  const year = getISOWeekYear(date, options);
	  const fourthOfJanuary = constructFrom(date, 0);
	  fourthOfJanuary.setFullYear(year, 0, 4);
	  fourthOfJanuary.setHours(0, 0, 0, 0);
	  return startOfISOWeek(fourthOfJanuary);
	}

	/**
	 * @name isDate
	 * @category Common Helpers
	 * @summary Is the given value a date?
	 *
	 * @description
	 * Returns true if the given value is an instance of Date. The function works for dates transferred across iframes.
	 *
	 * @param value - The value to check
	 *
	 * @returns True if the given value is a date
	 *
	 * @example
	 * // For a valid date:
	 * const result = isDate(new Date())
	 * //=> true
	 *
	 * @example
	 * // For an invalid date:
	 * const result = isDate(new Date(NaN))
	 * //=> true
	 *
	 * @example
	 * // For some value:
	 * const result = isDate('2014-02-31')
	 * //=> false
	 *
	 * @example
	 * // For an object:
	 * const result = isDate({})
	 * //=> false
	 */
	function isDate(value) {
	  return (
	    value instanceof Date ||
	    (typeof value === "object" &&
	      Object.prototype.toString.call(value) === "[object Date]")
	  );
	}

	/**
	 * @name isValid
	 * @category Common Helpers
	 * @summary Is the given date valid?
	 *
	 * @description
	 * Returns false if argument is Invalid Date and true otherwise.
	 * Argument is converted to Date using `toDate`. See [toDate](https://date-fns.org/docs/toDate)
	 * Invalid Date is a Date, whose time value is NaN.
	 *
	 * Time value of Date: http://es5.github.io/#x15.9.1.1
	 *
	 * @param date - The date to check
	 *
	 * @returns The date is valid
	 *
	 * @example
	 * // For the valid date:
	 * const result = isValid(new Date(2014, 1, 31))
	 * //=> true
	 *
	 * @example
	 * // For the value, convertible into a date:
	 * const result = isValid(1393804800000)
	 * //=> true
	 *
	 * @example
	 * // For the invalid date:
	 * const result = isValid(new Date(''))
	 * //=> false
	 */
	function isValid(date) {
	  return !((!isDate(date) && typeof date !== "number") || isNaN(+toDate(date)));
	}

	/**
	 * The {@link differenceInDays} function options.
	 */

	/**
	 * @name differenceInDays
	 * @category Day Helpers
	 * @summary Get the number of full days between the given dates.
	 *
	 * @description
	 * Get the number of full day periods between two dates. Fractional days are
	 * truncated towards zero.
	 *
	 * One "full day" is the distance between a local time in one day to the same
	 * local time on the next or previous day. A full day can sometimes be less than
	 * or more than 24 hours if a daylight savings change happens between two dates.
	 *
	 * To ignore DST and only measure exact 24-hour periods, use this instead:
	 * `Math.trunc(differenceInHours(dateLeft, dateRight)/24)|0`.
	 *
	 * @param laterDate - The later date
	 * @param earlierDate - The earlier date
	 * @param options - An object with options
	 *
	 * @returns The number of full days according to the local timezone
	 *
	 * @example
	 * // How many full days are between
	 * // 2 July 2011 23:00:00 and 2 July 2012 00:00:00?
	 * const result = differenceInDays(
	 *   new Date(2012, 6, 2, 0, 0),
	 *   new Date(2011, 6, 2, 23, 0)
	 * )
	 * //=> 365
	 *
	 * @example
	 * // How many full days are between
	 * // 2 July 2011 23:59:00 and 3 July 2011 00:01:00?
	 * const result = differenceInDays(
	 *   new Date(2011, 6, 3, 0, 1),
	 *   new Date(2011, 6, 2, 23, 59)
	 * )
	 * //=> 0
	 *
	 * @example
	 * // How many full days are between
	 * // 1 March 2020 0:00 and 1 June 2020 0:00 ?
	 * // Note: because local time is used, the
	 * // result will always be 92 days, even in
	 * // time zones where DST starts and the
	 * // period has only 92*24-1 hours.
	 * const result = differenceInDays(
	 *   new Date(2020, 5, 1),
	 *   new Date(2020, 2, 1)
	 * )
	 * //=> 92
	 */
	function differenceInDays(laterDate, earlierDate, options) {
	  const [laterDate_, earlierDate_] = normalizeDates(
	    options?.in,
	    laterDate,
	    earlierDate,
	  );

	  const sign = compareLocalAsc(laterDate_, earlierDate_);
	  const difference = Math.abs(
	    differenceInCalendarDays(laterDate_, earlierDate_),
	  );

	  laterDate_.setDate(laterDate_.getDate() - sign * difference);

	  // Math.abs(diff in full days - diff in calendar days) === 1 if last calendar day is not full
	  // If so, result must be decreased by 1 in absolute value
	  const isLastDayNotFull = Number(
	    compareLocalAsc(laterDate_, earlierDate_) === -sign,
	  );

	  const result = sign * (difference - isLastDayNotFull);
	  // Prevent negative zero
	  return result === 0 ? 0 : result;
	}

	// Like `compareAsc` but uses local time not UTC, which is needed
	// for accurate equality comparisons of UTC timestamps that end up
	// having the same representation in local time, e.g. one hour before
	// DST ends vs. the instant that DST ends.
	function compareLocalAsc(laterDate, earlierDate) {
	  const diff =
	    laterDate.getFullYear() - earlierDate.getFullYear() ||
	    laterDate.getMonth() - earlierDate.getMonth() ||
	    laterDate.getDate() - earlierDate.getDate() ||
	    laterDate.getHours() - earlierDate.getHours() ||
	    laterDate.getMinutes() - earlierDate.getMinutes() ||
	    laterDate.getSeconds() - earlierDate.getSeconds() ||
	    laterDate.getMilliseconds() - earlierDate.getMilliseconds();

	  if (diff < 0) return -1;
	  if (diff > 0) return 1;

	  // Return 0 if diff is 0; return NaN if diff is NaN
	  return diff;
	}

	/**
	 * The {@link startOfYear} function options.
	 */

	/**
	 * @name startOfYear
	 * @category Year Helpers
	 * @summary Return the start of a year for the given date.
	 *
	 * @description
	 * Return the start of a year for the given date.
	 * The result will be in the local timezone.
	 *
	 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
	 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
	 *
	 * @param date - The original date
	 * @param options - The options
	 *
	 * @returns The start of a year
	 *
	 * @example
	 * // The start of a year for 2 September 2014 11:55:00:
	 * const result = startOfYear(new Date(2014, 8, 2, 11, 55, 00))
	 * //=> Wed Jan 01 2014 00:00:00
	 */
	function startOfYear(date, options) {
	  const date_ = toDate(date, options?.in);
	  date_.setFullYear(date_.getFullYear(), 0, 1);
	  date_.setHours(0, 0, 0, 0);
	  return date_;
	}

	const formatDistanceLocale = {
	  lessThanXSeconds: {
	    one: "less than a second",
	    other: "less than {{count}} seconds",
	  },

	  xSeconds: {
	    one: "1 second",
	    other: "{{count}} seconds",
	  },

	  halfAMinute: "half a minute",

	  lessThanXMinutes: {
	    one: "less than a minute",
	    other: "less than {{count}} minutes",
	  },

	  xMinutes: {
	    one: "1 minute",
	    other: "{{count}} minutes",
	  },

	  aboutXHours: {
	    one: "about 1 hour",
	    other: "about {{count}} hours",
	  },

	  xHours: {
	    one: "1 hour",
	    other: "{{count}} hours",
	  },

	  xDays: {
	    one: "1 day",
	    other: "{{count}} days",
	  },

	  aboutXWeeks: {
	    one: "about 1 week",
	    other: "about {{count}} weeks",
	  },

	  xWeeks: {
	    one: "1 week",
	    other: "{{count}} weeks",
	  },

	  aboutXMonths: {
	    one: "about 1 month",
	    other: "about {{count}} months",
	  },

	  xMonths: {
	    one: "1 month",
	    other: "{{count}} months",
	  },

	  aboutXYears: {
	    one: "about 1 year",
	    other: "about {{count}} years",
	  },

	  xYears: {
	    one: "1 year",
	    other: "{{count}} years",
	  },

	  overXYears: {
	    one: "over 1 year",
	    other: "over {{count}} years",
	  },

	  almostXYears: {
	    one: "almost 1 year",
	    other: "almost {{count}} years",
	  },
	};

	const formatDistance = (token, count, options) => {
	  let result;

	  const tokenValue = formatDistanceLocale[token];
	  if (typeof tokenValue === "string") {
	    result = tokenValue;
	  } else if (count === 1) {
	    result = tokenValue.one;
	  } else {
	    result = tokenValue.other.replace("{{count}}", count.toString());
	  }

	  if (options?.addSuffix) {
	    if (options.comparison && options.comparison > 0) {
	      return "in " + result;
	    } else {
	      return result + " ago";
	    }
	  }

	  return result;
	};

	function buildFormatLongFn(args) {
	  return (options = {}) => {
	    // TODO: Remove String()
	    const width = options.width ? String(options.width) : args.defaultWidth;
	    const format = args.formats[width] || args.formats[args.defaultWidth];
	    return format;
	  };
	}

	const dateFormats = {
	  full: "EEEE, MMMM do, y",
	  long: "MMMM do, y",
	  medium: "MMM d, y",
	  short: "MM/dd/yyyy",
	};

	const timeFormats = {
	  full: "h:mm:ss a zzzz",
	  long: "h:mm:ss a z",
	  medium: "h:mm:ss a",
	  short: "h:mm a",
	};

	const dateTimeFormats = {
	  full: "{{date}} 'at' {{time}}",
	  long: "{{date}} 'at' {{time}}",
	  medium: "{{date}}, {{time}}",
	  short: "{{date}}, {{time}}",
	};

	const formatLong = {
	  date: buildFormatLongFn({
	    formats: dateFormats,
	    defaultWidth: "full",
	  }),

	  time: buildFormatLongFn({
	    formats: timeFormats,
	    defaultWidth: "full",
	  }),

	  dateTime: buildFormatLongFn({
	    formats: dateTimeFormats,
	    defaultWidth: "full",
	  }),
	};

	const formatRelativeLocale = {
	  lastWeek: "'last' eeee 'at' p",
	  yesterday: "'yesterday at' p",
	  today: "'today at' p",
	  tomorrow: "'tomorrow at' p",
	  nextWeek: "eeee 'at' p",
	  other: "P",
	};

	const formatRelative = (token, _date, _baseDate, _options) =>
	  formatRelativeLocale[token];

	/**
	 * The localize function argument callback which allows to convert raw value to
	 * the actual type.
	 *
	 * @param value - The value to convert
	 *
	 * @returns The converted value
	 */

	/**
	 * The map of localized values for each width.
	 */

	/**
	 * The index type of the locale unit value. It types conversion of units of
	 * values that don't start at 0 (i.e. quarters).
	 */

	/**
	 * Converts the unit value to the tuple of values.
	 */

	/**
	 * The tuple of localized era values. The first element represents BC,
	 * the second element represents AD.
	 */

	/**
	 * The tuple of localized quarter values. The first element represents Q1.
	 */

	/**
	 * The tuple of localized day values. The first element represents Sunday.
	 */

	/**
	 * The tuple of localized month values. The first element represents January.
	 */

	function buildLocalizeFn(args) {
	  return (value, options) => {
	    const context = options?.context ? String(options.context) : "standalone";

	    let valuesArray;
	    if (context === "formatting" && args.formattingValues) {
	      const defaultWidth = args.defaultFormattingWidth || args.defaultWidth;
	      const width = options?.width ? String(options.width) : defaultWidth;

	      valuesArray =
	        args.formattingValues[width] || args.formattingValues[defaultWidth];
	    } else {
	      const defaultWidth = args.defaultWidth;
	      const width = options?.width ? String(options.width) : args.defaultWidth;

	      valuesArray = args.values[width] || args.values[defaultWidth];
	    }
	    const index = args.argumentCallback ? args.argumentCallback(value) : value;

	    // @ts-expect-error - For some reason TypeScript just don't want to match it, no matter how hard we try. I challenge you to try to remove it!
	    return valuesArray[index];
	  };
	}

	const eraValues = {
	  narrow: ["B", "A"],
	  abbreviated: ["BC", "AD"],
	  wide: ["Before Christ", "Anno Domini"],
	};

	const quarterValues = {
	  narrow: ["1", "2", "3", "4"],
	  abbreviated: ["Q1", "Q2", "Q3", "Q4"],
	  wide: ["1st quarter", "2nd quarter", "3rd quarter", "4th quarter"],
	};

	// Note: in English, the names of days of the week and months are capitalized.
	// If you are making a new locale based on this one, check if the same is true for the language you're working on.
	// Generally, formatted dates should look like they are in the middle of a sentence,
	// e.g. in Spanish language the weekdays and months should be in the lowercase.
	const monthValues = {
	  narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
	  abbreviated: [
	    "Jan",
	    "Feb",
	    "Mar",
	    "Apr",
	    "May",
	    "Jun",
	    "Jul",
	    "Aug",
	    "Sep",
	    "Oct",
	    "Nov",
	    "Dec",
	  ],

	  wide: [
	    "January",
	    "February",
	    "March",
	    "April",
	    "May",
	    "June",
	    "July",
	    "August",
	    "September",
	    "October",
	    "November",
	    "December",
	  ],
	};

	const dayValues = {
	  narrow: ["S", "M", "T", "W", "T", "F", "S"],
	  short: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
	  abbreviated: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
	  wide: [
	    "Sunday",
	    "Monday",
	    "Tuesday",
	    "Wednesday",
	    "Thursday",
	    "Friday",
	    "Saturday",
	  ],
	};

	const dayPeriodValues = {
	  narrow: {
	    am: "a",
	    pm: "p",
	    midnight: "mi",
	    noon: "n",
	    morning: "morning",
	    afternoon: "afternoon",
	    evening: "evening",
	    night: "night",
	  },
	  abbreviated: {
	    am: "AM",
	    pm: "PM",
	    midnight: "midnight",
	    noon: "noon",
	    morning: "morning",
	    afternoon: "afternoon",
	    evening: "evening",
	    night: "night",
	  },
	  wide: {
	    am: "a.m.",
	    pm: "p.m.",
	    midnight: "midnight",
	    noon: "noon",
	    morning: "morning",
	    afternoon: "afternoon",
	    evening: "evening",
	    night: "night",
	  },
	};

	const formattingDayPeriodValues = {
	  narrow: {
	    am: "a",
	    pm: "p",
	    midnight: "mi",
	    noon: "n",
	    morning: "in the morning",
	    afternoon: "in the afternoon",
	    evening: "in the evening",
	    night: "at night",
	  },
	  abbreviated: {
	    am: "AM",
	    pm: "PM",
	    midnight: "midnight",
	    noon: "noon",
	    morning: "in the morning",
	    afternoon: "in the afternoon",
	    evening: "in the evening",
	    night: "at night",
	  },
	  wide: {
	    am: "a.m.",
	    pm: "p.m.",
	    midnight: "midnight",
	    noon: "noon",
	    morning: "in the morning",
	    afternoon: "in the afternoon",
	    evening: "in the evening",
	    night: "at night",
	  },
	};

	const ordinalNumber = (dirtyNumber, _options) => {
	  const number = Number(dirtyNumber);

	  // If ordinal numbers depend on context, for example,
	  // if they are different for different grammatical genders,
	  // use `options.unit`.
	  //
	  // `unit` can be 'year', 'quarter', 'month', 'week', 'date', 'dayOfYear',
	  // 'day', 'hour', 'minute', 'second'.

	  const rem100 = number % 100;
	  if (rem100 > 20 || rem100 < 10) {
	    switch (rem100 % 10) {
	      case 1:
	        return number + "st";
	      case 2:
	        return number + "nd";
	      case 3:
	        return number + "rd";
	    }
	  }
	  return number + "th";
	};

	const localize = {
	  ordinalNumber,

	  era: buildLocalizeFn({
	    values: eraValues,
	    defaultWidth: "wide",
	  }),

	  quarter: buildLocalizeFn({
	    values: quarterValues,
	    defaultWidth: "wide",
	    argumentCallback: (quarter) => quarter - 1,
	  }),

	  month: buildLocalizeFn({
	    values: monthValues,
	    defaultWidth: "wide",
	  }),

	  day: buildLocalizeFn({
	    values: dayValues,
	    defaultWidth: "wide",
	  }),

	  dayPeriod: buildLocalizeFn({
	    values: dayPeriodValues,
	    defaultWidth: "wide",
	    formattingValues: formattingDayPeriodValues,
	    defaultFormattingWidth: "wide",
	  }),
	};

	function buildMatchFn(args) {
	  return (string, options = {}) => {
	    const width = options.width;

	    const matchPattern =
	      (width && args.matchPatterns[width]) ||
	      args.matchPatterns[args.defaultMatchWidth];
	    const matchResult = string.match(matchPattern);

	    if (!matchResult) {
	      return null;
	    }
	    const matchedString = matchResult[0];

	    const parsePatterns =
	      (width && args.parsePatterns[width]) ||
	      args.parsePatterns[args.defaultParseWidth];

	    const key = Array.isArray(parsePatterns)
	      ? findIndex(parsePatterns, (pattern) => pattern.test(matchedString))
	      : // [TODO] -- I challenge you to fix the type
	        findKey(parsePatterns, (pattern) => pattern.test(matchedString));

	    let value;

	    value = args.valueCallback ? args.valueCallback(key) : key;
	    value = options.valueCallback
	      ? // [TODO] -- I challenge you to fix the type
	        options.valueCallback(value)
	      : value;

	    const rest = string.slice(matchedString.length);

	    return { value, rest };
	  };
	}

	function findKey(object, predicate) {
	  for (const key in object) {
	    if (
	      Object.prototype.hasOwnProperty.call(object, key) &&
	      predicate(object[key])
	    ) {
	      return key;
	    }
	  }
	  return undefined;
	}

	function findIndex(array, predicate) {
	  for (let key = 0; key < array.length; key++) {
	    if (predicate(array[key])) {
	      return key;
	    }
	  }
	  return undefined;
	}

	function buildMatchPatternFn(args) {
	  return (string, options = {}) => {
	    const matchResult = string.match(args.matchPattern);
	    if (!matchResult) return null;
	    const matchedString = matchResult[0];

	    const parseResult = string.match(args.parsePattern);
	    if (!parseResult) return null;
	    let value = args.valueCallback
	      ? args.valueCallback(parseResult[0])
	      : parseResult[0];

	    // [TODO] I challenge you to fix the type
	    value = options.valueCallback ? options.valueCallback(value) : value;

	    const rest = string.slice(matchedString.length);

	    return { value, rest };
	  };
	}

	const matchOrdinalNumberPattern = /^(\d+)(th|st|nd|rd)?/i;
	const parseOrdinalNumberPattern = /\d+/i;

	const matchEraPatterns = {
	  narrow: /^(b|a)/i,
	  abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
	  wide: /^(before christ|before common era|anno domini|common era)/i,
	};
	const parseEraPatterns = {
	  any: [/^b/i, /^(a|c)/i],
	};

	const matchQuarterPatterns = {
	  narrow: /^[1234]/i,
	  abbreviated: /^q[1234]/i,
	  wide: /^[1234](th|st|nd|rd)? quarter/i,
	};
	const parseQuarterPatterns = {
	  any: [/1/i, /2/i, /3/i, /4/i],
	};

	const matchMonthPatterns = {
	  narrow: /^[jfmasond]/i,
	  abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
	  wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i,
	};
	const parseMonthPatterns = {
	  narrow: [
	    /^j/i,
	    /^f/i,
	    /^m/i,
	    /^a/i,
	    /^m/i,
	    /^j/i,
	    /^j/i,
	    /^a/i,
	    /^s/i,
	    /^o/i,
	    /^n/i,
	    /^d/i,
	  ],

	  any: [
	    /^ja/i,
	    /^f/i,
	    /^mar/i,
	    /^ap/i,
	    /^may/i,
	    /^jun/i,
	    /^jul/i,
	    /^au/i,
	    /^s/i,
	    /^o/i,
	    /^n/i,
	    /^d/i,
	  ],
	};

	const matchDayPatterns = {
	  narrow: /^[smtwf]/i,
	  short: /^(su|mo|tu|we|th|fr|sa)/i,
	  abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
	  wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i,
	};
	const parseDayPatterns = {
	  narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
	  any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i],
	};

	const matchDayPeriodPatterns = {
	  narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
	  any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i,
	};
	const parseDayPeriodPatterns = {
	  any: {
	    am: /^a/i,
	    pm: /^p/i,
	    midnight: /^mi/i,
	    noon: /^no/i,
	    morning: /morning/i,
	    afternoon: /afternoon/i,
	    evening: /evening/i,
	    night: /night/i,
	  },
	};

	const match = {
	  ordinalNumber: buildMatchPatternFn({
	    matchPattern: matchOrdinalNumberPattern,
	    parsePattern: parseOrdinalNumberPattern,
	    valueCallback: (value) => parseInt(value, 10),
	  }),

	  era: buildMatchFn({
	    matchPatterns: matchEraPatterns,
	    defaultMatchWidth: "wide",
	    parsePatterns: parseEraPatterns,
	    defaultParseWidth: "any",
	  }),

	  quarter: buildMatchFn({
	    matchPatterns: matchQuarterPatterns,
	    defaultMatchWidth: "wide",
	    parsePatterns: parseQuarterPatterns,
	    defaultParseWidth: "any",
	    valueCallback: (index) => index + 1,
	  }),

	  month: buildMatchFn({
	    matchPatterns: matchMonthPatterns,
	    defaultMatchWidth: "wide",
	    parsePatterns: parseMonthPatterns,
	    defaultParseWidth: "any",
	  }),

	  day: buildMatchFn({
	    matchPatterns: matchDayPatterns,
	    defaultMatchWidth: "wide",
	    parsePatterns: parseDayPatterns,
	    defaultParseWidth: "any",
	  }),

	  dayPeriod: buildMatchFn({
	    matchPatterns: matchDayPeriodPatterns,
	    defaultMatchWidth: "any",
	    parsePatterns: parseDayPeriodPatterns,
	    defaultParseWidth: "any",
	  }),
	};

	/**
	 * @category Locales
	 * @summary English locale (United States).
	 * @language English
	 * @iso-639-2 eng
	 * @author Sasha Koss [@kossnocorp](https://github.com/kossnocorp)
	 * @author Lesha Koss [@leshakoss](https://github.com/leshakoss)
	 */
	const enUS = {
	  code: "en-US",
	  formatDistance: formatDistance,
	  formatLong: formatLong,
	  formatRelative: formatRelative,
	  localize: localize,
	  match: match,
	  options: {
	    weekStartsOn: 0 /* Sunday */,
	    firstWeekContainsDate: 1,
	  },
	};

	/**
	 * The {@link getDayOfYear} function options.
	 */

	/**
	 * @name getDayOfYear
	 * @category Day Helpers
	 * @summary Get the day of the year of the given date.
	 *
	 * @description
	 * Get the day of the year of the given date.
	 *
	 * @param date - The given date
	 * @param options - The options
	 *
	 * @returns The day of year
	 *
	 * @example
	 * // Which day of the year is 2 July 2014?
	 * const result = getDayOfYear(new Date(2014, 6, 2))
	 * //=> 183
	 */
	function getDayOfYear(date, options) {
	  const _date = toDate(date, options?.in);
	  const diff = differenceInCalendarDays(_date, startOfYear(_date));
	  const dayOfYear = diff + 1;
	  return dayOfYear;
	}

	/**
	 * The {@link getISOWeek} function options.
	 */

	/**
	 * @name getISOWeek
	 * @category ISO Week Helpers
	 * @summary Get the ISO week of the given date.
	 *
	 * @description
	 * Get the ISO week of the given date.
	 *
	 * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date
	 *
	 * @param date - The given date
	 * @param options - The options
	 *
	 * @returns The ISO week
	 *
	 * @example
	 * // Which week of the ISO-week numbering year is 2 January 2005?
	 * const result = getISOWeek(new Date(2005, 0, 2))
	 * //=> 53
	 */
	function getISOWeek(date, options) {
	  const _date = toDate(date, options?.in);
	  const diff = +startOfISOWeek(_date) - +startOfISOWeekYear(_date);

	  // Round the number of weeks to the nearest integer because the number of
	  // milliseconds in a week is not constant (e.g. it's different in the week of
	  // the daylight saving time clock shift).
	  return Math.round(diff / millisecondsInWeek) + 1;
	}

	/**
	 * The {@link getWeekYear} function options.
	 */

	/**
	 * @name getWeekYear
	 * @category Week-Numbering Year Helpers
	 * @summary Get the local week-numbering year of the given date.
	 *
	 * @description
	 * Get the local week-numbering year of the given date.
	 * The exact calculation depends on the values of
	 * `options.weekStartsOn` (which is the index of the first day of the week)
	 * and `options.firstWeekContainsDate` (which is the day of January, which is always in
	 * the first week of the week-numbering year)
	 *
	 * Week numbering: https://en.wikipedia.org/wiki/Week#The_ISO_week_date_system
	 *
	 * @param date - The given date
	 * @param options - An object with options.
	 *
	 * @returns The local week-numbering year
	 *
	 * @example
	 * // Which week numbering year is 26 December 2004 with the default settings?
	 * const result = getWeekYear(new Date(2004, 11, 26))
	 * //=> 2005
	 *
	 * @example
	 * // Which week numbering year is 26 December 2004 if week starts on Saturday?
	 * const result = getWeekYear(new Date(2004, 11, 26), { weekStartsOn: 6 })
	 * //=> 2004
	 *
	 * @example
	 * // Which week numbering year is 26 December 2004 if the first week contains 4 January?
	 * const result = getWeekYear(new Date(2004, 11, 26), { firstWeekContainsDate: 4 })
	 * //=> 2004
	 */
	function getWeekYear(date, options) {
	  const _date = toDate(date, options?.in);
	  const year = _date.getFullYear();

	  const defaultOptions = getDefaultOptions();
	  const firstWeekContainsDate =
	    options?.firstWeekContainsDate ??
	    options?.locale?.options?.firstWeekContainsDate ??
	    defaultOptions.firstWeekContainsDate ??
	    defaultOptions.locale?.options?.firstWeekContainsDate ??
	    1;

	  const firstWeekOfNextYear = constructFrom(options?.in || date, 0);
	  firstWeekOfNextYear.setFullYear(year + 1, 0, firstWeekContainsDate);
	  firstWeekOfNextYear.setHours(0, 0, 0, 0);
	  const startOfNextYear = startOfWeek(firstWeekOfNextYear, options);

	  const firstWeekOfThisYear = constructFrom(options?.in || date, 0);
	  firstWeekOfThisYear.setFullYear(year, 0, firstWeekContainsDate);
	  firstWeekOfThisYear.setHours(0, 0, 0, 0);
	  const startOfThisYear = startOfWeek(firstWeekOfThisYear, options);

	  if (+_date >= +startOfNextYear) {
	    return year + 1;
	  } else if (+_date >= +startOfThisYear) {
	    return year;
	  } else {
	    return year - 1;
	  }
	}

	/**
	 * The {@link startOfWeekYear} function options.
	 */

	/**
	 * @name startOfWeekYear
	 * @category Week-Numbering Year Helpers
	 * @summary Return the start of a local week-numbering year for the given date.
	 *
	 * @description
	 * Return the start of a local week-numbering year.
	 * The exact calculation depends on the values of
	 * `options.weekStartsOn` (which is the index of the first day of the week)
	 * and `options.firstWeekContainsDate` (which is the day of January, which is always in
	 * the first week of the week-numbering year)
	 *
	 * Week numbering: https://en.wikipedia.org/wiki/Week#The_ISO_week_date_system
	 *
	 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
	 * @typeParam ResultDate - The result `Date` type.
	 *
	 * @param date - The original date
	 * @param options - An object with options
	 *
	 * @returns The start of a week-numbering year
	 *
	 * @example
	 * // The start of an a week-numbering year for 2 July 2005 with default settings:
	 * const result = startOfWeekYear(new Date(2005, 6, 2))
	 * //=> Sun Dec 26 2004 00:00:00
	 *
	 * @example
	 * // The start of a week-numbering year for 2 July 2005
	 * // if Monday is the first day of week
	 * // and 4 January is always in the first week of the year:
	 * const result = startOfWeekYear(new Date(2005, 6, 2), {
	 *   weekStartsOn: 1,
	 *   firstWeekContainsDate: 4
	 * })
	 * //=> Mon Jan 03 2005 00:00:00
	 */
	function startOfWeekYear(date, options) {
	  const defaultOptions = getDefaultOptions();
	  const firstWeekContainsDate =
	    options?.firstWeekContainsDate ??
	    options?.locale?.options?.firstWeekContainsDate ??
	    defaultOptions.firstWeekContainsDate ??
	    defaultOptions.locale?.options?.firstWeekContainsDate ??
	    1;

	  const year = getWeekYear(date, options);
	  const firstWeek = constructFrom(options?.in || date, 0);
	  firstWeek.setFullYear(year, 0, firstWeekContainsDate);
	  firstWeek.setHours(0, 0, 0, 0);
	  const _date = startOfWeek(firstWeek, options);
	  return _date;
	}

	/**
	 * The {@link getWeek} function options.
	 */

	/**
	 * @name getWeek
	 * @category Week Helpers
	 * @summary Get the local week index of the given date.
	 *
	 * @description
	 * Get the local week index of the given date.
	 * The exact calculation depends on the values of
	 * `options.weekStartsOn` (which is the index of the first day of the week)
	 * and `options.firstWeekContainsDate` (which is the day of January, which is always in
	 * the first week of the week-numbering year)
	 *
	 * Week numbering: https://en.wikipedia.org/wiki/Week#The_ISO_week_date_system
	 *
	 * @param date - The given date
	 * @param options - An object with options
	 *
	 * @returns The week
	 *
	 * @example
	 * // Which week of the local week numbering year is 2 January 2005 with default options?
	 * const result = getWeek(new Date(2005, 0, 2))
	 * //=> 2
	 *
	 * @example
	 * // Which week of the local week numbering year is 2 January 2005,
	 * // if Monday is the first day of the week,
	 * // and the first week of the year always contains 4 January?
	 * const result = getWeek(new Date(2005, 0, 2), {
	 *   weekStartsOn: 1,
	 *   firstWeekContainsDate: 4
	 * })
	 * //=> 53
	 */
	function getWeek(date, options) {
	  const _date = toDate(date, options?.in);
	  const diff = +startOfWeek(_date, options) - +startOfWeekYear(_date, options);

	  // Round the number of weeks to the nearest integer because the number of
	  // milliseconds in a week is not constant (e.g. it's different in the week of
	  // the daylight saving time clock shift).
	  return Math.round(diff / millisecondsInWeek) + 1;
	}

	function addLeadingZeros(number, targetLength) {
	  const sign = number < 0 ? "-" : "";
	  const output = Math.abs(number).toString().padStart(targetLength, "0");
	  return sign + output;
	}

	/*
	 * |     | Unit                           |     | Unit                           |
	 * |-----|--------------------------------|-----|--------------------------------|
	 * |  a  | AM, PM                         |  A* |                                |
	 * |  d  | Day of month                   |  D  |                                |
	 * |  h  | Hour [1-12]                    |  H  | Hour [0-23]                    |
	 * |  m  | Minute                         |  M  | Month                          |
	 * |  s  | Second                         |  S  | Fraction of second             |
	 * |  y  | Year (abs)                     |  Y  |                                |
	 *
	 * Letters marked by * are not implemented but reserved by Unicode standard.
	 */

	const lightFormatters = {
	  // Year
	  y(date, token) {
	    // From http://www.unicode.org/reports/tr35/tr35-31/tr35-dates.html#Date_Format_tokens
	    // | Year     |     y | yy |   yyy |  yyyy | yyyyy |
	    // |----------|-------|----|-------|-------|-------|
	    // | AD 1     |     1 | 01 |   001 |  0001 | 00001 |
	    // | AD 12    |    12 | 12 |   012 |  0012 | 00012 |
	    // | AD 123   |   123 | 23 |   123 |  0123 | 00123 |
	    // | AD 1234  |  1234 | 34 |  1234 |  1234 | 01234 |
	    // | AD 12345 | 12345 | 45 | 12345 | 12345 | 12345 |

	    const signedYear = date.getFullYear();
	    // Returns 1 for 1 BC (which is year 0 in JavaScript)
	    const year = signedYear > 0 ? signedYear : 1 - signedYear;
	    return addLeadingZeros(token === "yy" ? year % 100 : year, token.length);
	  },

	  // Month
	  M(date, token) {
	    const month = date.getMonth();
	    return token === "M" ? String(month + 1) : addLeadingZeros(month + 1, 2);
	  },

	  // Day of the month
	  d(date, token) {
	    return addLeadingZeros(date.getDate(), token.length);
	  },

	  // AM or PM
	  a(date, token) {
	    const dayPeriodEnumValue = date.getHours() / 12 >= 1 ? "pm" : "am";

	    switch (token) {
	      case "a":
	      case "aa":
	        return dayPeriodEnumValue.toUpperCase();
	      case "aaa":
	        return dayPeriodEnumValue;
	      case "aaaaa":
	        return dayPeriodEnumValue[0];
	      case "aaaa":
	      default:
	        return dayPeriodEnumValue === "am" ? "a.m." : "p.m.";
	    }
	  },

	  // Hour [1-12]
	  h(date, token) {
	    return addLeadingZeros(date.getHours() % 12 || 12, token.length);
	  },

	  // Hour [0-23]
	  H(date, token) {
	    return addLeadingZeros(date.getHours(), token.length);
	  },

	  // Minute
	  m(date, token) {
	    return addLeadingZeros(date.getMinutes(), token.length);
	  },

	  // Second
	  s(date, token) {
	    return addLeadingZeros(date.getSeconds(), token.length);
	  },

	  // Fraction of second
	  S(date, token) {
	    const numberOfDigits = token.length;
	    const milliseconds = date.getMilliseconds();
	    const fractionalSeconds = Math.trunc(
	      milliseconds * Math.pow(10, numberOfDigits - 3),
	    );
	    return addLeadingZeros(fractionalSeconds, token.length);
	  },
	};

	const dayPeriodEnum = {
	  midnight: "midnight",
	  noon: "noon",
	  morning: "morning",
	  afternoon: "afternoon",
	  evening: "evening",
	  night: "night",
	};

	/*
	 * |     | Unit                           |     | Unit                           |
	 * |-----|--------------------------------|-----|--------------------------------|
	 * |  a  | AM, PM                         |  A* | Milliseconds in day            |
	 * |  b  | AM, PM, noon, midnight         |  B  | Flexible day period            |
	 * |  c  | Stand-alone local day of week  |  C* | Localized hour w/ day period   |
	 * |  d  | Day of month                   |  D  | Day of year                    |
	 * |  e  | Local day of week              |  E  | Day of week                    |
	 * |  f  |                                |  F* | Day of week in month           |
	 * |  g* | Modified Julian day            |  G  | Era                            |
	 * |  h  | Hour [1-12]                    |  H  | Hour [0-23]                    |
	 * |  i! | ISO day of week                |  I! | ISO week of year               |
	 * |  j* | Localized hour w/ day period   |  J* | Localized hour w/o day period  |
	 * |  k  | Hour [1-24]                    |  K  | Hour [0-11]                    |
	 * |  l* | (deprecated)                   |  L  | Stand-alone month              |
	 * |  m  | Minute                         |  M  | Month                          |
	 * |  n  |                                |  N  |                                |
	 * |  o! | Ordinal number modifier        |  O  | Timezone (GMT)                 |
	 * |  p! | Long localized time            |  P! | Long localized date            |
	 * |  q  | Stand-alone quarter            |  Q  | Quarter                        |
	 * |  r* | Related Gregorian year         |  R! | ISO week-numbering year        |
	 * |  s  | Second                         |  S  | Fraction of second             |
	 * |  t! | Seconds timestamp              |  T! | Milliseconds timestamp         |
	 * |  u  | Extended year                  |  U* | Cyclic year                    |
	 * |  v* | Timezone (generic non-locat.)  |  V* | Timezone (location)            |
	 * |  w  | Local week of year             |  W* | Week of month                  |
	 * |  x  | Timezone (ISO-8601 w/o Z)      |  X  | Timezone (ISO-8601)            |
	 * |  y  | Year (abs)                     |  Y  | Local week-numbering year      |
	 * |  z  | Timezone (specific non-locat.) |  Z* | Timezone (aliases)             |
	 *
	 * Letters marked by * are not implemented but reserved by Unicode standard.
	 *
	 * Letters marked by ! are non-standard, but implemented by date-fns:
	 * - `o` modifies the previous token to turn it into an ordinal (see `format` docs)
	 * - `i` is ISO day of week. For `i` and `ii` is returns numeric ISO week days,
	 *   i.e. 7 for Sunday, 1 for Monday, etc.
	 * - `I` is ISO week of year, as opposed to `w` which is local week of year.
	 * - `R` is ISO week-numbering year, as opposed to `Y` which is local week-numbering year.
	 *   `R` is supposed to be used in conjunction with `I` and `i`
	 *   for universal ISO week-numbering date, whereas
	 *   `Y` is supposed to be used in conjunction with `w` and `e`
	 *   for week-numbering date specific to the locale.
	 * - `P` is long localized date format
	 * - `p` is long localized time format
	 */

	const formatters = {
	  // Era
	  G: function (date, token, localize) {
	    const era = date.getFullYear() > 0 ? 1 : 0;
	    switch (token) {
	      // AD, BC
	      case "G":
	      case "GG":
	      case "GGG":
	        return localize.era(era, { width: "abbreviated" });
	      // A, B
	      case "GGGGG":
	        return localize.era(era, { width: "narrow" });
	      // Anno Domini, Before Christ
	      case "GGGG":
	      default:
	        return localize.era(era, { width: "wide" });
	    }
	  },

	  // Year
	  y: function (date, token, localize) {
	    // Ordinal number
	    if (token === "yo") {
	      const signedYear = date.getFullYear();
	      // Returns 1 for 1 BC (which is year 0 in JavaScript)
	      const year = signedYear > 0 ? signedYear : 1 - signedYear;
	      return localize.ordinalNumber(year, { unit: "year" });
	    }

	    return lightFormatters.y(date, token);
	  },

	  // Local week-numbering year
	  Y: function (date, token, localize, options) {
	    const signedWeekYear = getWeekYear(date, options);
	    // Returns 1 for 1 BC (which is year 0 in JavaScript)
	    const weekYear = signedWeekYear > 0 ? signedWeekYear : 1 - signedWeekYear;

	    // Two digit year
	    if (token === "YY") {
	      const twoDigitYear = weekYear % 100;
	      return addLeadingZeros(twoDigitYear, 2);
	    }

	    // Ordinal number
	    if (token === "Yo") {
	      return localize.ordinalNumber(weekYear, { unit: "year" });
	    }

	    // Padding
	    return addLeadingZeros(weekYear, token.length);
	  },

	  // ISO week-numbering year
	  R: function (date, token) {
	    const isoWeekYear = getISOWeekYear(date);

	    // Padding
	    return addLeadingZeros(isoWeekYear, token.length);
	  },

	  // Extended year. This is a single number designating the year of this calendar system.
	  // The main difference between `y` and `u` localizers are B.C. years:
	  // | Year | `y` | `u` |
	  // |------|-----|-----|
	  // | AC 1 |   1 |   1 |
	  // | BC 1 |   1 |   0 |
	  // | BC 2 |   2 |  -1 |
	  // Also `yy` always returns the last two digits of a year,
	  // while `uu` pads single digit years to 2 characters and returns other years unchanged.
	  u: function (date, token) {
	    const year = date.getFullYear();
	    return addLeadingZeros(year, token.length);
	  },

	  // Quarter
	  Q: function (date, token, localize) {
	    const quarter = Math.ceil((date.getMonth() + 1) / 3);
	    switch (token) {
	      // 1, 2, 3, 4
	      case "Q":
	        return String(quarter);
	      // 01, 02, 03, 04
	      case "QQ":
	        return addLeadingZeros(quarter, 2);
	      // 1st, 2nd, 3rd, 4th
	      case "Qo":
	        return localize.ordinalNumber(quarter, { unit: "quarter" });
	      // Q1, Q2, Q3, Q4
	      case "QQQ":
	        return localize.quarter(quarter, {
	          width: "abbreviated",
	          context: "formatting",
	        });
	      // 1, 2, 3, 4 (narrow quarter; could be not numerical)
	      case "QQQQQ":
	        return localize.quarter(quarter, {
	          width: "narrow",
	          context: "formatting",
	        });
	      // 1st quarter, 2nd quarter, ...
	      case "QQQQ":
	      default:
	        return localize.quarter(quarter, {
	          width: "wide",
	          context: "formatting",
	        });
	    }
	  },

	  // Stand-alone quarter
	  q: function (date, token, localize) {
	    const quarter = Math.ceil((date.getMonth() + 1) / 3);
	    switch (token) {
	      // 1, 2, 3, 4
	      case "q":
	        return String(quarter);
	      // 01, 02, 03, 04
	      case "qq":
	        return addLeadingZeros(quarter, 2);
	      // 1st, 2nd, 3rd, 4th
	      case "qo":
	        return localize.ordinalNumber(quarter, { unit: "quarter" });
	      // Q1, Q2, Q3, Q4
	      case "qqq":
	        return localize.quarter(quarter, {
	          width: "abbreviated",
	          context: "standalone",
	        });
	      // 1, 2, 3, 4 (narrow quarter; could be not numerical)
	      case "qqqqq":
	        return localize.quarter(quarter, {
	          width: "narrow",
	          context: "standalone",
	        });
	      // 1st quarter, 2nd quarter, ...
	      case "qqqq":
	      default:
	        return localize.quarter(quarter, {
	          width: "wide",
	          context: "standalone",
	        });
	    }
	  },

	  // Month
	  M: function (date, token, localize) {
	    const month = date.getMonth();
	    switch (token) {
	      case "M":
	      case "MM":
	        return lightFormatters.M(date, token);
	      // 1st, 2nd, ..., 12th
	      case "Mo":
	        return localize.ordinalNumber(month + 1, { unit: "month" });
	      // Jan, Feb, ..., Dec
	      case "MMM":
	        return localize.month(month, {
	          width: "abbreviated",
	          context: "formatting",
	        });
	      // J, F, ..., D
	      case "MMMMM":
	        return localize.month(month, {
	          width: "narrow",
	          context: "formatting",
	        });
	      // January, February, ..., December
	      case "MMMM":
	      default:
	        return localize.month(month, { width: "wide", context: "formatting" });
	    }
	  },

	  // Stand-alone month
	  L: function (date, token, localize) {
	    const month = date.getMonth();
	    switch (token) {
	      // 1, 2, ..., 12
	      case "L":
	        return String(month + 1);
	      // 01, 02, ..., 12
	      case "LL":
	        return addLeadingZeros(month + 1, 2);
	      // 1st, 2nd, ..., 12th
	      case "Lo":
	        return localize.ordinalNumber(month + 1, { unit: "month" });
	      // Jan, Feb, ..., Dec
	      case "LLL":
	        return localize.month(month, {
	          width: "abbreviated",
	          context: "standalone",
	        });
	      // J, F, ..., D
	      case "LLLLL":
	        return localize.month(month, {
	          width: "narrow",
	          context: "standalone",
	        });
	      // January, February, ..., December
	      case "LLLL":
	      default:
	        return localize.month(month, { width: "wide", context: "standalone" });
	    }
	  },

	  // Local week of year
	  w: function (date, token, localize, options) {
	    const week = getWeek(date, options);

	    if (token === "wo") {
	      return localize.ordinalNumber(week, { unit: "week" });
	    }

	    return addLeadingZeros(week, token.length);
	  },

	  // ISO week of year
	  I: function (date, token, localize) {
	    const isoWeek = getISOWeek(date);

	    if (token === "Io") {
	      return localize.ordinalNumber(isoWeek, { unit: "week" });
	    }

	    return addLeadingZeros(isoWeek, token.length);
	  },

	  // Day of the month
	  d: function (date, token, localize) {
	    if (token === "do") {
	      return localize.ordinalNumber(date.getDate(), { unit: "date" });
	    }

	    return lightFormatters.d(date, token);
	  },

	  // Day of year
	  D: function (date, token, localize) {
	    const dayOfYear = getDayOfYear(date);

	    if (token === "Do") {
	      return localize.ordinalNumber(dayOfYear, { unit: "dayOfYear" });
	    }

	    return addLeadingZeros(dayOfYear, token.length);
	  },

	  // Day of week
	  E: function (date, token, localize) {
	    const dayOfWeek = date.getDay();
	    switch (token) {
	      // Tue
	      case "E":
	      case "EE":
	      case "EEE":
	        return localize.day(dayOfWeek, {
	          width: "abbreviated",
	          context: "formatting",
	        });
	      // T
	      case "EEEEE":
	        return localize.day(dayOfWeek, {
	          width: "narrow",
	          context: "formatting",
	        });
	      // Tu
	      case "EEEEEE":
	        return localize.day(dayOfWeek, {
	          width: "short",
	          context: "formatting",
	        });
	      // Tuesday
	      case "EEEE":
	      default:
	        return localize.day(dayOfWeek, {
	          width: "wide",
	          context: "formatting",
	        });
	    }
	  },

	  // Local day of week
	  e: function (date, token, localize, options) {
	    const dayOfWeek = date.getDay();
	    const localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;
	    switch (token) {
	      // Numerical value (Nth day of week with current locale or weekStartsOn)
	      case "e":
	        return String(localDayOfWeek);
	      // Padded numerical value
	      case "ee":
	        return addLeadingZeros(localDayOfWeek, 2);
	      // 1st, 2nd, ..., 7th
	      case "eo":
	        return localize.ordinalNumber(localDayOfWeek, { unit: "day" });
	      case "eee":
	        return localize.day(dayOfWeek, {
	          width: "abbreviated",
	          context: "formatting",
	        });
	      // T
	      case "eeeee":
	        return localize.day(dayOfWeek, {
	          width: "narrow",
	          context: "formatting",
	        });
	      // Tu
	      case "eeeeee":
	        return localize.day(dayOfWeek, {
	          width: "short",
	          context: "formatting",
	        });
	      // Tuesday
	      case "eeee":
	      default:
	        return localize.day(dayOfWeek, {
	          width: "wide",
	          context: "formatting",
	        });
	    }
	  },

	  // Stand-alone local day of week
	  c: function (date, token, localize, options) {
	    const dayOfWeek = date.getDay();
	    const localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;
	    switch (token) {
	      // Numerical value (same as in `e`)
	      case "c":
	        return String(localDayOfWeek);
	      // Padded numerical value
	      case "cc":
	        return addLeadingZeros(localDayOfWeek, token.length);
	      // 1st, 2nd, ..., 7th
	      case "co":
	        return localize.ordinalNumber(localDayOfWeek, { unit: "day" });
	      case "ccc":
	        return localize.day(dayOfWeek, {
	          width: "abbreviated",
	          context: "standalone",
	        });
	      // T
	      case "ccccc":
	        return localize.day(dayOfWeek, {
	          width: "narrow",
	          context: "standalone",
	        });
	      // Tu
	      case "cccccc":
	        return localize.day(dayOfWeek, {
	          width: "short",
	          context: "standalone",
	        });
	      // Tuesday
	      case "cccc":
	      default:
	        return localize.day(dayOfWeek, {
	          width: "wide",
	          context: "standalone",
	        });
	    }
	  },

	  // ISO day of week
	  i: function (date, token, localize) {
	    const dayOfWeek = date.getDay();
	    const isoDayOfWeek = dayOfWeek === 0 ? 7 : dayOfWeek;
	    switch (token) {
	      // 2
	      case "i":
	        return String(isoDayOfWeek);
	      // 02
	      case "ii":
	        return addLeadingZeros(isoDayOfWeek, token.length);
	      // 2nd
	      case "io":
	        return localize.ordinalNumber(isoDayOfWeek, { unit: "day" });
	      // Tue
	      case "iii":
	        return localize.day(dayOfWeek, {
	          width: "abbreviated",
	          context: "formatting",
	        });
	      // T
	      case "iiiii":
	        return localize.day(dayOfWeek, {
	          width: "narrow",
	          context: "formatting",
	        });
	      // Tu
	      case "iiiiii":
	        return localize.day(dayOfWeek, {
	          width: "short",
	          context: "formatting",
	        });
	      // Tuesday
	      case "iiii":
	      default:
	        return localize.day(dayOfWeek, {
	          width: "wide",
	          context: "formatting",
	        });
	    }
	  },

	  // AM or PM
	  a: function (date, token, localize) {
	    const hours = date.getHours();
	    const dayPeriodEnumValue = hours / 12 >= 1 ? "pm" : "am";

	    switch (token) {
	      case "a":
	      case "aa":
	        return localize.dayPeriod(dayPeriodEnumValue, {
	          width: "abbreviated",
	          context: "formatting",
	        });
	      case "aaa":
	        return localize
	          .dayPeriod(dayPeriodEnumValue, {
	            width: "abbreviated",
	            context: "formatting",
	          })
	          .toLowerCase();
	      case "aaaaa":
	        return localize.dayPeriod(dayPeriodEnumValue, {
	          width: "narrow",
	          context: "formatting",
	        });
	      case "aaaa":
	      default:
	        return localize.dayPeriod(dayPeriodEnumValue, {
	          width: "wide",
	          context: "formatting",
	        });
	    }
	  },

	  // AM, PM, midnight, noon
	  b: function (date, token, localize) {
	    const hours = date.getHours();
	    let dayPeriodEnumValue;
	    if (hours === 12) {
	      dayPeriodEnumValue = dayPeriodEnum.noon;
	    } else if (hours === 0) {
	      dayPeriodEnumValue = dayPeriodEnum.midnight;
	    } else {
	      dayPeriodEnumValue = hours / 12 >= 1 ? "pm" : "am";
	    }

	    switch (token) {
	      case "b":
	      case "bb":
	        return localize.dayPeriod(dayPeriodEnumValue, {
	          width: "abbreviated",
	          context: "formatting",
	        });
	      case "bbb":
	        return localize
	          .dayPeriod(dayPeriodEnumValue, {
	            width: "abbreviated",
	            context: "formatting",
	          })
	          .toLowerCase();
	      case "bbbbb":
	        return localize.dayPeriod(dayPeriodEnumValue, {
	          width: "narrow",
	          context: "formatting",
	        });
	      case "bbbb":
	      default:
	        return localize.dayPeriod(dayPeriodEnumValue, {
	          width: "wide",
	          context: "formatting",
	        });
	    }
	  },

	  // in the morning, in the afternoon, in the evening, at night
	  B: function (date, token, localize) {
	    const hours = date.getHours();
	    let dayPeriodEnumValue;
	    if (hours >= 17) {
	      dayPeriodEnumValue = dayPeriodEnum.evening;
	    } else if (hours >= 12) {
	      dayPeriodEnumValue = dayPeriodEnum.afternoon;
	    } else if (hours >= 4) {
	      dayPeriodEnumValue = dayPeriodEnum.morning;
	    } else {
	      dayPeriodEnumValue = dayPeriodEnum.night;
	    }

	    switch (token) {
	      case "B":
	      case "BB":
	      case "BBB":
	        return localize.dayPeriod(dayPeriodEnumValue, {
	          width: "abbreviated",
	          context: "formatting",
	        });
	      case "BBBBB":
	        return localize.dayPeriod(dayPeriodEnumValue, {
	          width: "narrow",
	          context: "formatting",
	        });
	      case "BBBB":
	      default:
	        return localize.dayPeriod(dayPeriodEnumValue, {
	          width: "wide",
	          context: "formatting",
	        });
	    }
	  },

	  // Hour [1-12]
	  h: function (date, token, localize) {
	    if (token === "ho") {
	      let hours = date.getHours() % 12;
	      if (hours === 0) hours = 12;
	      return localize.ordinalNumber(hours, { unit: "hour" });
	    }

	    return lightFormatters.h(date, token);
	  },

	  // Hour [0-23]
	  H: function (date, token, localize) {
	    if (token === "Ho") {
	      return localize.ordinalNumber(date.getHours(), { unit: "hour" });
	    }

	    return lightFormatters.H(date, token);
	  },

	  // Hour [0-11]
	  K: function (date, token, localize) {
	    const hours = date.getHours() % 12;

	    if (token === "Ko") {
	      return localize.ordinalNumber(hours, { unit: "hour" });
	    }

	    return addLeadingZeros(hours, token.length);
	  },

	  // Hour [1-24]
	  k: function (date, token, localize) {
	    let hours = date.getHours();
	    if (hours === 0) hours = 24;

	    if (token === "ko") {
	      return localize.ordinalNumber(hours, { unit: "hour" });
	    }

	    return addLeadingZeros(hours, token.length);
	  },

	  // Minute
	  m: function (date, token, localize) {
	    if (token === "mo") {
	      return localize.ordinalNumber(date.getMinutes(), { unit: "minute" });
	    }

	    return lightFormatters.m(date, token);
	  },

	  // Second
	  s: function (date, token, localize) {
	    if (token === "so") {
	      return localize.ordinalNumber(date.getSeconds(), { unit: "second" });
	    }

	    return lightFormatters.s(date, token);
	  },

	  // Fraction of second
	  S: function (date, token) {
	    return lightFormatters.S(date, token);
	  },

	  // Timezone (ISO-8601. If offset is 0, output is always `'Z'`)
	  X: function (date, token, _localize) {
	    const timezoneOffset = date.getTimezoneOffset();

	    if (timezoneOffset === 0) {
	      return "Z";
	    }

	    switch (token) {
	      // Hours and optional minutes
	      case "X":
	        return formatTimezoneWithOptionalMinutes(timezoneOffset);

	      // Hours, minutes and optional seconds without `:` delimiter
	      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
	      // so this token always has the same output as `XX`
	      case "XXXX":
	      case "XX": // Hours and minutes without `:` delimiter
	        return formatTimezone(timezoneOffset);

	      // Hours, minutes and optional seconds with `:` delimiter
	      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
	      // so this token always has the same output as `XXX`
	      case "XXXXX":
	      case "XXX": // Hours and minutes with `:` delimiter
	      default:
	        return formatTimezone(timezoneOffset, ":");
	    }
	  },

	  // Timezone (ISO-8601. If offset is 0, output is `'+00:00'` or equivalent)
	  x: function (date, token, _localize) {
	    const timezoneOffset = date.getTimezoneOffset();

	    switch (token) {
	      // Hours and optional minutes
	      case "x":
	        return formatTimezoneWithOptionalMinutes(timezoneOffset);

	      // Hours, minutes and optional seconds without `:` delimiter
	      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
	      // so this token always has the same output as `xx`
	      case "xxxx":
	      case "xx": // Hours and minutes without `:` delimiter
	        return formatTimezone(timezoneOffset);

	      // Hours, minutes and optional seconds with `:` delimiter
	      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
	      // so this token always has the same output as `xxx`
	      case "xxxxx":
	      case "xxx": // Hours and minutes with `:` delimiter
	      default:
	        return formatTimezone(timezoneOffset, ":");
	    }
	  },

	  // Timezone (GMT)
	  O: function (date, token, _localize) {
	    const timezoneOffset = date.getTimezoneOffset();

	    switch (token) {
	      // Short
	      case "O":
	      case "OO":
	      case "OOO":
	        return "GMT" + formatTimezoneShort(timezoneOffset, ":");
	      // Long
	      case "OOOO":
	      default:
	        return "GMT" + formatTimezone(timezoneOffset, ":");
	    }
	  },

	  // Timezone (specific non-location)
	  z: function (date, token, _localize) {
	    const timezoneOffset = date.getTimezoneOffset();

	    switch (token) {
	      // Short
	      case "z":
	      case "zz":
	      case "zzz":
	        return "GMT" + formatTimezoneShort(timezoneOffset, ":");
	      // Long
	      case "zzzz":
	      default:
	        return "GMT" + formatTimezone(timezoneOffset, ":");
	    }
	  },

	  // Seconds timestamp
	  t: function (date, token, _localize) {
	    const timestamp = Math.trunc(+date / 1000);
	    return addLeadingZeros(timestamp, token.length);
	  },

	  // Milliseconds timestamp
	  T: function (date, token, _localize) {
	    return addLeadingZeros(+date, token.length);
	  },
	};

	function formatTimezoneShort(offset, delimiter = "") {
	  const sign = offset > 0 ? "-" : "+";
	  const absOffset = Math.abs(offset);
	  const hours = Math.trunc(absOffset / 60);
	  const minutes = absOffset % 60;
	  if (minutes === 0) {
	    return sign + String(hours);
	  }
	  return sign + String(hours) + delimiter + addLeadingZeros(minutes, 2);
	}

	function formatTimezoneWithOptionalMinutes(offset, delimiter) {
	  if (offset % 60 === 0) {
	    const sign = offset > 0 ? "-" : "+";
	    return sign + addLeadingZeros(Math.abs(offset) / 60, 2);
	  }
	  return formatTimezone(offset, delimiter);
	}

	function formatTimezone(offset, delimiter = "") {
	  const sign = offset > 0 ? "-" : "+";
	  const absOffset = Math.abs(offset);
	  const hours = addLeadingZeros(Math.trunc(absOffset / 60), 2);
	  const minutes = addLeadingZeros(absOffset % 60, 2);
	  return sign + hours + delimiter + minutes;
	}

	const dateLongFormatter = (pattern, formatLong) => {
	  switch (pattern) {
	    case "P":
	      return formatLong.date({ width: "short" });
	    case "PP":
	      return formatLong.date({ width: "medium" });
	    case "PPP":
	      return formatLong.date({ width: "long" });
	    case "PPPP":
	    default:
	      return formatLong.date({ width: "full" });
	  }
	};

	const timeLongFormatter = (pattern, formatLong) => {
	  switch (pattern) {
	    case "p":
	      return formatLong.time({ width: "short" });
	    case "pp":
	      return formatLong.time({ width: "medium" });
	    case "ppp":
	      return formatLong.time({ width: "long" });
	    case "pppp":
	    default:
	      return formatLong.time({ width: "full" });
	  }
	};

	const dateTimeLongFormatter = (pattern, formatLong) => {
	  const matchResult = pattern.match(/(P+)(p+)?/) || [];
	  const datePattern = matchResult[1];
	  const timePattern = matchResult[2];

	  if (!timePattern) {
	    return dateLongFormatter(pattern, formatLong);
	  }

	  let dateTimeFormat;

	  switch (datePattern) {
	    case "P":
	      dateTimeFormat = formatLong.dateTime({ width: "short" });
	      break;
	    case "PP":
	      dateTimeFormat = formatLong.dateTime({ width: "medium" });
	      break;
	    case "PPP":
	      dateTimeFormat = formatLong.dateTime({ width: "long" });
	      break;
	    case "PPPP":
	    default:
	      dateTimeFormat = formatLong.dateTime({ width: "full" });
	      break;
	  }

	  return dateTimeFormat
	    .replace("{{date}}", dateLongFormatter(datePattern, formatLong))
	    .replace("{{time}}", timeLongFormatter(timePattern, formatLong));
	};

	const longFormatters = {
	  p: timeLongFormatter,
	  P: dateTimeLongFormatter,
	};

	const dayOfYearTokenRE = /^D+$/;
	const weekYearTokenRE = /^Y+$/;

	const throwTokens = ["D", "DD", "YY", "YYYY"];

	function isProtectedDayOfYearToken(token) {
	  return dayOfYearTokenRE.test(token);
	}

	function isProtectedWeekYearToken(token) {
	  return weekYearTokenRE.test(token);
	}

	function warnOrThrowProtectedError(token, format, input) {
	  const _message = message(token, format, input);
	  console.warn(_message);
	  if (throwTokens.includes(token)) throw new RangeError(_message);
	}

	function message(token, format, input) {
	  const subject = token[0] === "Y" ? "years" : "days of the month";
	  return `Use \`${token.toLowerCase()}\` instead of \`${token}\` (in \`${format}\`) for formatting ${subject} to the input \`${input}\`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md`;
	}

	// This RegExp consists of three parts separated by `|`:
	// - [yYQqMLwIdDecihHKkms]o matches any available ordinal number token
	//   (one of the certain letters followed by `o`)
	// - (\w)\1* matches any sequences of the same letter
	// - '' matches two quote characters in a row
	// - '(''|[^'])+('|$) matches anything surrounded by two quote characters ('),
	//   except a single quote symbol, which ends the sequence.
	//   Two quote characters do not end the sequence.
	//   If there is no matching single quote
	//   then the sequence will continue until the end of the string.
	// - . matches any single character unmatched by previous parts of the RegExps
	const formattingTokensRegExp =
	  /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g;

	// This RegExp catches symbols escaped by quotes, and also
	// sequences of symbols P, p, and the combinations like `PPPPPPPppppp`
	const longFormattingTokensRegExp = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;

	const escapedStringRegExp = /^'([^]*?)'?$/;
	const doubleQuoteRegExp = /''/g;
	const unescapedLatinCharacterRegExp = /[a-zA-Z]/;

	/**
	 * The {@link format} function options.
	 */

	/**
	 * @name format
	 * @alias formatDate
	 * @category Common Helpers
	 * @summary Format the date.
	 *
	 * @description
	 * Return the formatted date string in the given format. The result may vary by locale.
	 *
	 * >  Please note that the `format` tokens differ from Moment.js and other libraries.
	 * > See: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
	 *
	 * The characters wrapped between two single quotes characters (') are escaped.
	 * Two single quotes in a row, whether inside or outside a quoted sequence, represent a 'real' single quote.
	 * (see the last example)
	 *
	 * Format of the string is based on Unicode Technical Standard #35:
	 * https://www.unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table
	 * with a few additions (see note 7 below the table).
	 *
	 * Accepted patterns:
	 * | Unit                            | Pattern | Result examples                   | Notes |
	 * |---------------------------------|---------|-----------------------------------|-------|
	 * | Era                             | G..GGG  | AD, BC                            |       |
	 * |                                 | GGGG    | Anno Domini, Before Christ        | 2     |
	 * |                                 | GGGGG   | A, B                              |       |
	 * | Calendar year                   | y       | 44, 1, 1900, 2017                 | 5     |
	 * |                                 | yo      | 44th, 1st, 0th, 17th              | 5,7   |
	 * |                                 | yy      | 44, 01, 00, 17                    | 5     |
	 * |                                 | yyy     | 044, 001, 1900, 2017              | 5     |
	 * |                                 | yyyy    | 0044, 0001, 1900, 2017            | 5     |
	 * |                                 | yyyyy   | ...                               | 3,5   |
	 * | Local week-numbering year       | Y       | 44, 1, 1900, 2017                 | 5     |
	 * |                                 | Yo      | 44th, 1st, 1900th, 2017th         | 5,7   |
	 * |                                 | YY      | 44, 01, 00, 17                    | 5,8   |
	 * |                                 | YYY     | 044, 001, 1900, 2017              | 5     |
	 * |                                 | YYYY    | 0044, 0001, 1900, 2017            | 5,8   |
	 * |                                 | YYYYY   | ...                               | 3,5   |
	 * | ISO week-numbering year         | R       | -43, 0, 1, 1900, 2017             | 5,7   |
	 * |                                 | RR      | -43, 00, 01, 1900, 2017           | 5,7   |
	 * |                                 | RRR     | -043, 000, 001, 1900, 2017        | 5,7   |
	 * |                                 | RRRR    | -0043, 0000, 0001, 1900, 2017     | 5,7   |
	 * |                                 | RRRRR   | ...                               | 3,5,7 |
	 * | Extended year                   | u       | -43, 0, 1, 1900, 2017             | 5     |
	 * |                                 | uu      | -43, 01, 1900, 2017               | 5     |
	 * |                                 | uuu     | -043, 001, 1900, 2017             | 5     |
	 * |                                 | uuuu    | -0043, 0001, 1900, 2017           | 5     |
	 * |                                 | uuuuu   | ...                               | 3,5   |
	 * | Quarter (formatting)            | Q       | 1, 2, 3, 4                        |       |
	 * |                                 | Qo      | 1st, 2nd, 3rd, 4th                | 7     |
	 * |                                 | QQ      | 01, 02, 03, 04                    |       |
	 * |                                 | QQQ     | Q1, Q2, Q3, Q4                    |       |
	 * |                                 | QQQQ    | 1st quarter, 2nd quarter, ...     | 2     |
	 * |                                 | QQQQQ   | 1, 2, 3, 4                        | 4     |
	 * | Quarter (stand-alone)           | q       | 1, 2, 3, 4                        |       |
	 * |                                 | qo      | 1st, 2nd, 3rd, 4th                | 7     |
	 * |                                 | qq      | 01, 02, 03, 04                    |       |
	 * |                                 | qqq     | Q1, Q2, Q3, Q4                    |       |
	 * |                                 | qqqq    | 1st quarter, 2nd quarter, ...     | 2     |
	 * |                                 | qqqqq   | 1, 2, 3, 4                        | 4     |
	 * | Month (formatting)              | M       | 1, 2, ..., 12                     |       |
	 * |                                 | Mo      | 1st, 2nd, ..., 12th               | 7     |
	 * |                                 | MM      | 01, 02, ..., 12                   |       |
	 * |                                 | MMM     | Jan, Feb, ..., Dec                |       |
	 * |                                 | MMMM    | January, February, ..., December  | 2     |
	 * |                                 | MMMMM   | J, F, ..., D                      |       |
	 * | Month (stand-alone)             | L       | 1, 2, ..., 12                     |       |
	 * |                                 | Lo      | 1st, 2nd, ..., 12th               | 7     |
	 * |                                 | LL      | 01, 02, ..., 12                   |       |
	 * |                                 | LLL     | Jan, Feb, ..., Dec                |       |
	 * |                                 | LLLL    | January, February, ..., December  | 2     |
	 * |                                 | LLLLL   | J, F, ..., D                      |       |
	 * | Local week of year              | w       | 1, 2, ..., 53                     |       |
	 * |                                 | wo      | 1st, 2nd, ..., 53th               | 7     |
	 * |                                 | ww      | 01, 02, ..., 53                   |       |
	 * | ISO week of year                | I       | 1, 2, ..., 53                     | 7     |
	 * |                                 | Io      | 1st, 2nd, ..., 53th               | 7     |
	 * |                                 | II      | 01, 02, ..., 53                   | 7     |
	 * | Day of month                    | d       | 1, 2, ..., 31                     |       |
	 * |                                 | do      | 1st, 2nd, ..., 31st               | 7     |
	 * |                                 | dd      | 01, 02, ..., 31                   |       |
	 * | Day of year                     | D       | 1, 2, ..., 365, 366               | 9     |
	 * |                                 | Do      | 1st, 2nd, ..., 365th, 366th       | 7     |
	 * |                                 | DD      | 01, 02, ..., 365, 366             | 9     |
	 * |                                 | DDD     | 001, 002, ..., 365, 366           |       |
	 * |                                 | DDDD    | ...                               | 3     |
	 * | Day of week (formatting)        | E..EEE  | Mon, Tue, Wed, ..., Sun           |       |
	 * |                                 | EEEE    | Monday, Tuesday, ..., Sunday      | 2     |
	 * |                                 | EEEEE   | M, T, W, T, F, S, S               |       |
	 * |                                 | EEEEEE  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
	 * | ISO day of week (formatting)    | i       | 1, 2, 3, ..., 7                   | 7     |
	 * |                                 | io      | 1st, 2nd, ..., 7th                | 7     |
	 * |                                 | ii      | 01, 02, ..., 07                   | 7     |
	 * |                                 | iii     | Mon, Tue, Wed, ..., Sun           | 7     |
	 * |                                 | iiii    | Monday, Tuesday, ..., Sunday      | 2,7   |
	 * |                                 | iiiii   | M, T, W, T, F, S, S               | 7     |
	 * |                                 | iiiiii  | Mo, Tu, We, Th, Fr, Sa, Su        | 7     |
	 * | Local day of week (formatting)  | e       | 2, 3, 4, ..., 1                   |       |
	 * |                                 | eo      | 2nd, 3rd, ..., 1st                | 7     |
	 * |                                 | ee      | 02, 03, ..., 01                   |       |
	 * |                                 | eee     | Mon, Tue, Wed, ..., Sun           |       |
	 * |                                 | eeee    | Monday, Tuesday, ..., Sunday      | 2     |
	 * |                                 | eeeee   | M, T, W, T, F, S, S               |       |
	 * |                                 | eeeeee  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
	 * | Local day of week (stand-alone) | c       | 2, 3, 4, ..., 1                   |       |
	 * |                                 | co      | 2nd, 3rd, ..., 1st                | 7     |
	 * |                                 | cc      | 02, 03, ..., 01                   |       |
	 * |                                 | ccc     | Mon, Tue, Wed, ..., Sun           |       |
	 * |                                 | cccc    | Monday, Tuesday, ..., Sunday      | 2     |
	 * |                                 | ccccc   | M, T, W, T, F, S, S               |       |
	 * |                                 | cccccc  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
	 * | AM, PM                          | a..aa   | AM, PM                            |       |
	 * |                                 | aaa     | am, pm                            |       |
	 * |                                 | aaaa    | a.m., p.m.                        | 2     |
	 * |                                 | aaaaa   | a, p                              |       |
	 * | AM, PM, noon, midnight          | b..bb   | AM, PM, noon, midnight            |       |
	 * |                                 | bbb     | am, pm, noon, midnight            |       |
	 * |                                 | bbbb    | a.m., p.m., noon, midnight        | 2     |
	 * |                                 | bbbbb   | a, p, n, mi                       |       |
	 * | Flexible day period             | B..BBB  | at night, in the morning, ...     |       |
	 * |                                 | BBBB    | at night, in the morning, ...     | 2     |
	 * |                                 | BBBBB   | at night, in the morning, ...     |       |
	 * | Hour [1-12]                     | h       | 1, 2, ..., 11, 12                 |       |
	 * |                                 | ho      | 1st, 2nd, ..., 11th, 12th         | 7     |
	 * |                                 | hh      | 01, 02, ..., 11, 12               |       |
	 * | Hour [0-23]                     | H       | 0, 1, 2, ..., 23                  |       |
	 * |                                 | Ho      | 0th, 1st, 2nd, ..., 23rd          | 7     |
	 * |                                 | HH      | 00, 01, 02, ..., 23               |       |
	 * | Hour [0-11]                     | K       | 1, 2, ..., 11, 0                  |       |
	 * |                                 | Ko      | 1st, 2nd, ..., 11th, 0th          | 7     |
	 * |                                 | KK      | 01, 02, ..., 11, 00               |       |
	 * | Hour [1-24]                     | k       | 24, 1, 2, ..., 23                 |       |
	 * |                                 | ko      | 24th, 1st, 2nd, ..., 23rd         | 7     |
	 * |                                 | kk      | 24, 01, 02, ..., 23               |       |
	 * | Minute                          | m       | 0, 1, ..., 59                     |       |
	 * |                                 | mo      | 0th, 1st, ..., 59th               | 7     |
	 * |                                 | mm      | 00, 01, ..., 59                   |       |
	 * | Second                          | s       | 0, 1, ..., 59                     |       |
	 * |                                 | so      | 0th, 1st, ..., 59th               | 7     |
	 * |                                 | ss      | 00, 01, ..., 59                   |       |
	 * | Fraction of second              | S       | 0, 1, ..., 9                      |       |
	 * |                                 | SS      | 00, 01, ..., 99                   |       |
	 * |                                 | SSS     | 000, 001, ..., 999                |       |
	 * |                                 | SSSS    | ...                               | 3     |
	 * | Timezone (ISO-8601 w/ Z)        | X       | -08, +0530, Z                     |       |
	 * |                                 | XX      | -0800, +0530, Z                   |       |
	 * |                                 | XXX     | -08:00, +05:30, Z                 |       |
	 * |                                 | XXXX    | -0800, +0530, Z, +123456          | 2     |
	 * |                                 | XXXXX   | -08:00, +05:30, Z, +12:34:56      |       |
	 * | Timezone (ISO-8601 w/o Z)       | x       | -08, +0530, +00                   |       |
	 * |                                 | xx      | -0800, +0530, +0000               |       |
	 * |                                 | xxx     | -08:00, +05:30, +00:00            | 2     |
	 * |                                 | xxxx    | -0800, +0530, +0000, +123456      |       |
	 * |                                 | xxxxx   | -08:00, +05:30, +00:00, +12:34:56 |       |
	 * | Timezone (GMT)                  | O...OOO | GMT-8, GMT+5:30, GMT+0            |       |
	 * |                                 | OOOO    | GMT-08:00, GMT+05:30, GMT+00:00   | 2     |
	 * | Timezone (specific non-locat.)  | z...zzz | GMT-8, GMT+5:30, GMT+0            | 6     |
	 * |                                 | zzzz    | GMT-08:00, GMT+05:30, GMT+00:00   | 2,6   |
	 * | Seconds timestamp               | t       | 512969520                         | 7     |
	 * |                                 | tt      | ...                               | 3,7   |
	 * | Milliseconds timestamp          | T       | 512969520900                      | 7     |
	 * |                                 | TT      | ...                               | 3,7   |
	 * | Long localized date             | P       | 04/29/1453                        | 7     |
	 * |                                 | PP      | Apr 29, 1453                      | 7     |
	 * |                                 | PPP     | April 29th, 1453                  | 7     |
	 * |                                 | PPPP    | Friday, April 29th, 1453          | 2,7   |
	 * | Long localized time             | p       | 12:00 AM                          | 7     |
	 * |                                 | pp      | 12:00:00 AM                       | 7     |
	 * |                                 | ppp     | 12:00:00 AM GMT+2                 | 7     |
	 * |                                 | pppp    | 12:00:00 AM GMT+02:00             | 2,7   |
	 * | Combination of date and time    | Pp      | 04/29/1453, 12:00 AM              | 7     |
	 * |                                 | PPpp    | Apr 29, 1453, 12:00:00 AM         | 7     |
	 * |                                 | PPPppp  | April 29th, 1453 at ...           | 7     |
	 * |                                 | PPPPpppp| Friday, April 29th, 1453 at ...   | 2,7   |
	 * Notes:
	 * 1. "Formatting" units (e.g. formatting quarter) in the default en-US locale
	 *    are the same as "stand-alone" units, but are different in some languages.
	 *    "Formatting" units are declined according to the rules of the language
	 *    in the context of a date. "Stand-alone" units are always nominative singular:
	 *
	 *    `format(new Date(2017, 10, 6), 'do LLLL', {locale: cs}) //=> '6. listopad'`
	 *
	 *    `format(new Date(2017, 10, 6), 'do MMMM', {locale: cs}) //=> '6. listopadu'`
	 *
	 * 2. Any sequence of the identical letters is a pattern, unless it is escaped by
	 *    the single quote characters (see below).
	 *    If the sequence is longer than listed in table (e.g. `EEEEEEEEEEE`)
	 *    the output will be the same as default pattern for this unit, usually
	 *    the longest one (in case of ISO weekdays, `EEEE`). Default patterns for units
	 *    are marked with "2" in the last column of the table.
	 *
	 *    `format(new Date(2017, 10, 6), 'MMM') //=> 'Nov'`
	 *
	 *    `format(new Date(2017, 10, 6), 'MMMM') //=> 'November'`
	 *
	 *    `format(new Date(2017, 10, 6), 'MMMMM') //=> 'N'`
	 *
	 *    `format(new Date(2017, 10, 6), 'MMMMMM') //=> 'November'`
	 *
	 *    `format(new Date(2017, 10, 6), 'MMMMMMM') //=> 'November'`
	 *
	 * 3. Some patterns could be unlimited length (such as `yyyyyyyy`).
	 *    The output will be padded with zeros to match the length of the pattern.
	 *
	 *    `format(new Date(2017, 10, 6), 'yyyyyyyy') //=> '00002017'`
	 *
	 * 4. `QQQQQ` and `qqqqq` could be not strictly numerical in some locales.
	 *    These tokens represent the shortest form of the quarter.
	 *
	 * 5. The main difference between `y` and `u` patterns are B.C. years:
	 *
	 *    | Year | `y` | `u` |
	 *    |------|-----|-----|
	 *    | AC 1 |   1 |   1 |
	 *    | BC 1 |   1 |   0 |
	 *    | BC 2 |   2 |  -1 |
	 *
	 *    Also `yy` always returns the last two digits of a year,
	 *    while `uu` pads single digit years to 2 characters and returns other years unchanged:
	 *
	 *    | Year | `yy` | `uu` |
	 *    |------|------|------|
	 *    | 1    |   01 |   01 |
	 *    | 14   |   14 |   14 |
	 *    | 376  |   76 |  376 |
	 *    | 1453 |   53 | 1453 |
	 *
	 *    The same difference is true for local and ISO week-numbering years (`Y` and `R`),
	 *    except local week-numbering years are dependent on `options.weekStartsOn`
	 *    and `options.firstWeekContainsDate` (compare [getISOWeekYear](https://date-fns.org/docs/getISOWeekYear)
	 *    and [getWeekYear](https://date-fns.org/docs/getWeekYear)).
	 *
	 * 6. Specific non-location timezones are currently unavailable in `date-fns`,
	 *    so right now these tokens fall back to GMT timezones.
	 *
	 * 7. These patterns are not in the Unicode Technical Standard #35:
	 *    - `i`: ISO day of week
	 *    - `I`: ISO week of year
	 *    - `R`: ISO week-numbering year
	 *    - `t`: seconds timestamp
	 *    - `T`: milliseconds timestamp
	 *    - `o`: ordinal number modifier
	 *    - `P`: long localized date
	 *    - `p`: long localized time
	 *
	 * 8. `YY` and `YYYY` tokens represent week-numbering years but they are often confused with years.
	 *    You should enable `options.useAdditionalWeekYearTokens` to use them. See: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
	 *
	 * 9. `D` and `DD` tokens represent days of the year but they are often confused with days of the month.
	 *    You should enable `options.useAdditionalDayOfYearTokens` to use them. See: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
	 *
	 * @param date - The original date
	 * @param format - The string of tokens
	 * @param options - An object with options
	 *
	 * @returns The formatted date string
	 *
	 * @throws `date` must not be Invalid Date
	 * @throws `options.locale` must contain `localize` property
	 * @throws `options.locale` must contain `formatLong` property
	 * @throws use `yyyy` instead of `YYYY` for formatting years using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
	 * @throws use `yy` instead of `YY` for formatting years using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
	 * @throws use `d` instead of `D` for formatting days of the month using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
	 * @throws use `dd` instead of `DD` for formatting days of the month using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
	 * @throws format string contains an unescaped latin alphabet character
	 *
	 * @example
	 * // Represent 11 February 2014 in middle-endian format:
	 * const result = format(new Date(2014, 1, 11), 'MM/dd/yyyy')
	 * //=> '02/11/2014'
	 *
	 * @example
	 * // Represent 2 July 2014 in Esperanto:
	 * import { eoLocale } from 'date-fns/locale/eo'
	 * const result = format(new Date(2014, 6, 2), "do 'de' MMMM yyyy", {
	 *   locale: eoLocale
	 * })
	 * //=> '2-a de julio 2014'
	 *
	 * @example
	 * // Escape string by single quote characters:
	 * const result = format(new Date(2014, 6, 2, 15), "h 'o''clock'")
	 * //=> "3 o'clock"
	 */
	function format(date, formatStr, options) {
	  const defaultOptions = getDefaultOptions();
	  const locale = defaultOptions.locale ?? enUS;

	  const firstWeekContainsDate =
	    defaultOptions.firstWeekContainsDate ??
	    defaultOptions.locale?.options?.firstWeekContainsDate ??
	    1;

	  const weekStartsOn =
	    defaultOptions.weekStartsOn ??
	    defaultOptions.locale?.options?.weekStartsOn ??
	    0;

	  const originalDate = toDate(date, options?.in);

	  if (!isValid(originalDate)) {
	    throw new RangeError("Invalid time value");
	  }

	  let parts = formatStr
	    .match(longFormattingTokensRegExp)
	    .map((substring) => {
	      const firstCharacter = substring[0];
	      if (firstCharacter === "p" || firstCharacter === "P") {
	        const longFormatter = longFormatters[firstCharacter];
	        return longFormatter(substring, locale.formatLong);
	      }
	      return substring;
	    })
	    .join("")
	    .match(formattingTokensRegExp)
	    .map((substring) => {
	      // Replace two single quote characters with one single quote character
	      if (substring === "''") {
	        return { isToken: false, value: "'" };
	      }

	      const firstCharacter = substring[0];
	      if (firstCharacter === "'") {
	        return { isToken: false, value: cleanEscapedString(substring) };
	      }

	      if (formatters[firstCharacter]) {
	        return { isToken: true, value: substring };
	      }

	      if (firstCharacter.match(unescapedLatinCharacterRegExp)) {
	        throw new RangeError(
	          "Format string contains an unescaped latin alphabet character `" +
	            firstCharacter +
	            "`",
	        );
	      }

	      return { isToken: false, value: substring };
	    });

	  // invoke localize preprocessor (only for french locales at the moment)
	  if (locale.localize.preprocessor) {
	    parts = locale.localize.preprocessor(originalDate, parts);
	  }

	  const formatterOptions = {
	    firstWeekContainsDate,
	    weekStartsOn,
	    locale,
	  };

	  return parts
	    .map((part) => {
	      if (!part.isToken) return part.value;

	      const token = part.value;

	      if (
	        (isProtectedWeekYearToken(token)) ||
	        (isProtectedDayOfYearToken(token))
	      ) {
	        warnOrThrowProtectedError(token, formatStr, String(date));
	      }

	      const formatter = formatters[token[0]];
	      return formatter(originalDate, token, locale.localize, formatterOptions);
	    })
	    .join("");
	}

	function cleanEscapedString(input) {
	  const matched = input.match(escapedStringRegExp);

	  if (!matched) {
	    return input;
	  }

	  return matched[1].replace(doubleQuoteRegExp, "'");
	}

	// src/utils.ts
	const schema = create$3().shape({
	    destinations: create$2().of(create$6().trim()).min(1, "Please select at least one destination").required("Please select destinations"),
	    city: create$6().required("Please choose a departure city").trim(),
	    dates: create$3().shape({
	        start: create$4().required("Select travel start date"),
	        end: create$4()
	            .required("Select travel end date")
	            .test("is-after-start", "End date must be after start date", function (value) {
	            const { start } = this.parent;
	            if (!start || !value)
	                return true;
	            return value > start;
	        })
	            .test("min-nights", "Minimum 3 nights required", function (value) {
	            const { start } = this.parent;
	            if (!start || !value)
	                return true;
	            const diffTime = value.getTime() - start.getTime();
	            const diffDays = diffTime / (1000 * 60 * 60 * 24);
	            return diffDays >= 3; // Minimum 3 nights = 4 days total (start + 3 nights + end)
	        }),
	    }),
	    rooms: create$2()
	        .of(create$3().shape({
	        id: create$8().required(),
	        adults: create$5().min(1, "At least 1 adult required").max(3, "Maximum 3 adults per room").required(),
	        children: create$5().min(0).max(6, "Maximum 6 children per room").required(),
	        infants: create$5().min(0).max(3, "Maximum 3 infants per room"),
	        bedPreference: create$6(),
	        childAges: create$2()
	            .of(create$5().min(1, "Child age must be between 1-17").max(17, "Child age must be between 1-17").required("Age is required"))
	            .when('children', {
	            is: (val) => val > 0,
	            then: (schema) => schema
	                .min(1, "Please enter age for children")
	                .test("length-matches-children", "Please enter valid ages for all children (1-17 years)", function (value) {
	                const { children } = this.parent;
	                if (!value)
	                    return false; // Add this check
	                return value.length === children && value.every((age) => age !== undefined && age !== null);
	            })
	                .required("Please enter age for children"),
	            otherwise: (schema) => schema.notRequired().default([])
	        }),
	    }))
	        .min(1, "Add at least one room")
	        .max(10, "Maximum 10 rooms allowed")
	        .test("at-least-one-adult", "At least 1 adult required across all rooms", function (rooms) {
	        if (!rooms)
	            return false;
	        const totalAdults = rooms.reduce((sum, room) => sum + (room.adults || 0), 0);
	        return totalAdults >= 1;
	    }),
	    preference: create$6().oneOf(["value", "comfort"]).required(),
	    contact: create$3().shape({
	        name: create$6().trim(),
	        phone: create$6()
	            .required("Enter a valid phone number")
	            .test("is-valid-phone", "Enter a valid phone number", function (value) {
	            if (!value)
	                return false;
	            try {
	                const phoneNumber = parsePhoneNumber(value);
	                return phoneNumber ? phoneNumber.isValid() : false;
	            }
	            catch (_a) {
	                // Fallback validation for E.164 format
	                const e164Regex = /^\+[1-9]\d{7,14}$/;
	                const indiaRegex = /^[6-9]\d{9}$/;
	                return e164Regex.test(value) || indiaRegex.test(value);
	            }
	        }),
	        email: create$6().email("Enter a valid email").trim(),
	    }),
	    extras: create$3().shape({
	        visaAssistance: create$7().default(false),
	        travelInsurance: create$7().default(false),
	        includeFlights: create$7().default(false),
	        specialRequests: create$6().trim().default(""),
	    }).required(),
	});
	const formatDate = (date, fmt = "dd MMM yyyy") => {
	    return date ? format(date, fmt) : "";
	};
	const calculateNights = (start, end) => {
	    if (!start || !end)
	        return 0;
	    return differenceInDays(end, start);
	};
	// Phone number utilities
	const formatPhoneNumber = (phoneNumber) => {
	    if (!phoneNumber)
	        return "";
	    try {
	        const parsed = parsePhoneNumber(phoneNumber);
	        if (parsed) {
	            // Format: +91 94400-94018
	            const countryCode = `+${parsed.countryCallingCode}`;
	            const nationalNumber = parsed.nationalNumber.toString();
	            // Format national number based on country
	            let formattedNational = nationalNumber;
	            // India: 94400-94018 (5-5 format)
	            if (parsed.country === 'IN' && nationalNumber.length === 10) {
	                formattedNational = `${nationalNumber.slice(0, 5)}-${nationalNumber.slice(5)}`;
	            }
	            // US/Canada: 944-009-4018 (3-3-4 format)
	            else if ((parsed.country === 'US' || parsed.country === 'CA') && nationalNumber.length === 10) {
	                formattedNational = `${nationalNumber.slice(0, 3)}-${nationalNumber.slice(3, 6)}-${nationalNumber.slice(6)}`;
	            }
	            // UK: 20-7946-0018 (varies)
	            else if (parsed.country === 'GB') {
	                formattedNational = parsed.formatNational().replace(/^0/, '');
	            }
	            // Default: Use libphonenumber's national format without leading 0
	            else {
	                formattedNational = parsed.formatNational().replace(/^0/, '');
	            }
	            return `${countryCode} ${formattedNational}`;
	        }
	    }
	    catch (error) {
	        console.error('Error formatting phone number:', error);
	    }
	    // Fallback: return as is
	    return phoneNumber;
	};
	const getPhoneNumberWithoutCountryCode = (phoneNumber) => {
	    if (!phoneNumber)
	        return "";
	    try {
	        const parsed = parsePhoneNumber(phoneNumber);
	        if (parsed) {
	            return parsed.nationalNumber.toString();
	        }
	    }
	    catch (error) {
	        console.error('Error parsing phone number:', error);
	    }
	    // Fallback: remove + and country code manually
	    return phoneNumber.replace(/^\+\d{1,3}/, '');
	};
	const handleFileOpen = async (url, filename) => {
	    // Privacy: avoid logging potentially sensitive URLs/filenames
	    if (!url)
	        return;
	    try {
	        window.open(url, '_blank');
	    }
	    catch (_a) {
	        // swallow error to avoid leaking details
	    }
	};

	const AuthContext = reactExports.createContext(undefined);
	function AuthProvider({ children, apiBaseUrl }) {
	    const [user, setUser] = reactExports.useState(null);
	    const [token, setToken] = reactExports.useState(null);
	    const [isLoading, setIsLoading] = reactExports.useState(false);
	    const [error, setError] = reactExports.useState(null);
	    const clearError = reactExports.useCallback(() => {
	        setError(null);
	    }, []);
	    const requestOTP = reactExports.useCallback(async (phone) => {
	        setIsLoading(true);
	        setError(null);
	        try {
	            const phoneWithoutCode = getPhoneNumberWithoutCountryCode(phone);
	            const baseUrl = (apiBaseUrl === null || apiBaseUrl === void 0 ? void 0 : apiBaseUrl.replace(/\/$/, "")) || "";
	            const url = `${baseUrl}/api/auth/request/otp/${encodeURIComponent(phoneWithoutCode)}`;
	            const res = await fetch(url, {
	                method: "GET",
	                headers: {
	                    "Content-Type": "application/json",
	                },
	            });
	            if (!res.ok) {
	                let message = "Failed to send OTP";
	                try {
	                    const data = await res.json();
	                    message = (data === null || data === void 0 ? void 0 : data.message) || message;
	                }
	                catch (_a) { }
	                setError(message);
	                return false;
	            }
	            return true;
	        }
	        catch (err) {
	            setError((err === null || err === void 0 ? void 0 : err.message) || "Network error. Please try again.");
	            return false;
	        }
	        finally {
	            setIsLoading(false);
	        }
	    }, [apiBaseUrl]);
	    const validateOTP = reactExports.useCallback(async (phone, otp) => {
	        setIsLoading(true);
	        setError(null);
	        try {
	            const phoneWithoutCode = getPhoneNumberWithoutCountryCode(phone);
	            const baseUrl = (apiBaseUrl === null || apiBaseUrl === void 0 ? void 0 : apiBaseUrl.replace(/\/$/, "")) || "";
	            const url = `${baseUrl}/api/validate/phone/${encodeURIComponent(phoneWithoutCode)}/otp/${encodeURIComponent(otp)}`;
	            const res = await fetch(url, {
	                method: "GET",
	                headers: {
	                    "Content-Type": "application/json",
	                },
	            });
	            const contentType = res.headers.get("content-type");
	            const data = (contentType === null || contentType === void 0 ? void 0 : contentType.includes("application/json")) ? await res.json() : { success: false, message: await res.text() };
	            if (!res.ok || !(data === null || data === void 0 ? void 0 : data.token)) {
	                setError((data === null || data === void 0 ? void 0 : data.message) || "Invalid OTP. Please try again.");
	                return false;
	            }
	            setUser(data.user);
	            setToken(data.token);
	            if (typeof window !== "undefined") {
	                localStorage.setItem("authToken", data.token);
	                localStorage.setItem("user", JSON.stringify(data.user));
	            }
	            return true;
	        }
	        catch (err) {
	            setError((err === null || err === void 0 ? void 0 : err.message) || "Verification failed. Please try again.");
	            return false;
	        }
	        finally {
	            setIsLoading(false);
	        }
	    }, [apiBaseUrl]);
	    const logout = reactExports.useCallback(() => {
	        setUser(null);
	        setToken(null);
	        setError(null);
	        if (typeof window !== "undefined") {
	            localStorage.removeItem("authToken");
	            localStorage.removeItem("user");
	        }
	    }, []);
	    const value = {
	        user,
	        token,
	        isAuthenticated: !!token,
	        isLoading,
	        error,
	        requestOTP,
	        validateOTP,
	        logout,
	        clearError,
	    };
	    return jsxRuntimeExports.jsx(AuthContext.Provider, { value: value, children: children });
	}
	function useAuth() {
	    const context = reactExports.useContext(AuthContext);
	    if (!context) {
	        throw new Error("useAuth must be used within AuthProvider");
	    }
	    return context;
	}

	const ItineraryContext = reactExports.createContext(undefined);
	function ItineraryProvider({ children, apiBaseUrl }) {
	    const { token, user } = useAuth();
	    const [isLoading, setIsLoading] = reactExports.useState(false);
	    const [error, setError] = reactExports.useState(null);
	    const [pdfInfo, setPdfInfo] = reactExports.useState(null);
	    const [itineraryJson, setItineraryJson] = reactExports.useState(null);
	    const clearError = reactExports.useCallback(() => {
	        setError(null);
	    }, []);
	    const clearState = reactExports.useCallback(() => {
	        setPdfInfo(null);
	        setItineraryJson(null);
	        setError(null);
	        setIsLoading(false);
	    }, []);
	    const generatePdfFromJson = reactExports.useCallback(async (itineraryJsonData, meta) => {
	        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
	        // Validate auth
	        if (!token || !(user === null || user === void 0 ? void 0 : user.id)) {
	            console.log("[PDF Generation] Auth validation failed");
	            setError("Authentication required. Please verify your phone number first.");
	            return false;
	        }
	        // Start PDF generation
	        // Clear error on new attempt
	        setError(null);
	        setIsLoading(true);
	        // Format metadata for PDF generation
	        const totalAdults = meta.rooms.reduce((sum, room) => sum + (room.adults || 0), 0);
	        const totalChildren = meta.rooms.reduce((sum, room) => sum + (room.children || 0), 0);
	        // Extract date in YYYY-MM-DD format from ISO string
	        const formatDateToYYYYMMDD = (isoDate) => {
	            if (isoDate instanceof Date) {
	                return isoDate.toISOString().split('T')[0];
	            }
	            return String(isoDate).split('T')[0];
	        };
	        const pdfMeta = {
	            customerName: meta.contact.name || "",
	            customerPhone: meta.contact.phone,
	            customerEmail: meta.contact.email || "",
	            departureCity: meta.city,
	            departureDate: formatDateToYYYYMMDD(meta.dates.start),
	            returnDate: formatDateToYYYYMMDD(meta.dates.end),
	            numberOfAdults: totalAdults,
	            numberOfChildren: totalChildren,
	            rooms: meta.rooms.length,
	            currency: "INR",
	            flightsIncluded: ((_a = meta.extras) === null || _a === void 0 ? void 0 : _a.includeFlights) || false,
	            visaIncluded: ((_b = meta.extras) === null || _b === void 0 ? void 0 : _b.visaAssistance) || false,
	        };
	        // Step 2: Render PDF from itinerary JSON + meta (with retry logic)
	        const maxRetries = 2;
	        let lastError = null;
	        for (let attempt = 0; attempt <= maxRetries; attempt++) {
	            try {
	                // Attempt with exponential backoff retry logic
	                // Prefer server action for SSR boundary
	                // const { generatePdfFromJsonAction } = await import("../actions"); // REMOVE
	                const baseUrl = (apiBaseUrl === null || apiBaseUrl === void 0 ? void 0 : apiBaseUrl.replace(/\/$/, "")) || "";
	                const url = `${baseUrl}/api/itineraries/generate-json-pdf`;
	                const actionRes = await fetch(url, {
	                    method: "POST",
	                    headers: {
	                        "Content-Type": "application/json",
	                        Authorization: `Bearer ${token}`,
	                        "x-user-id": user.id,
	                        "x-ssr": "1",
	                    },
	                    body: JSON.stringify({ itinerary: itineraryJsonData, meta: pdfMeta }),
	                    cache: "no-store",
	                });
	                if (!actionRes.ok) {
	                    let message = "Failed to generate PDF";
	                    try {
	                        const data = await actionRes.json();
	                        message = (data === null || data === void 0 ? void 0 : data.message) || message;
	                    }
	                    catch (_k) { }
	                    throw new Error(message || "Failed to generate PDF. Please try again.");
	                }
	                const contentType = actionRes.headers.get("content-type");
	                const data = (contentType === null || contentType === void 0 ? void 0 : contentType.includes("application/json")) ? await actionRes.json() : await actionRes.text();
	                const payload = (typeof data === "object" && (data === null || data === void 0 ? void 0 : data.data)) ? data.data : data;
	                // Handle successful response
	                const pdfData = payload !== null && payload !== void 0 ? payload : {};
	                // Normalize different response shapes
	                const pdfResult = (_c = pdfData === null || pdfData === void 0 ? void 0 : pdfData.data) !== null && _c !== void 0 ? _c : pdfData;
	                // Handle different possible response structures
	                let nextPdfInfo = null;
	                if (pdfResult && typeof pdfResult === "object") {
	                    // Check if it has url and filename directly
	                    if (pdfResult.url && pdfResult.filename) {
	                        nextPdfInfo = {
	                            url: pdfResult.url,
	                            filename: pdfResult.filename,
	                        };
	                    }
	                    // Check if it's nested under different keys
	                    else if (pdfResult.pdfUrl || pdfResult.downloadUrl || pdfResult.link) {
	                        nextPdfInfo = {
	                            url: pdfResult.pdfUrl || pdfResult.downloadUrl || pdfResult.link,
	                            filename: pdfResult.filename || pdfResult.fileName || pdfResult.name || "itinerary.pdf",
	                        };
	                    }
	                    // Check if it's an array or has other structure
	                    else if (Array.isArray(pdfResult) && pdfResult.length > 0) {
	                        const firstItem = pdfResult[0];
	                        if (firstItem.url || firstItem.pdfUrl || firstItem.downloadUrl) {
	                            nextPdfInfo = {
	                                url: firstItem.url || firstItem.pdfUrl || firstItem.downloadUrl,
	                                filename: firstItem.filename || firstItem.fileName || firstItem.name || "itinerary.pdf",
	                            };
	                        }
	                    }
	                    // Check for any URL-like field
	                    else {
	                        const urlKeys = Object.keys(pdfResult).filter(key => key.toLowerCase().includes("url") || key.toLowerCase().includes("link"));
	                        if (urlKeys.length > 0) {
	                            const urlKey = urlKeys[0];
	                            nextPdfInfo = {
	                                url: pdfResult[urlKey],
	                                filename: pdfResult.filename || pdfResult.fileName || pdfResult.name || "itinerary.pdf",
	                            };
	                        }
	                    }
	                }
	                if (nextPdfInfo && nextPdfInfo.url) {
	                    // Store PDF info for download
	                    setPdfInfo(nextPdfInfo);
	                    setIsLoading(false);
	                    return true; // Success - exit function
	                }
	                else {
	                    throw new Error("Could not complete PDF generation. Please try again.");
	                }
	            }
	            catch (err) {
	                lastError = err;
	                // Capture error message for retry decision
	                // Determine if we should retry
	                const isNetworkError = !(err === null || err === void 0 ? void 0 : err.response) || ((_d = err.message) === null || _d === void 0 ? void 0 : _d.includes("fetch")) || err.message === "Network Error";
	                const isServerError = ((_e = err === null || err === void 0 ? void 0 : err.response) === null || _e === void 0 ? void 0 : _e.status) >= 500;
	                const shouldRetry = isNetworkError || isServerError;
	                if (attempt < maxRetries && shouldRetry) {
	                    // Wait before retrying (exponential backoff: 1s, 2s)
	                    const waitTime = 1000 * (attempt + 1);
	                    await new Promise((resolve) => setTimeout(resolve, waitTime));
	                    continue;
	                }
	                break;
	            }
	        }
	        // All retries failed - set user-friendly error message
	        const statusCode = (_g = (_f = lastError === null || lastError === void 0 ? void 0 : lastError.response) === null || _f === void 0 ? void 0 : _f.status) !== null && _g !== void 0 ? _g : lastError === null || lastError === void 0 ? void 0 : lastError.status;
	        const rawError = String((_j = (_h = lastError === null || lastError === void 0 ? void 0 : lastError.message) !== null && _h !== void 0 ? _h : lastError) !== null && _j !== void 0 ? _j : "Unknown error").toLowerCase();
	        let userFriendlyError = "";
	        if (statusCode === 401) {
	            userFriendlyError = "Authentication expired. Please verify your phone number again.";
	        }
	        else if (statusCode >= 500 && statusCode < 600) {
	            userFriendlyError = "Server is temporarily unavailable. We've retried 3 times. Please try again in a moment.";
	        }
	        else if (rawError.includes("network") || rawError.includes("fetch") || rawError.includes("failed to fetch")) {
	            userFriendlyError = "Network connection issue. Please check your internet and try again.";
	        }
	        else if (rawError.includes("timeout")) {
	            userFriendlyError = "Request took too long. Please try again.";
	        }
	        else {
	            userFriendlyError = "Something went wrong while generating your PDF. Please try again.";
	        }
	        setError(userFriendlyError);
	        setIsLoading(false);
	        return false;
	    }, [token, user, apiBaseUrl]);
	    const retryPdfGeneration = reactExports.useCallback(async (meta) => {
	        if (!itineraryJson) {
	            setError("No itinerary data available. Please start over.");
	            return false;
	        }
	        return await generatePdfFromJson(itineraryJson, meta);
	    }, [itineraryJson, generatePdfFromJson]);
	    const generateItinerary = reactExports.useCallback(async (query, meta) => {
	        var _a;
	        // Validate auth
	        if (!token || !(user === null || user === void 0 ? void 0 : user.id)) {
	            setError("Authentication required. Please verify your phone number first.");
	            return false;
	        }
	        // Clear error on new attempt, keep PDF info if retrying
	        setError(null);
	        setIsLoading(true);
	        // Step 1: Generate itinerary JSON from query via server action
	        let itineraryJsonData;
	        try {
	            // const { generateItineraryAction } = await import("../actions"); // REMOVE
	            const baseUrl = (apiBaseUrl === null || apiBaseUrl === void 0 ? void 0 : apiBaseUrl.replace(/\/$/, "")) || "";
	            const url = `${baseUrl}/api/itineraries/generate-json`;
	            const actionRes = await fetch(url, {
	                method: "POST",
	                headers: {
	                    "Content-Type": "application/json",
	                    Authorization: `Bearer ${token}`,
	                    "x-user-id": user.id,
	                    "x-ssr": "1",
	                },
	                body: JSON.stringify({ query }),
	                cache: "no-store",
	            });
	            if (!actionRes.ok) {
	                let message = "Failed to generate itinerary";
	                try {
	                    const data = await actionRes.json();
	                    message = (data === null || data === void 0 ? void 0 : data.message) || message;
	                }
	                catch (_b) { }
	                throw new Error(message || "Failed to generate itinerary. Please try again.");
	            }
	            // Support both {data: ...} and raw JSON payloads
	            const data = await actionRes.json().catch(() => ({}));
	            const payload = (_a = data === null || data === void 0 ? void 0 : data.data) !== null && _a !== void 0 ? _a : data;
	            itineraryJsonData = payload;
	            if (!itineraryJsonData) {
	                throw new Error("Could not generate itinerary. Please try again or contact support.");
	            }
	            setItineraryJson(itineraryJsonData);
	        }
	        catch (err) {
	            const message = (err === null || err === void 0 ? void 0 : err.message) || "Failed to generate itinerary. Please try again.";
	            setError(message);
	            setIsLoading(false);
	            return false;
	        }
	        // Step 2: Render PDF from itinerary JSON + meta
	        return await generatePdfFromJson(itineraryJsonData, meta);
	    }, [token, user, generatePdfFromJson, apiBaseUrl]);
	    const value = {
	        isLoading,
	        error,
	        pdfInfo,
	        itineraryJson,
	        generateItinerary,
	        retryPdfGeneration,
	        clearState,
	        clearError,
	    };
	    return jsxRuntimeExports.jsx(ItineraryContext.Provider, { value: value, children: children });
	}
	function useItinerary() {
	    const context = reactExports.useContext(ItineraryContext);
	    if (!context) {
	        throw new Error("useItinerary must be used within ItineraryProvider");
	    }
	    return context;
	}

	function ImageCover() {
	    return (jsxRuntimeExports.jsx("div", { className: "hidden sm:block w-80 bg-[#072433] text-white flex-shrink-0", children: jsxRuntimeExports.jsx("img", { src: "https://intellora.s3.ap-south-1.amazonaws.com/image/f60e0759-294b-40e2-845d-260dc01528ee-1113bf5f95e1401db1eab0a4b05bdbef.png", alt: "Promotional", loading: "lazy", className: "h-full w-full object-cover" }) }));
	}

	const uniqueArray = [
	    "Dubai",
	    "Singapore",
	    "Thailand",
	    "Bali",
	    "Indonesia",
	    "Malaysia",
	    "Maldives",
	    "Sri Lanka",
	    "Nepal",
	    "Bhutan",
	    "Switzerland",
	    "Asia",
	    "Japan",
	    "Tokyo",
	    "Taiwan",
	    "South Korea",
	    "China",
	    "India",
	    "Vietnam",
	    "Thailand",
	    "Singapore",
	    "Pakistan",
	    "Bangladesh",
	    "Sri Lanka",
	    "Mongolia",
	    "Cambodia",
	    "Philippines",
	    "Europe",
	    "United Kingdom",
	    "England",
	    "Scotland",
	    "Wales",
	    "Northern Ireland",
	    "France",
	    "Germany",
	    "Italy",
	    "Spain",
	    "Netherlands",
	    "Belgium",
	    "Austria",
	    "Sweden",
	    "Norway",
	    "Finland",
	    "Denmark",
	    "Poland",
	    "Czech Republic",
	    "Hungary",
	    "Portugal",
	    "Ireland",
	    "Switzerland",
	    "Russia",
	    "Greece",
	    "Turkey",
	    "Croatia",
	    "Romania",
	    "Slovakia",
	    "Bulgaria",
	    "Lithuania",
	    "Latvia",
	    "Estonia",
	    "Slovenia",
	    "Serbia",
	    "Bosnia and Herzegovina",
	    "Macedonia",
	    "Belarus",
	    "Ukraine",
	    "Moldova",
	    "Iceland",
	    "Luxembourg",
	    "North America",
	    "United States of america",
	    "California",
	    "Texas",
	    "New York",
	    "Florida",
	    "Illinois",
	    "Washington",
	    "Colorado",
	    "Nevada",
	    "Georgia",
	    "Ohio",
	    "Pennsylvania",
	    "Minnesota",
	    "North Carolina",
	    "Oregon",
	    "Arizona",
	    "Kentucky",
	    "South Carolina",
	    "New Mexico",
	    "Virginia",
	    "Wisconsin",
	    "Iowa",
	    "Michigan",
	    "Alaska",
	    "Utah",
	    "Missouri",
	    "Alabama",
	    "Montana",
	    "Idaho",
	    "Connecticut",
	    "Rhode Island",
	    "Maine",
	    "New Hampshire",
	    "North Dakota",
	    "Wyoming",
	    "Nebraska",
	    "Massachusetts",
	    "Canada",
	    "Ontario",
	    "Quebec",
	    "British Columbia",
	    "Alberta",
	    "Manitoba",
	    "New Brunswick",
	    "Nova Scotia",
	    "Mexico",
	    "Guatemala",
	    "El Salvador",
	    "Costa Rica",
	    "Panama",
	    "South America",
	    "Brazil",
	    "Argentina",
	    "Colombia",
	    "Peru",
	    "Chile",
	    "Ecuador",
	    "Uruguay",
	    "Bolivia",
	    "Africa",
	    "South Africa",
	    "Kenya",
	    "Morocco",
	    "Egypt",
	    "Tunisia",
	    "Mauritius",
	    "Nigeria",
	    "Senegal",
	    "Angola",
	    "Democratic Republic of the Congo",
	    "Tanzania",
	    "Cameroon",
	    "Algeria",
	    "Mozambique",
	    "Sudan",
	    "Middle East",
	    "United Arab Emirates",
	    "Israel",
	    "Saudi Arabia",
	    "Qatar",
	    "Oman",
	    "Jordan",
	    "Lebanon",
	    "Kuwait",
	    "Australia",
	    "New South Wales",
	    "Victoria",
	    "Queensland",
	    "Western Australia",
	    "Tasmania",
	    "Australian Capital Territory",
	    "Northern Territory",
	    "Auckland",
	    "Wellington",
	    // Cities - examples from the data (repeat for up to 500)
	    "Tokyo",
	    "Boston",
	    "New York",
	    "Sydney",
	    "Singapore",
	    "Dallas-Fort Worth",
	    "Seoul",
	    "Houston",
	    "Chicago",
	    "Paris",
	    "London",
	    "San Francisco - San Jose",
	    "Atlanta",
	    "Seattle",
	    "Shanghai",
	    "Stockholm",
	    "Miami",
	    "Washington DC",
	    "Beijing",
	    "Los Angeles",
	    "Austin",
	    "Vienna",
	    "Taipei",
	    "Amsterdam",
	    "Oslo",
	    "Shenzhen",
	    "Las Vegas",
	    "Denver",
	    "Dubai",
	    "Osaka",
	    "Berlin",
	    "Istanbul",
	    "Melbourne",
	    "Moscow",
	    "Philadelphia",
	    "Portland",
	    "Minneapolis-St Paul",
	    "Nashville",
	    "Munich",
	    "Madrid",
	    "Helsinki",
	    "Brisbane",
	    "Toronto",
	    "Phoenix",
	    "San Diego",
	    "Charlotte",
	    "Kansas City",
	    "San Antonio",
	    "Hong Kong",
	    "Detroit",
	    "Guangzhou",
	    "Barcelona",
	    "Montreal",
	    "Copenhagen",
	    "Baltimore",
	    "Boulder",
	    "Fort Lauderdale",
	    "Des Moines",
	    "Lexington",
	    "Charleston",
	    "Springfield",
	    "Orlando",
	    "Milan",
	    "Kyoto",
	    "Oakland",
	    "Pittsburgh",
	    "Salt Lake City",
	    "St Louis",
	    "Indianapolis",
	    "Zurich",
	    "Albuquerque",
	    "Providence",
	    "Oklahoma City",
	    "Perth",
	    "Newark",
	    "Nagoya",
	    "Savannah",
	    "Richmond",
	    "Tulsa",
	    "Honolulu",
	    "Louisville",
	    "Little Rock",
	    "Santa Ana-Anaheim",
	    "Augusta",
	    "Canberra",
	    "Omaha",
	    "Norfolk-Virginia Beach",
	    "Chattanooga",
	    "Anchorage",
	    "Hamburg",
	    "Tel Aviv",
	    "Dublin",
	    "Rome",
	    "Rotterdam",
	    "Abu Dhabi",
	    "Busan",
	    "Budapest",
	    "Wellington",
	    "Tallahassee",
	    "Adelaide",
	    "Milwaukee",
	    "Jacksonville",
	    "New Orleans",
	    "Rio De Janeiro",
	    "Fukuoka",
	    "Cleveland",
	    "Gothenburg",
	    "Birmingham",
	    "Tucson",
	    "Greensboro",
	    "Columbia",
	    "Tallinn",
	    "Cincinnati",
	    "Knoxville",
	    "Yokohama",
	    "Montgomery",
	    "Jackson",
	    "Winston-Salem",
	    "St Petersburg",
	    "Christchurch",
	    "Warsaw",
	    "Frankfurt",
	    "Prague",
	    "Brussels",
	    "Raleigh-Durham",
	    "Malm",
	    "Boise",
	    "Stuttgart",
	    "Sapporo",
	    "The Hague",
	    "Ulsan",
	    "So Paulo",
	    "Memphis",
	    "Vancouver",
	    "Baton Rouge",
	    "Columbus",
	    "Ann Arbor",
	    "Colorado Springs",
	    "Corpus Christi",
	    "Dayton",
	    "Grand Rapids",
	    "Tampa",
	    "Wichita",
	    "Toledo",
	    "Akron",
	    "Madison",
	    "Reno",
	    "Sacramento",
	    "Ningbo",
	    "Lincoln",
	    "El Paso",
	    "Bozeman",
	    "Riverside",
	    "Dsseldorf",
	    "Reykjavik",
	    "Lisbon",
	    "Auckland",
	    "Gold Coast",
	    "Mexico City",
	    "Daegu",
	    "Buffalo",
	    "Basel",
	    "Albany",
	    "Allentown",
	    "Luxembourg",
	    "Incheon",
	    "Rochester",
	    "Manchester",
	    "Buenos Aires",
	    "Bangkok",
	    "Spokane",
	    "Daejeon",
	    "Green Bay",
	    "Chongqing",
	    "Tianjin",
	    "Suzhou",
	    "Hiroshima",
	    "Greenville",
	    "Ankara",
	    "Nanjing",
	    "Chengdu",
	    "Springfield",
	    "Charlottesville",
	    "Kaohsiung",
	    "Fargo",
	    "Hangzhou",
	    "Izmir",
	    "Tainan",
	    "Sioux Falls",
	    "Roanoke",
	    "Xiamen",
	    "Rochester",
	    "Wuxi",
	    "Nagasaki",
	    "Qubec",
	    "Valencia",
	    "Geneva",
	    "Manchester",
	    "Bucharest",
	    "Kawasaki",
	    "Salzburg",
	    "Ottawa",
	    "Leipzig",
	    "Santiago",
	    "Wilmington",
	    "Cairo",
	    "Eindhoven",
	    "Kagoshima",
	    "Fuji",
	    "Newcastle",
	    "Utrecht",
	    "Xi'an",
	    "Bern",
	    "Hartford",
	    "Wenzhou",
	    "Syracuse",
	    "Fuzhou",
	    "Ventura-Oxnard",
	    "Oporto",
	    "Calgary",
	    "Kuala Lumpur",
	    "Athens",
	    "Riga",
	    "Edinburgh",
	    "Lyon",
	    "Hannover",
	    "Dongguan",
	    "Wrocaw",
	    "Birmingham",
	    "Bremen",
	    "Wollongong",
	    "Essen",
	    "Suwon",
	    "Cologne",
	    "Taichung",
	    "Duisburg",
	    "Ho Chi Minh City",
	    "Karlsruhe",
	    "Sharjah",
	    "Nanning",
	    "Burlington",
	    "Nantong",
	    "Taiyuan",
	    "Lancaster",
	    "Quanzhou",
	    "Dalian",
	    "Bridgeport",
	    "Qingdao",
	    "Brasilia",
	    "Shenyang",
	    "Florence",
	    "Hobart",
	    "Bilbao",
	    "Napoli (Naples)",
	    "Glasgow",
	    "Belfast",
	    "Dortmund",
	    "Queenstown",
	    "Mumbai",
	    "Graz",
	    "Antwerp",
	    "Liverpool",
	    "Jakarta",
	    "Krakw",
	    "Nottingham",
	    "Kiel",
	    "Bristol",
	    "Sheffield",
	    "Hamilton",
	    "Alexandria",
	    "Billings",
	    "Gdansk",
	    "Bonn",
	    "Hanoi",
	    "Newcastle-upon-Tyne",
	    "Katowice",
	    "Yangzhou",
	    "Belo Horizonte",
	    "Nanchang",
	    "Springfield",
	    "Kunming",
	    "Fresno",
	    "Harbin",
	    "Bakersfield",
	    "Macau",
	    "Zhongshan",
	    "Cheyenne",
	    "Foshan",
	    "Edmonton",
	    "Dresden",
	    "Bogot",
	    "Bangalore",
	    "Seville",
	    "Nuremberg",
	    "Moncton",
	    "Gijn",
	    "Ljubljana",
	    "Mannheim-Heidelberg",
	    "Mlaga",
	    "Pamplona",
	    "Curitiba",
	    "Bursa",
	    "Winnipeg",
	    "Bochum",
	    "Porto Alegre",
	    "Nice",
	    "Aachen",
	    "Sofia",
	    "Nantes",
	    "Leeds",
	    "Marseille",
	    "Cardiff",
	    "Linz",
	    "London (Canada)",
	    "Wuppertal",
	    "Odense",
	    "Manila",
	    "Salvador",
	    "Lucerne",
	    "Geelong",
	    "Fredericton - St John",
	    "Zhuhai",
	    "Modesto",
	    "Changchun",
	    "Hefei",
	    "Jinan",
	    "Stockton",
	    "Yantai-Weihai",
	    "Zhengzhou",
	    "Belgrade",
	    "Medellin",
	    "Cape Town",
	    "Vilnius",
	    "Timisoara",
	    "Toulouse",
	    "Bratislava",
	    "Adana",
	    "Venice",
	    "Torino",
	    "Bordeaux",
	    "Antalya",
	    "Delhi",
	    "Gent",
	    "Padova",
	    "Karachi",
	    "Guatemala City",
	    "Colombo",
	    "Recife",
	    "Kuwait City",
	    "Southampton",
	    "Kitchener",
	    "Lille",
	    "Coventry",
	    "Granada",
	    "Shantou",
	    "Wuhan",
	    "Kiev",
	    "Grenoble",
	    "Modena",
	    "Strasbourg",
	    "Lige",
	    "Rennes",
	    "Verona",
	    "Kazan",
	    "Bath & NE Somerset",
	    "Halifax",
	    "Riyadh",
	    "Trieste",
	    "Haifa",
	    "Johannesburg",
	    "Monterrey",
	    "Kingston-Upon-Hull",
	    "Brno",
	    "Le Havre",
	    "Tbilisi",
	    "Ulaanbaatar",
	    "Al-Ain",
	    "Guadalajara",
	    "Fortaleza",
	    "Zagreb",
	    "Thessaloniki",
	    "Montpellier",
	    "Yekaterinburg",
	    "Kosice",
	    "Jerusalem",
	    "Bologna",
	    "Dijon",
	    "Chennai",
	    "Lima",
	    "Parma",
	    "Ballarat",
	    "Reims",
	    "Hyderabad",
	    "Rouen",
	    "San Jose, Costa Rica",
	    "Bendigo",
	    "Saint-tienne",
	    "Leuven",
	    "Volgograd",
	    "Jeddah",
	    "Lahore",
	    "Kaliningrad",
	    "Minsk",
	    "Novosibirsk",
	    "Yangon",
	    "Phnom Penh",
	    "Doha",
	    "Chisinau",
	    "Dubrovnik",
	    "Montevideo",
	    "Almaty",
	    "Nairobi",
	    "Muscat",
	    "San Salvador",
	    "Limoges",
	    "Ajman",
	    "Skopje",
	    "Quito",
	    "Samara",
	    "Sarajevo",
	    "Nizhny Novgorod",
	    "Amman",
	    "Rostov-na-Donu",
	    "Valparaso",
	    "Santo Domingo",
	    "Vladivostok",
	    "Metz",
	    "Cordoba",
	    "Kolkata",
	    "Guimaraes",
	    "Manama",
	    "Ahmedabad",
	    "Santa Cruz de Tenerife",
	    "Pune",
	    "Krasnoyarsk",
	    "Dar es Salaam",
	    "Omsk",
	    "Caracas",
	    "Cannes",
	    "Astana",
	    "Durban",
	    "Kingston",
	    "Tehran",
	    "Guayaquil",
	    "Casablanca",
	    "Saratov",
	    "Dhaka",
	    "Perm",
	    "Puebla",
	    "Tomsk",
	    "Panama City",
	    "Orenburg",
	    "Izhevsk",
	    "Chittagong",
	    "Baku",
	    "Beirut",
	    "Havana",
	    "Bishkek",
	    "Pretoria",
	    "Odessa",
	    "Cali",
	    "Tirana",
	    "Tolyatti",
	    "Tunis",
	    "Petaling Jaya",
	    "Lagos",
	    "Barnaul",
	    "Port Louis",
	    "San Juan",
	    "Port of Spain",
	    "Jaipur",
	    "Kharkov",
	    "Surat",
	    "Rabat",
	    "Tegucigalpa",
	    "Bandung",
	    "Algiers",
	    "Lviv",
	    "Addis Ababa",
	    "Nassau",
	    "Asuncion",
	    "Dushanbe",
	    "Cartagena",
	    "Sevastopol",
	    "Lucknow",
	    "Dnepropetrovsk",
	    "Port Harcourt",
	    "Luanda",
	    "Kinshasa",
	    "Dakar",
	    "Simferopol",
	    "Donetsk",
	    "Kanpur",
	    "Zaporozhye",
	    "Douala",
	    "Madurai",
	    "La Paz",
	    "Khartoum",
	];
	const popularDestinations = [...new Set(uniqueArray)];
	const CITIES = [
	    // Metro & Major International Airports
	    "Agartala, IXA",
	    "Ahmedabad, AMD",
	    "Amritsar, ATQ",
	    "Bengaluru, BLR",
	    "Bhopal, BHO",
	    "Bhubaneswar, BBI",
	    "Chandigarh, IXC",
	    "Chennai, MAA",
	    "Coimbatore, CJB",
	    "Delhi, DEL",
	    "Goa (Dabolim), GOI",
	    "Goa (Mopa), GOX",
	    "Guwahati, GAU",
	    "Hyderabad, HYD",
	    "Indore, IDR",
	    "Jaipur, JAI",
	    "Kochi, COK",
	    "Kolkata, CCU",
	    "Lucknow, LKO",
	    "Mumbai, BOM",
	    "Nagpur, NAG",
	    "Patna, PAT",
	    "Pune, PNQ",
	    "Raipur, RPR",
	    "Ranchi, IXR",
	    "Srinagar, SXR",
	    "Surat, STV",
	    "Thiruvananthapuram, TRV",
	    "Tiruchirappalli, TRZ",
	    "Udaipur, UDR",
	    "Varanasi, VNS",
	    "Vijayawada, VGA",
	    "Visakhapatnam, VTZ",
	    // Andhra Pradesh
	    "Kadapa, CDP",
	    "Kurnool, KJB",
	    "Rajahmundry, RJA",
	    "Tirupati, TIR",
	    // Arunachal Pradesh
	    "Itanagar, HGI",
	    "Pasighat, IXT",
	    // Assam
	    "Dibrugarh, DIB",
	    "Jorhat, JRH",
	    "Silchar, IXS",
	    "Tezpur, TEZ",
	    // Bihar
	    "Darbhanga, DBR",
	    "Gaya, GAY",
	    // Chhattisgarh
	    "Bilaspur, PAB",
	    "Jagdalpur, JGB",
	    // Gujarat
	    "Bhavnagar, BHU",
	    "Bhuj, BHJ",
	    "Jamnagar, JGA",
	    "Junagadh, JND",
	    "Kandla, IXY",
	    "Porbandar, PBD",
	    "Rajkot, RAJ",
	    "Vadodara, BDQ",
	    // Haryana
	    "Hisar, HSS",
	    // Himachal Pradesh
	    "Dharamshala, DHM",
	    "Kullu, KUU",
	    "Shimla, SLV",
	    // Jammu & Kashmir / Ladakh
	    "Jammu, IXJ",
	    "Leh, IXL",
	    // Jharkhand
	    "Deoghar, DGH",
	    // Karnataka
	    "Belagavi, IXG",
	    "Ballari, BEP",
	    "Hubballi, HBX",
	    "Kalaburagi, GBI",
	    "Mangaluru, IXE",
	    "Mysuru, MYQ",
	    "Shivamogga, RQY",
	    // Kerala
	    "Kannur, CNN",
	    "Kozhikode, CCJ",
	    // Madhya Pradesh
	    "Gwalior, GWL",
	    "Jabalpur, JLR",
	    "Khajuraho, HJR",
	    // Maharashtra
	    "Akola, AKD",
	    "Aurangabad, IXU",
	    "Jalgaon, JLG",
	    "Kolhapur, KLH",
	    "Nanded, NDC",
	    "Nashik, ISK",
	    "Shirdi, SAG",
	    "Solapur, SSE",
	    // Manipur
	    "Imphal, IMF",
	    // Meghalaya
	    "Shillong, SHL",
	    // Mizoram
	    "Aizawl, AJL",
	    // Nagaland
	    "Dimapur, DMU",
	    // Odisha
	    "Jharsuguda, JRG",
	    "Rourkela, RRK",
	    // Punjab
	    "Bathinda, BUP",
	    "Ludhiana, LUH",
	    "Pathankot, IXP",
	    // Rajasthan
	    "Ajmer, KQH",
	    "Bikaner, BKB",
	    "Jaisalmer, JSA",
	    "Jodhpur, JDH",
	    "Kota, KTU",
	    // Sikkim
	    "Gangtok, PYG",
	    // Tamil Nadu
	    "Madurai, IXM",
	    "Salem, SXV",
	    "Thoothukudi, TCR",
	    // Telangana
	    "Warangal, WGC",
	    // Uttar Pradesh
	    "Ayodhya, AYJ",
	    "Bareilly, BEK",
	    "Gorakhpur, GOP",
	    "Jhansi, JHS",
	    "Kanpur, KNU",
	    "Prayagraj, IXD",
	    // Uttarakhand
	    "Dehradun, DED",
	    "Pantnagar, PGH",
	    // West Bengal
	    "Bagdogra, IXB",
	    "Cooch Behar, COO"
	];
	const WEEK_DAYS = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];

	function StepDestination({ citySearch, setCitySearch, setValue, watch, setStep, errors, }) {
	    const selectedDestinations = watch("destinations") || [];
	    const filteredCities = popularDestinations.filter((city) => city.toLowerCase().includes(citySearch.toLowerCase()) &&
	        !selectedDestinations.includes(city));
	    const addDestination = (city) => {
	        const isAlreadySelected = selectedDestinations.includes(city);
	        const newDestinations = isAlreadySelected ? [] : [city];
	        setValue("destinations", newDestinations, { shouldDirty: true, shouldTouch: true, shouldValidate: true });
	        setCitySearch("");
	    };
	    const removeDestination = (cityToRemove) => {
	        const newDestinations = selectedDestinations.filter(city => city !== cityToRemove);
	        setValue("destinations", newDestinations, { shouldDirty: true, shouldTouch: true, shouldValidate: true });
	    };
	    const handleContinue = () => {
	        if (selectedDestinations.length > 0) {
	            setStep(1);
	        }
	    };
	    return (jsxRuntimeExports.jsxs("div", { className: "h-full flex flex-col bg-gradient-to-b from-white to-slate-50", children: [jsxRuntimeExports.jsxs("div", { className: "flex-none p-4 border-b bg-white", children: [jsxRuntimeExports.jsxs("div", { className: "relative", children: [jsxRuntimeExports.jsx("input", { type: "text", className: "w-full h-12 pl-10 pr-4 rounded-full border-2 text-base border-[#6D28D9] text-gray-800 placeholder:text-gray-400 focus:border-[#6D28D9] focus:ring-4 focus:ring-[#6D28D9]/20 focus:outline-none transition-all duration-200 shadow-sm", placeholder: "Search destinations to add to your trip", value: citySearch, onChange: (e) => setCitySearch(e.target.value) }), jsxRuntimeExports.jsx("svg", { className: "absolute left-4 top-1/2 -translate-y-1/2 w-5 h-5 text-[#6D28D9]", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor", children: jsxRuntimeExports.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" }) })] }), selectedDestinations.length > 0 && (jsxRuntimeExports.jsx("div", { className: "mt-4", children: jsxRuntimeExports.jsx("div", { className: "flex gap-2 overflow-x-auto scrollbar-thin scrollbar-thumb-gray-300 scrollbar-track-transparent", style: { scrollBehavior: "smooth" }, children: selectedDestinations.map((destination) => (jsxRuntimeExports.jsxs("div", { className: "flex-shrink-0 inline-flex items-center gap-2 px-3 py-1 bg-[#6D28D9] text-white text-sm rounded-full", children: [jsxRuntimeExports.jsx("span", { children: destination }), jsxRuntimeExports.jsx("button", { onClick: () => removeDestination(destination), className: "hover:bg-white/20 rounded-full p-0.5 transition-colors", children: jsxRuntimeExports.jsx("svg", { className: "w-4 h-4", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor", children: jsxRuntimeExports.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M6 18L18 6M6 6l12 12" }) }) })] }, destination))) }) }))] }), jsxRuntimeExports.jsx("div", { className: "flex-1 overflow-y-auto p-4 min-h-0", children: jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-1 gap-2", children: [filteredCities.map((city) => (jsxRuntimeExports.jsx("button", { onClick: () => addDestination(city), className: "text-left px-5 py-4 rounded-lg hover:text-white hover:bg-gradient-to-r hover:from-[#6D28D9] hover:to-[#5B21B6] transition-all duration-200 text-base font-medium shadow-sm hover:shadow-md border border-transparent hover:border-[#6D28D9] bg-white", children: jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-3", children: [jsxRuntimeExports.jsxs("svg", { className: "w-5 h-5 opacity-70", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor", children: [jsxRuntimeExports.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M17.657 16.657L13.414 20.9a1.998 1.998 0 01-2.827 0l-4.244-4.243a8 8 0 1111.314 0z" }), jsxRuntimeExports.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M15 11a3 3 0 11-6 0 3 3 0 016 0z" })] }), city, jsxRuntimeExports.jsx("div", { className: "ml-auto", children: jsxRuntimeExports.jsx("svg", { className: "w-5 h-5 opacity-50", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor", children: jsxRuntimeExports.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M12 6v6m0 0v6m0-6h6m-6 0H6" }) }) })] }) }, city))), filteredCities.length === 0 && citySearch && (jsxRuntimeExports.jsxs("div", { className: "text-center py-12 text-slate-500 text-base", children: [jsxRuntimeExports.jsx("div", { className: "text-4xl mb-3", children: "\uD83D\uDE15" }), jsxRuntimeExports.jsx("div", { className: "font-medium", children: "No destinations found" }), jsxRuntimeExports.jsx("div", { className: "text-sm mt-2 text-slate-400", children: "Try searching for a different destination" })] }))] }) }), selectedDestinations.length > 0 && (jsxRuntimeExports.jsx("div", { className: "flex-none p-4 border-t bg-white", children: jsxRuntimeExports.jsx("button", { onClick: handleContinue, className: "w-full bg-gradient-to-r from-[#6D28D9] to-[#5B21B6] text-white py-3 px-6 rounded-lg font-medium text-base shadow-md hover:shadow-lg transition-all duration-200 hover:scale-[1.02]", children: "Continue" }) }))] }));
	}

	function Step0City({ citySearch, setCitySearch, setValue, setStep, errors, }) {
	    const filteredCities = CITIES.filter((city) => city.toLowerCase().includes(citySearch.toLowerCase()));
	    return (jsxRuntimeExports.jsxs("div", { className: "h-full flex flex-col bg-gradient-to-b from-white to-slate-50", children: [jsxRuntimeExports.jsx("div", { className: "flex-none p-4 border-b bg-white", children: jsxRuntimeExports.jsxs("div", { className: "relative", children: [jsxRuntimeExports.jsx("input", { type: "text", className: "w-full h-12 pl-10 pr-4 rounded-full border-2 text-base border-[#6D28D9] text-gray-800 placeholder:text-gray-400 focus:border-[#6D28D9] focus:ring-4 focus:ring-[#6D28D9]/20 focus:outline-none transition-all duration-200 shadow-sm", placeholder: "Search from over 3000 cities", value: citySearch, onChange: (e) => setCitySearch(e.target.value) }), jsxRuntimeExports.jsx("svg", { className: "absolute left-4 top-1/2 -translate-y-1/2 w-5 h-5 text-[#6D28D9]", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor", children: jsxRuntimeExports.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" }) })] }) }), jsxRuntimeExports.jsx("div", { className: "flex-1 overflow-y-auto p-4 min-h-0", children: jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-1 gap-2", children: [filteredCities.map((city) => (jsxRuntimeExports.jsx("button", { onClick: () => {
	                                setValue("city", city, { shouldDirty: true, shouldTouch: true, shouldValidate: true });
	                                setCitySearch("");
	                                setStep(2);
	                            }, className: "text-left px-5 py-4 rounded-lg hover:text-white hover:bg-gradient-to-r hover:from-[#6D28D9] hover:to-[#5B21B6] transition-all duration-200 text-base font-medium shadow-sm hover:shadow-md border border-transparent hover:border-[#6D28D9] bg-white", children: jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-3", children: [jsxRuntimeExports.jsxs("svg", { className: "w-5 h-5 opacity-70", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor", children: [jsxRuntimeExports.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M17.657 16.657L13.414 20.9a1.998 1.998 0 01-2.827 0l-4.244-4.243a8 8 0 1111.314 0z" }), jsxRuntimeExports.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M15 11a3 3 0 11-6 0 3 3 0 016 0z" })] }), city] }) }, city))), filteredCities.length === 0 && (jsxRuntimeExports.jsxs("div", { className: "text-center py-12 text-slate-500 text-base", children: [jsxRuntimeExports.jsx("div", { className: "text-4xl mb-3", children: "\uD83D\uDE15" }), jsxRuntimeExports.jsx("div", { className: "font-medium", children: "Oh no! We haven't unwrapped this destination yet!" }), jsxRuntimeExports.jsx("div", { className: "text-sm mt-2 text-slate-400", children: "Try searching for a different city" })] }))] }) }), errors.city && jsxRuntimeExports.jsx("div", { className: "flex-none px-4 pb-4 text-sm text-red-500 font-medium bg-red-50 border-t border-red-200", children: errors.city.message })] }));
	}

	function Step1Dates({ setValue, setStep, errors, watchedDates }) {
	    var _a, _b, _c, _d, _e, _f;
	    const monthsToShow = 4;
	    const today = new Date();
	    const startMonth = new Date(today.getFullYear(), today.getMonth(), 1);
	    const months = Array.from({ length: monthsToShow }).map((_, mi) => {
	        const firstOfMonth = new Date(startMonth.getFullYear(), startMonth.getMonth() + mi, 1);
	        return firstOfMonth;
	    });
	    const MAX_RANGE_DAYS = 10; // inclusive window (start to end)
	    const MS_PER_DAY = 24 * 60 * 60 * 1000;
	    const normalize = (d) => {
	        if (!d)
	            return null;
	        if (d instanceof Date)
	            return new Date(d.getFullYear(), d.getMonth(), d.getDate());
	        const parsed = new Date(d);
	        if (isNaN(parsed.getTime()))
	            return null;
	        return new Date(parsed.getFullYear(), parsed.getMonth(), parsed.getDate());
	    };
	    const startDate = reactExports.useMemo(() => normalize(watchedDates === null || watchedDates === void 0 ? void 0 : watchedDates.start), [watchedDates === null || watchedDates === void 0 ? void 0 : watchedDates.start]);
	    const endDate = reactExports.useMemo(() => normalize(watchedDates === null || watchedDates === void 0 ? void 0 : watchedDates.end), [watchedDates === null || watchedDates === void 0 ? void 0 : watchedDates.end]);
	    const [rangeError, setRangeError] = reactExports.useState("");
	    const maxEndDate = reactExports.useMemo(() => {
	        if (!startDate)
	            return null;
	        const d = new Date(startDate);
	        d.setDate(d.getDate() + (MAX_RANGE_DAYS - 1)); // inclusive: start + 9 = 10 days total
	        return d;
	    }, [startDate]);
	    const totalDays = reactExports.useMemo(() => {
	        if (!startDate || !endDate)
	            return 0;
	        return Math.floor((endDate.getTime() - startDate.getTime()) / MS_PER_DAY) + 1; // inclusive
	    }, [startDate, endDate]);
	    const resetSelection = () => {
	        setValue("dates.start", null);
	        setValue("dates.end", null);
	        setRangeError("");
	    };
	    return (jsxRuntimeExports.jsxs("div", { className: "h-full flex flex-col bg-gradient-to-b from-white to-slate-50", children: [jsxRuntimeExports.jsxs("div", { className: "flex-none p-4 border-b bg-white", children: [jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between gap-4", children: [jsxRuntimeExports.jsxs("div", { children: [jsxRuntimeExports.jsx("div", { className: "text-base font-semibold text-gray-900", children: "Select your travel dates" }), jsxRuntimeExports.jsx("div", { className: "text-sm text-gray-500", children: "You can select 3-10 days (minimum 3 nights)" })] }), startDate && (jsxRuntimeExports.jsx("button", { type: "button", onClick: resetSelection, className: "px-3 py-2 rounded-full text-sm font-medium border-2 border-[#6D28D9] text-[#6D28D9] hover:bg-[#6D28D9] hover:text-white transition-colors", children: "Reset" }))] }), (startDate || endDate) && (jsxRuntimeExports.jsxs("div", { className: "mt-3 flex flex-wrap items-center gap-2 text-sm", children: [startDate && (jsxRuntimeExports.jsxs("span", { className: "inline-flex items-center gap-1 px-3 py-1 rounded-full bg-[#6D28D9]/10 text-[#6D28D9] font-medium", children: [jsxRuntimeExports.jsx("svg", { className: "w-4 h-4", viewBox: "0 0 20 20", fill: "currentColor", children: jsxRuntimeExports.jsx("path", { d: "M6 2a1 1 0 00-1 1v1H4a2 2 0 00-2 2v1h16V6a2 2 0 00-2-2h-1V3a1 1 0 10-2 0v1H7V3a1 1 0 00-1-1zM18 9H2v5a2 2 0 002 2h12a2 2 0 002-2V9z" }) }), "Start: ", format(startDate, "dd MMM, yyyy")] })), endDate && (jsxRuntimeExports.jsxs("span", { className: "inline-flex items-center gap-1 px-3 py-1 rounded-full bg-[#6D28D9]/10 text-[#6D28D9] font-medium", children: [jsxRuntimeExports.jsx("svg", { className: "w-4 h-4", viewBox: "0 0 20 20", fill: "currentColor", children: jsxRuntimeExports.jsx("path", { d: "M6 2a1 1 0 00-1 1v1H4a2 2 0 00-2 2v1h16V6a2 2 0 00-2-2h-1V3a1 1 0 10-2 0v1H7V3a1 1 0 00-1-1zM18 9H2v5a2 2 0 002 2h12a2 2 0 002-2V9z" }) }), "End: ", format(endDate, "dd MMM, yyyy")] })), startDate && endDate && (jsxRuntimeExports.jsxs("span", { className: "inline-flex items-center gap-1 px-3 py-1 rounded-full bg-emerald-50 text-emerald-700 font-medium", children: [jsxRuntimeExports.jsx("svg", { className: "w-4 h-4", viewBox: "0 0 20 20", fill: "currentColor", children: jsxRuntimeExports.jsx("path", { d: "M13 7H7a1 1 0 000 2h6a1 1 0 100-2zM7 11h6a1 1 0 010 2H7a1 1 0 110-2z" }) }), totalDays, " ", totalDays === 1 ? "day" : "days"] }))] })), rangeError && (jsxRuntimeExports.jsx("div", { className: "mt-3 text-amber-800 bg-amber-50 border border-amber-200 rounded-md px-3 py-2 text-sm", children: rangeError }))] }), jsxRuntimeExports.jsx("div", { className: "flex-1 p-4 overflow-y-auto min-h-0", children: jsxRuntimeExports.jsx("div", { className: "grid grid-cols-1 gap-6", children: months.map((m, mi) => {
	                        const year = m.getFullYear();
	                        const month = m.getMonth();
	                        const daysInMonth = new Date(year, month + 1, 0).getDate();
	                        const firstWeekday = new Date(year, month, 1).getDay();
	                        const cells = [];
	                        for (let i = 0; i < firstWeekday; i++)
	                            cells.push(null);
	                        for (let d = 1; d <= daysInMonth; d++)
	                            cells.push(new Date(year, month, d));
	                        return (jsxRuntimeExports.jsxs("div", { className: "border border-[#6D28D9]/20 rounded-lg p-3 bg-white shadow-sm", children: [jsxRuntimeExports.jsxs("div", { className: "text-center font-semibold text-lg mb-3 text-[#6D28D9]", children: [format(m, "MMMM"), " ", year] }), jsxRuntimeExports.jsx("div", { className: "grid grid-cols-7 gap-1 mb-2", children: WEEK_DAYS.map((wd) => (jsxRuntimeExports.jsx("div", { className: "text-center text-sm text-slate-500 font-medium", children: wd }, wd))) }), jsxRuntimeExports.jsx("div", { className: "grid grid-cols-7 gap-1", children: cells.map((cell, ci) => {
	                                        if (cell === null) {
	                                            return jsxRuntimeExports.jsx("div", { className: "h-10" }, ci);
	                                        }
	                                        // normalize cell and watched dates to plain date objects without time
	                                        const cellDate = new Date(cell.getFullYear(), cell.getMonth(), cell.getDate());
	                                        const todayDate = new Date(today.getFullYear(), today.getMonth(), today.getDate());
	                                        const isBeforeToday = cellDate < todayDate;
	                                        const sDate = startDate;
	                                        const eDate = endDate;
	                                        const isSelectedStart = sDate && cellDate.getTime() === sDate.getTime();
	                                        const isSelectedEnd = eDate && cellDate.getTime() === eDate.getTime();
	                                        const isInRange = sDate && eDate && cellDate.getTime() > sDate.getTime() && cellDate.getTime() < eDate.getTime();
	                                        const beyondMax = sDate && maxEndDate ? cellDate.getTime() > maxEndDate.getTime() : false;
	                                        const isDisabled = isBeforeToday || !!beyondMax;
	                                        let className = `aspect-square flex items-center justify-center p-1 text-center rounded text-base font-medium transition-colors ${isDisabled ? "text-slate-300 cursor-not-allowed" : "hover:bg-[#6D28D9]/10"}`;
	                                        if (isSelectedStart || isSelectedEnd)
	                                            className += " bg-[#6D28D9] text-white";
	                                        else if (isInRange)
	                                            className += " bg-[#6D28D9]/10 text-[#111827]";
	                                        else if (!isDisabled && cellDate.getTime() === todayDate.getTime())
	                                            className += " ring-1 ring-[#6D28D9]/40";
	                                        return (jsxRuntimeExports.jsx("button", { onClick: () => {
	                                                if (isDisabled)
	                                                    return;
	                                                setRangeError("");
	                                                if (!sDate || cellDate.getTime() < sDate.getTime()) {
	                                                    setValue("dates.start", cell);
	                                                    setValue("dates.end", cell);
	                                                }
	                                                else if (sDate && cellDate.getTime() >= sDate.getTime()) {
	                                                    // inclusive window: end must be <= start + 14 (15 days total) and >= start + 3 (4 days total for 3 nights)
	                                                    const diffDaysIncl = Math.floor((cellDate.getTime() - sDate.getTime()) / MS_PER_DAY) + 1;
	                                                    if (diffDaysIncl > MAX_RANGE_DAYS) {
	                                                        setRangeError(`Maximum ${MAX_RANGE_DAYS} days can be selected`);
	                                                        return;
	                                                    }
	                                                    if (diffDaysIncl < 4) {
	                                                        setRangeError(`Minimum 3 nights required (4 days total)`);
	                                                        return;
	                                                    }
	                                                    setValue("dates.end", cell);
	                                                    setTimeout(() => setStep(3), 300);
	                                                }
	                                                else {
	                                                    setValue("dates.start", cell);
	                                                    setValue("dates.end", cell);
	                                                }
	                                            }, disabled: isDisabled, className: className, children: jsxRuntimeExports.jsx("div", { children: cell.getDate() }) }, ci));
	                                    }) })] }, mi));
	                    }) }) }), (((_a = errors.dates) === null || _a === void 0 ? void 0 : _a.start) || ((_b = errors.dates) === null || _b === void 0 ? void 0 : _b.end)) && (jsxRuntimeExports.jsx("div", { className: "flex-none px-4 pb-4 text-sm text-red-500 font-medium bg-red-50 border-t border-red-200", children: ((_d = (_c = errors.dates) === null || _c === void 0 ? void 0 : _c.start) === null || _d === void 0 ? void 0 : _d.message) || ((_f = (_e = errors.dates) === null || _e === void 0 ? void 0 : _e.end) === null || _f === void 0 ? void 0 : _f.message) }))] }));
	}

	function Step2Rooms({ setValue, errors, watchedRooms, handleNext }) {
	    return (jsxRuntimeExports.jsxs("div", { className: "h-full flex flex-col", children: [jsxRuntimeExports.jsx("div", { className: "flex-1 overflow-y-auto p-3.5 min-h-0", children: watchedRooms.map((room, idx) => {
	                    var _a, _b, _c, _d, _e, _f, _g, _h, _j;
	                    return (jsxRuntimeExports.jsxs("div", { className: "mb-4 border rounded-lg", children: [jsxRuntimeExports.jsxs("div", { className: "px-4 py-3 flex items-center justify-between", children: [jsxRuntimeExports.jsxs("div", { children: [jsxRuntimeExports.jsxs("div", { className: "font-semibold text-lg", children: ["Room ", idx + 1] }), jsxRuntimeExports.jsxs("div", { className: "text-sm text-emerald-600 font-medium", children: [room.adults, " ", room.adults === 1 ? "adult" : "adults", room.children ? `, ${room.children} ${room.children === 1 ? "child" : "children"}` : "", room.infants ? `, ${room.infants} ${room.infants === 1 ? "infant" : "infants"}` : ""] })] }), jsxRuntimeExports.jsx("div", { className: "flex items-center gap-2", children: idx > 0 && (jsxRuntimeExports.jsx("button", { onClick: () => {
	                                                const newRooms = watchedRooms.filter((_, i) => i !== idx);
	                                                setValue("rooms", newRooms, { shouldValidate: true });
	                                            }, className: "text-red-500 p-2 text-sm font-medium", "aria-label": `Remove room ${idx + 1}`, children: "Remove" })) })] }), jsxRuntimeExports.jsxs("div", { className: "px-4 pb-4", children: [jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-3 gap-3 mb-3", children: [jsxRuntimeExports.jsxs("button", { type: "button", className: `p-4 border rounded-lg text-center flex flex-col items-center gap-2 ${room.adults === 2 && room.children === 0 ? "ring-2 ring-[#6D28D9] bg-emerald-50" : ""} hover:bg-[#F3E8FF] transition-colors`, onClick: () => {
	                                                    const newRooms = [...watchedRooms];
	                                                    newRooms[idx] = Object.assign(Object.assign({}, newRooms[idx]), { adults: 2, children: 0, childAges: [] });
	                                                    setValue("rooms", newRooms, { shouldValidate: true });
	                                                }, children: [jsxRuntimeExports.jsxs("div", { className: "flex gap-1", children: [jsxRuntimeExports.jsx("svg", { className: "w-5 h-5 text-[#6D28D9]", fill: "none", stroke: "currentColor", strokeWidth: "2", viewBox: "0 0 24 24", children: jsxRuntimeExports.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", d: "M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z" }) }), jsxRuntimeExports.jsx("svg", { className: "w-5 h-5 text-[#6D28D9]", fill: "none", stroke: "currentColor", strokeWidth: "2", viewBox: "0 0 24 24", children: jsxRuntimeExports.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", d: "M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z" }) })] }), jsxRuntimeExports.jsx("div", { className: "text-sm font-medium text-[#6D28D9]", children: "2 Adults" })] }), jsxRuntimeExports.jsxs("button", { type: "button", className: `p-4 border rounded-lg text-center flex flex-col items-center gap-2 ${room.adults === 2 && room.children === 1 ? "ring-2 ring-[#6D28D9] bg-emerald-50" : ""} hover:bg-[#F3E8FF] transition-colors`, onClick: () => {
	                                                    const newRooms = [...watchedRooms];
	                                                    newRooms[idx] = Object.assign(Object.assign({}, newRooms[idx]), { adults: 2, children: 1, childAges: [] });
	                                                    setValue("rooms", newRooms, { shouldValidate: true });
	                                                }, children: [jsxRuntimeExports.jsxs("div", { className: "flex gap-1 items-end", children: [jsxRuntimeExports.jsx("svg", { className: "w-5 h-5 text-[#6D28D9]", fill: "none", stroke: "currentColor", strokeWidth: "2", viewBox: "0 0 24 24", children: jsxRuntimeExports.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", d: "M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z" }) }), jsxRuntimeExports.jsx("svg", { className: "w-5 h-5 text-[#6D28D9]", fill: "none", stroke: "currentColor", strokeWidth: "2", viewBox: "0 0 24 24", children: jsxRuntimeExports.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", d: "M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z" }) }), jsxRuntimeExports.jsx("svg", { className: "w-4 h-4 text-[#6D28D9]", fill: "none", stroke: "currentColor", strokeWidth: "2", viewBox: "0 0 24 24", children: jsxRuntimeExports.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", d: "M14.828 14.828a4 4 0 01-5.656 0M9 10h.01M15 10h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" }) })] }), jsxRuntimeExports.jsx("div", { className: "text-xs font-medium text-[#6D28D9]", children: "2 Adults 1 Child" })] }), jsxRuntimeExports.jsxs("button", { type: "button", className: `p-4 border rounded-lg text-center flex flex-col items-center gap-2 ${room.adults === 3 ? "ring-2 ring-[#6D28D9] bg-emerald-50" : ""} hover:bg-[#F3E8FF] transition-colors`, onClick: () => {
	                                                    const newRooms = [...watchedRooms];
	                                                    newRooms[idx] = Object.assign(Object.assign({}, newRooms[idx]), { adults: 3, children: 0, childAges: [] });
	                                                    setValue("rooms", newRooms, { shouldValidate: true });
	                                                }, children: [jsxRuntimeExports.jsxs("div", { className: "flex gap-1", children: [jsxRuntimeExports.jsx("svg", { className: "w-5 h-5 text-[#6D28D9]", fill: "none", stroke: "currentColor", strokeWidth: "2", viewBox: "0 0 24 24", children: jsxRuntimeExports.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", d: "M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z" }) }), jsxRuntimeExports.jsx("svg", { className: "w-5 h-5 text-[#6D28D9]", fill: "none", stroke: "currentColor", strokeWidth: "2", viewBox: "0 0 24 24", children: jsxRuntimeExports.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", d: "M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z" }) }), jsxRuntimeExports.jsx("svg", { className: "w-5 h-5 text-[#6D28D9]", fill: "none", stroke: "currentColor", strokeWidth: "2", viewBox: "0 0 24 24", children: jsxRuntimeExports.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", d: "M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z" }) })] }), jsxRuntimeExports.jsx("div", { className: "text-sm font-medium text-[#6D28D9]", children: "3 Adults" })] })] }), ((_b = (_a = errors.rooms) === null || _a === void 0 ? void 0 : _a[idx]) === null || _b === void 0 ? void 0 : _b.adults) && (jsxRuntimeExports.jsx("div", { className: "text-sm text-red-500 mb-2", children: (_c = errors.rooms[idx].adults) === null || _c === void 0 ? void 0 : _c.message })), ((_e = (_d = errors.rooms) === null || _d === void 0 ? void 0 : _d[idx]) === null || _e === void 0 ? void 0 : _e.children) && (jsxRuntimeExports.jsx("div", { className: "text-sm text-red-500 mb-2", children: (_f = errors.rooms[idx].children) === null || _f === void 0 ? void 0 : _f.message })), room.children > 0 && (jsxRuntimeExports.jsxs("div", { className: "mt-4", children: [jsxRuntimeExports.jsx("div", { className: "text-base font-semibold mb-2 text-[#6D28D9]", children: "Update children details" }), jsxRuntimeExports.jsx("div", { className: "divide-y", children: Array.from({ length: room.children }).map((_, cIdx) => {
	                                                    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
	                                                    const age = (_a = room.childAges) === null || _a === void 0 ? void 0 : _a[cIdx];
	                                                    return (jsxRuntimeExports.jsxs("div", { className: "py-3 flex items-center justify-between", children: [jsxRuntimeExports.jsxs("div", { className: "text-sm font-medium flex items-center gap-2", children: [jsxRuntimeExports.jsx("svg", { className: "w-4 h-4 text-[#6D28D9]", fill: "none", stroke: "currentColor", strokeWidth: "2", viewBox: "0 0 24 24", children: jsxRuntimeExports.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", d: "M14.828 14.828a4 4 0 01-5.656 0M9 10h.01M15 10h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" }) }), "Age of Child ", cIdx + 1] }), jsxRuntimeExports.jsxs("div", { className: "relative", children: [jsxRuntimeExports.jsxs("select", { value: age !== null && age !== void 0 ? age : "", onChange: (e) => {
	                                                                            var _a;
	                                                                            const val = e.target.value === "" ? undefined : Number(e.target.value);
	                                                                            const newRooms = [...watchedRooms];
	                                                                            const childAges = [...((_a = newRooms[idx].childAges) !== null && _a !== void 0 ? _a : [])];
	                                                                            childAges[cIdx] = val;
	                                                                            newRooms[idx] = Object.assign(Object.assign({}, newRooms[idx]), { childAges });
	                                                                            setValue("rooms", newRooms, { shouldValidate: true });
	                                                                        }, className: `appearance-none min-w-[140px] py-2.5 px-3 pr-10 border-2 rounded-lg text-sm md:text-base focus:outline-none bg-white text-[#6D28D9] font-medium ${((_c = (_b = errors.rooms) === null || _b === void 0 ? void 0 : _b[idx]) === null || _c === void 0 ? void 0 : _c.childAges)
                                                                            ? "border-red-500 focus:ring-2 focus:ring-red-200"
                                                                            : "border-[#6D28D9]/40 focus:ring-2 focus:ring-[#A78BFA]/30"} hover:border-[#6D28D9] transition-all cursor-pointer`, style: {
	                                                                            maxHeight: '200px'
	                                                                        }, children: [jsxRuntimeExports.jsx("option", { value: "", children: "Select age" }), Array.from({ length: 17 }).map((__, a) => (jsxRuntimeExports.jsxs("option", { value: a + 1, className: "min-h-[150px]", children: [a + 1, " ", a + 1 === 1 ? 'Year' : 'Years'] }, a)))] }), jsxRuntimeExports.jsx("svg", { className: "absolute right-3 top-1/2 transform -translate-y-1/2 w-5 h-5 text-[#6D28D9] pointer-events-none", fill: "none", stroke: "currentColor", strokeWidth: "2", viewBox: "0 0 24 24", children: jsxRuntimeExports.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", d: "M19 9l-7 7-7-7" }) })] }), ((_g = (_f = (_e = (_d = errors.rooms) === null || _d === void 0 ? void 0 : _d[idx]) === null || _e === void 0 ? void 0 : _e.childAges) === null || _f === void 0 ? void 0 : _f[cIdx]) === null || _g === void 0 ? void 0 : _g.message) && (jsxRuntimeExports.jsx("div", { className: "text-xs text-red-600 mt-1", children: String((_l = (_k = (_j = (_h = errors.rooms) === null || _h === void 0 ? void 0 : _h[idx]) === null || _j === void 0 ? void 0 : _j.childAges) === null || _k === void 0 ? void 0 : _k[cIdx]) === null || _l === void 0 ? void 0 : _l.message) }))] }, cIdx));
	                                                }) }), ((_h = (_g = errors.rooms) === null || _g === void 0 ? void 0 : _g[idx]) === null || _h === void 0 ? void 0 : _h.childAges) && (jsxRuntimeExports.jsx("div", { className: "text-sm text-red-500 mt-1", children: (_j = errors.rooms[idx].childAges) === null || _j === void 0 ? void 0 : _j.message }))] }))] })] }, room.id));
	                }) }), jsxRuntimeExports.jsx("div", { className: "flex-none p-4 bg-white border-t", children: jsxRuntimeExports.jsxs("div", { className: "flex gap-3", children: [jsxRuntimeExports.jsx("button", { type: "button", onClick: () => {
	                                if (watchedRooms.length >= 10)
	                                    return;
	                                const newRoom = {
	                                    id: Date.now(),
	                                    adults: 2,
	                                    children: 0,
	                                    infants: 0,
	                                    childAges: [],
	                                };
	                                setValue("rooms", [...watchedRooms, newRoom], { shouldValidate: true });
	                            }, disabled: watchedRooms.length >= 10, className: "flex-1 p-3 border rounded-lg bg-[#F0F9FF] text-[#6D28D9] disabled:opacity-50 text-base font-medium hover:bg-[#6D28D9]/10 transition-colors", children: "Add new room" }), jsxRuntimeExports.jsx("button", { type: "button", onClick: handleNext, className: "flex-1 p-3 bg-[#6D28D9] text-white rounded-lg text-base font-medium hover:bg-[#5B21B6] transition-colors", children: "Confirm Changes" })] }) }), errors.rooms && typeof errors.rooms.message === "string" && (jsxRuntimeExports.jsx("div", { className: "flex-none px-4 pb-4 text-sm text-red-500 font-medium bg-red-50", children: errors.rooms.message })), jsxRuntimeExports.jsx("style", { children: `
        select {
          -webkit-appearance: none;
          -moz-appearance: none;
          appearance: none;
        }
        
        select option {
          padding: 10px;
        }
        
        /* Custom scrollbar for dropdown on webkit browsers */
        select::-webkit-scrollbar {
          width: 8px;
          height: 8px;
        }
        
        select::-webkit-scrollbar-track {
          background: #f1f1f1;
          border-radius: 4px;
        }
        
        select::-webkit-scrollbar-thumb {
          background: #6D28D9;
          border-radius: 4px;
        }
        
        select::-webkit-scrollbar-thumb:hover {
          background: #5B21B6;
        }
        
        /* Limit visible options to approximately 5 */
        @media (min-width: 768px) {
          select {
            size: 5;
          }
        }
      ` })] }));
	}

	const LOGIN_COUNTRIES = [
	    {
	        code: '+91',
	        country: 'India',
	        flag: '',
	        localLength: 10,
	        localPattern: '[6-9][0-9]{9}',
	        placeholder: '9876543210',
	    },
	    {
	        code: '+1',
	        country: 'USA / Canada',
	        flag: '',
	        localLength: 10,
	        localPattern: '[2-9][0-9]{2}[2-9][0-9]{6}',
	        placeholder: '4155552671',
	    },
	    {
	        code: '+33',
	        country: 'France',
	        flag: '',
	        localLength: 9,
	        localPattern: '[6-7][0-9]{8}',
	        placeholder: '612345678',
	    },
	    {
	        code: '+44',
	        country: 'UK',
	        flag: '',
	        localLength: 10,
	        localPattern: '7[0-9]{9}',
	        placeholder: '7123456789',
	    },
	];
	const getLoginCountryMeta = (code) => {
	    return LOGIN_COUNTRIES.find((c) => c.code === code) || LOGIN_COUNTRIES[0];
	};
	const isValidLocalFor = (code, localNumber) => {
	    const meta = getLoginCountryMeta(code);
	    const regex = new RegExp(`^${meta.localPattern}$`);
	    return regex.test(localNumber);
	};
	const getMaxLengthFor = (code) => {
	    return getLoginCountryMeta(code).localLength;
	};
	const sanitizeLocalNumber = (value) => {
	    return (value || '').replace(/\D/g, '');
	};
	const trimToMaxLength = (code, value) => {
	    const max = getMaxLengthFor(code);
	    const digits = sanitizeLocalNumber(value);
	    return digits.slice(0, max);
	};
	const isValidPartialFor = (code, localNumber) => {
	    if (!localNumber)
	        return true;
	    const meta = getLoginCountryMeta(code);
	    const max = meta.localLength;
	    if (!/^\d+$/.test(localNumber) || localNumber.length > max) {
	        return false;
	    }
	    if (code === '+91' && !/^[6-9]/.test(localNumber)) {
	        return false;
	    }
	    if (code === '+1') {
	        if (!/^[2-9]/.test(localNumber)) {
	            return false;
	        }
	        if (localNumber.length >= 4 && !/^[2-9]\d{2}[2-9]/.test(localNumber)) {
	            return false;
	        }
	    }
	    if (code === '+44' && !/^7/.test(localNumber)) {
	        return false;
	    }
	    if (code === '+33' && !/^[6-7]/.test(localNumber)) {
	        return false;
	    }
	    return true;
	};

	const PhoneNumberField = ({ countryCode, phoneNumber, onCountryCodeChange, onPhoneNumberChange, disabled = false, error = false, helperText, placeholder, }) => {
	    const maxLen = getMaxLengthFor(countryCode);
	    const handlePhoneChange = (value) => {
	        const trimmed = trimToMaxLength(countryCode, value);
	        if (isValidPartialFor(countryCode, trimmed)) {
	            onPhoneNumberChange(trimmed);
	        }
	        else if (trimmed === '') {
	            onPhoneNumberChange('');
	        }
	    };
	    const handleCountryChange = (code) => {
	        // When changing country, clear the local number (behaviour matches CRMCreateLead)
	        onCountryCodeChange(code);
	        onPhoneNumberChange('');
	    };
	    return (jsxRuntimeExports.jsxs("div", { children: [jsxRuntimeExports.jsxs("div", { className: "flex space-x-2", children: [jsxRuntimeExports.jsx("div", { className: "flex items-center rounded-lg border-2 bg-gray-50 border-gray-300", children: jsxRuntimeExports.jsx("select", { className: "appearance-none bg-transparent px-3 py-2 text-base leading-tight focus:outline-none", value: countryCode, onChange: (e) => handleCountryChange(e.target.value), disabled: disabled, "aria-label": "Country code", children: LOGIN_COUNTRIES.map((c) => (jsxRuntimeExports.jsxs("option", { value: c.code, children: [c.flag, " ", c.code] }, c.code))) }) }), jsxRuntimeExports.jsx("input", { type: "tel", className: `w-full p-3 border-2 rounded-lg text-base ${error ? 'border-red-500' : 'border-gray-300 focus:border-emerald-500'} focus:ring-2 focus:ring-emerald-500 focus:outline-none`, value: phoneNumber, onChange: (e) => handlePhoneChange(e.target.value), placeholder: placeholder || getLoginCountryMeta(countryCode).placeholder, disabled: disabled, inputMode: "numeric", maxLength: maxLen })] }), helperText !== undefined && (jsxRuntimeExports.jsx("p", { className: `mt-1 text-sm ${error ? 'text-red-600' : 'text-gray-600'}`, children: helperText }))] }));
	};

	function Step4Contact({ control, errors, handleNext, onVerifyContact }) {
	    var _a;
	    return (jsxRuntimeExports.jsxs("div", { className: "h-full flex flex-col bg-gradient-to-b from-white to-slate-50", children: [jsxRuntimeExports.jsxs("div", { className: "flex-1 p-6 space-y-6 overflow-y-auto min-h-0", children: [jsxRuntimeExports.jsxs("div", { className: "space-y-2", children: [jsxRuntimeExports.jsxs("label", { className: "flex items-center gap-2 text-base font-semibold text-gray-700", children: [jsxRuntimeExports.jsx("svg", { className: "w-5 h-5 text-emerald-600", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor", children: jsxRuntimeExports.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z" }) }), "Name (Optional)"] }), jsxRuntimeExports.jsx(Controller, { name: "contact.name", control: control, render: ({ field }) => (jsxRuntimeExports.jsx("input", Object.assign({}, field, { type: "text", className: "w-full p-3 border-2 border-gray-300 rounded-lg focus:ring-2 focus:ring-emerald-500 focus:border-emerald-500 focus:outline-none text-base transition-all shadow-sm", placeholder: "Enter your full name" }))) })] }), jsxRuntimeExports.jsxs("div", { className: "space-y-2", children: [jsxRuntimeExports.jsxs("label", { className: "flex items-center gap-2 text-base font-semibold text-gray-700", children: [jsxRuntimeExports.jsx("svg", { className: "w-5 h-5 text-emerald-600", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor", children: jsxRuntimeExports.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M3 5a2 2 0 012-2h3.28a1 1 0 01.948.684l1.498 4.493a1 1 0 01-.502 1.21l-2.257 1.13a11.042 11.042 0 005.516 5.516l1.13-2.257a1 1 0 011.21-.502l4.493 1.498a1 1 0 01.684.949V19a2 2 0 01-2 2h-1C9.716 21 3 14.284 3 6V5z" }) }), "Phone Number ", jsxRuntimeExports.jsx("span", { className: "text-red-500", children: "*" })] }), jsxRuntimeExports.jsx(Controller, { name: "contact.phone", control: control, render: ({ field }) => {
	                                    var _a, _b, _c;
	                                    // Parse current value into local digits and country code
	                                    const raw = typeof field.value === 'string' ? field.value : '';
	                                    const digits = raw.replace(/\D/g, '');
	                                    // Derive a default country code based on prefix; fallback to +91
	                                    let matched = LOGIN_COUNTRIES[0];
	                                    for (const c of LOGIN_COUNTRIES) {
	                                        const codeDigits = c.code.replace('+', '');
	                                        if (digits.startsWith(codeDigits)) {
	                                            matched = c;
	                                            break;
	                                        }
	                                    }
	                                    const codeFromValue = matched.code;
	                                    const local = digits.startsWith(codeFromValue.replace('+', '')) ? digits.slice(codeFromValue.replace('+', '').length) : digits;
	                                    // Local state for country-specific helper error (kept locally so parent form errors are respected)
	                                    const [phoneCountryCode, setPhoneCountryCode] = reactExports.useState(codeFromValue);
	                                    const [countryError, setCountryError] = reactExports.useState('');
	                                    // Sync state when raw field value changes (e.g., external updates)
	                                    reactExports.useEffect(() => {
	                                        setPhoneCountryCode(codeFromValue);
	                                    }, [raw]);
	                                    return (jsxRuntimeExports.jsx("div", { children: jsxRuntimeExports.jsx(PhoneNumberField, { countryCode: phoneCountryCode, phoneNumber: local, onCountryCodeChange: (code) => {
	                                                setPhoneCountryCode(code);
	                                                // Clear the underlying form value and any country error
	                                                field.onChange('');
	                                                setCountryError('');
	                                            }, onPhoneNumberChange: (phone) => {
	                                                // phone is local digits only
	                                                if (!phone) {
	                                                    field.onChange('');
	                                                    setCountryError('');
	                                                    return;
	                                                }
	                                                // set normalized +<code><local>
	                                                const normalized = `+${phoneCountryCode.replace(/^\+/, '')}${phone}`;
	                                                field.onChange(normalized);
	                                                // Immediate country-specific validation feedback
	                                                if (!isValidLocalFor(phoneCountryCode, phone)) {
	                                                    setCountryError(`Invalid phone number format for ${phoneCountryCode}`);
	                                                }
	                                                else {
	                                                    setCountryError('');
	                                                }
	                                            }, error: !!((_a = errors.contact) === null || _a === void 0 ? void 0 : _a.phone), helperText: ((_c = (_b = errors.contact) === null || _b === void 0 ? void 0 : _b.phone) === null || _c === void 0 ? void 0 : _c.message) || countryError || ' ', placeholder: '' }) }));
	                                } })] }), jsxRuntimeExports.jsxs("div", { className: "space-y-2", children: [jsxRuntimeExports.jsxs("label", { className: "flex items-center gap-2 text-base font-semibold text-gray-700", children: [jsxRuntimeExports.jsx("svg", { className: "w-5 h-5 text-emerald-600", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor", children: jsxRuntimeExports.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M3 8l7.89 5.26a2 2 0 002.22 0L21 8M5 19h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v10a2 2 0 002 2z" }) }), "Email (Optional)"] }), jsxRuntimeExports.jsx(Controller, { name: "contact.email", control: control, render: ({ field }) => {
	                                    var _a;
	                                    return (jsxRuntimeExports.jsx("input", Object.assign({}, field, { type: "email", className: `w-full p-3 border-2 rounded-lg focus:ring-2 focus:ring-emerald-500 focus:outline-none text-base transition-all shadow-sm ${((_a = errors.contact) === null || _a === void 0 ? void 0 : _a.email) ? "border-red-500 focus:border-red-500" : "border-gray-300 focus:border-emerald-500"}`, placeholder: "your.email@example.com" })));
	                                } }), ((_a = errors.contact) === null || _a === void 0 ? void 0 : _a.email) && (jsxRuntimeExports.jsxs("div", { className: "text-sm text-red-600 mt-2 font-medium flex items-center gap-1", children: [jsxRuntimeExports.jsx("svg", { className: "w-4 h-4", fill: "currentColor", viewBox: "0 0 20 20", children: jsxRuntimeExports.jsx("path", { fillRule: "evenodd", d: "M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7 4a1 1 0 11-2 0 1 1 0 012 0zm-1-9a1 1 0 00-1 1v4a1 1 0 102 0V6a1 1 0 00-1-1z", clipRule: "evenodd" }) }), errors.contact.email.message] }))] })] }), jsxRuntimeExports.jsx("div", { className: "flex-none p-4 border-t bg-white", children: jsxRuntimeExports.jsxs("button", { type: "button", onClick: onVerifyContact, className: "w-full p-4 bg-gradient-to-r from-emerald-600 to-emerald-700 text-white rounded-lg text-base font-semibold shadow-md hover:shadow-lg hover:from-emerald-700 hover:to-emerald-800 transition-all duration-200 flex items-center justify-center gap-2", children: ["Verify & Submit", jsxRuntimeExports.jsx("svg", { className: "w-5 h-5", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor", children: jsxRuntimeExports.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M5 13l4 4L19 7" }) })] }) })] }));
	}

	function Step5Extras({ control, handleNext }) {
	    return (jsxRuntimeExports.jsxs("div", { className: "h-full flex flex-col bg-gradient-to-b from-white to-slate-50", children: [jsxRuntimeExports.jsxs("div", { className: "flex-1 p-2.5 space-y-2.5 overflow-y-auto min-h-0", children: [jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between p-5 border-2 border-gray-200 rounded-xl hover:border-purple-300 transition-all shadow-sm hover:shadow-md bg-white", children: [jsxRuntimeExports.jsx("div", { className: "flex items-start gap-4", children: jsxRuntimeExports.jsx("div", { children: jsxRuntimeExports.jsx("div", { className: "font-semibold text-lg text-gray-800", children: "Visa Assistance" }) }) }), jsxRuntimeExports.jsx(Controller, { name: "extras.visaAssistance", control: control, render: ({ field }) => (jsxRuntimeExports.jsxs("label", { className: "relative inline-flex items-center cursor-pointer", children: [jsxRuntimeExports.jsx("input", { type: "checkbox", checked: field.value, onChange: field.onChange, className: "sr-only peer" }), jsxRuntimeExports.jsx("div", { className: "w-14 h-7 bg-gray-200 peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-purple-300 rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-6 after:w-6 after:transition-all peer-checked:bg-purple-700 shadow-inner" })] })) })] }), jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between p-5 border-2 border-gray-200 rounded-xl hover:border-purple-300 transition-all shadow-sm hover:shadow-md bg-white", children: [jsxRuntimeExports.jsx("div", { className: "flex items-start gap-4", children: jsxRuntimeExports.jsx("div", { children: jsxRuntimeExports.jsx("div", { className: "font-semibold text-lg text-gray-800", children: "Travel Insurance" }) }) }), jsxRuntimeExports.jsx(Controller, { name: "extras.travelInsurance", control: control, render: ({ field }) => (jsxRuntimeExports.jsxs("label", { className: "relative inline-flex items-center cursor-pointer", children: [jsxRuntimeExports.jsx("input", { type: "checkbox", checked: field.value, onChange: field.onChange, className: "sr-only peer" }), jsxRuntimeExports.jsx("div", { className: "w-14 h-7 bg-gray-200 peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-purple-300 rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-6 after:w-6 after:transition-all peer-checked:bg-purple-700 shadow-inner" })] })) })] }), jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between p-5 border-2 border-gray-200 rounded-xl hover:border-purple-300 transition-all shadow-sm hover:shadow-md bg-white", children: [jsxRuntimeExports.jsx("div", { className: "flex items-start gap-4", children: jsxRuntimeExports.jsx("div", { children: jsxRuntimeExports.jsx("div", { className: "font-semibold text-lg text-gray-800", children: "Flights Included" }) }) }), jsxRuntimeExports.jsx(Controller, { name: "extras.includeFlights", control: control, render: ({ field }) => (jsxRuntimeExports.jsxs("label", { className: "relative inline-flex items-center cursor-pointer", children: [jsxRuntimeExports.jsx("input", { type: "checkbox", checked: field.value, onChange: field.onChange, className: "sr-only peer" }), jsxRuntimeExports.jsx("div", { className: "w-14 h-7 bg-gray-200 peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-purple-300 rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-6 after:w-6 after:transition-all peer-checked:bg-purple-700 shadow-inner" })] })) })] }), jsxRuntimeExports.jsxs("div", { className: "bg-white border-2 border-gray-200 rounded-xl p-5 shadow-sm", children: [jsxRuntimeExports.jsxs("label", { className: "flex items-center gap-2 text-base font-semibold mb-3 text-gray-800", children: [jsxRuntimeExports.jsx("svg", { className: "w-5 h-5 text-amber-600", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor", children: jsxRuntimeExports.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M7 8h10M7 12h4m1 8l-4-4H5a2 2 0 01-2-2V6a2 2 0 012-2h14a2 2 0 012 2v8a2 2 0 01-2 2h-3l-4 4z" }) }), "Special Requests (Optional)"] }), jsxRuntimeExports.jsx(Controller, { name: "extras.specialRequests", control: control, render: ({ field }) => (jsxRuntimeExports.jsx("textarea", Object.assign({}, field, { rows: 4, className: "w-full p-4 border-2 border-gray-300 rounded-lg focus:ring-2 focus:ring-[#6d28d9] focus:border-[#6d28d9] focus:outline-none text-base transition-all resize-none", placeholder: "Tell us about any special requirements, dietary restrictions, accessibility needs, or preferences..." }))) })] })] }), jsxRuntimeExports.jsx("div", { className: "flex-none p-4 border-t bg-white", children: jsxRuntimeExports.jsxs("button", { type: "button", onClick: handleNext, className: "w-full p-4 text-white rounded-lg text-base font-semibold shadow-md hover:shadow-lg transition-all duration-200 flex items-center justify-center gap-2", style: { background: 'linear-gradient(to right, #6d28d9, #5b21b6)' }, onMouseEnter: (e) => e.currentTarget.style.background = 'linear-gradient(to right, #5b21b6, #4c1d95)', onMouseLeave: (e) => e.currentTarget.style.background = 'linear-gradient(to right, #6d28d9, #5b21b6)', children: ["Continue to Review", jsxRuntimeExports.jsx("svg", { className: "w-5 h-5", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor", children: jsxRuntimeExports.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M13 7l5 5m0 0l-5 5m5-5H6" }) })] }) })] }));
	}

	function Step6Review({ watchedDestinations, watchedDepartureCity, watchedDates, watchedRooms, watchedContact, watchedExtras, handleGenerateOTP, }) {
	    const nights = calculateNights(watchedDates.start, watchedDates.end);
	    // Prepare a single non-wrapping date string to avoid layout breaks on small screens
	    const startDate = (watchedDates === null || watchedDates === void 0 ? void 0 : watchedDates.start) ? formatDate(watchedDates.start) : "";
	    const endDate = (watchedDates === null || watchedDates === void 0 ? void 0 : watchedDates.end) ? formatDate(watchedDates.end) : "";
	    const datesDisplay = startDate && endDate ? `${startDate}\u00A0 to \u00A0${endDate}` : "";
	    return (jsxRuntimeExports.jsxs("div", { className: "h-full flex flex-col", children: [jsxRuntimeExports.jsxs("div", { className: "flex-1 p-4 space-y-4 overflow-y-auto min-h-0", children: [jsxRuntimeExports.jsxs("div", { className: "border rounded-lg p-4", children: [jsxRuntimeExports.jsx("h3", { className: "font-semibold text-lg mb-3", children: "Trip Details" }), jsxRuntimeExports.jsxs("div", { className: "space-y-2 text-base", children: [jsxRuntimeExports.jsxs("div", { children: [jsxRuntimeExports.jsx("span", { className: "text-slate-600 font-medium", children: "Destinations:" }), jsxRuntimeExports.jsx("p", { className: "font-semibold", children: watchedDestinations.length > 0 ? watchedDestinations.join(", ") : "" })] }), jsxRuntimeExports.jsxs("div", { children: [jsxRuntimeExports.jsx("span", { className: "text-slate-600 font-medium", children: "Departure City:" }), jsxRuntimeExports.jsx("p", { className: "font-semibold", children: watchedDepartureCity || "" })] }), jsxRuntimeExports.jsxs("div", { children: [jsxRuntimeExports.jsx("span", { className: "text-slate-600 font-medium", children: "Travel Dates:" }), jsxRuntimeExports.jsx("p", { className: "font-semibold whitespace-nowrap", children: datesDisplay })] }), jsxRuntimeExports.jsxs("div", { children: [jsxRuntimeExports.jsx("span", { className: "text-slate-600 font-medium", children: "Nights:" }), jsxRuntimeExports.jsx("p", { className: "font-semibold", children: nights })] })] })] }), jsxRuntimeExports.jsxs("div", { className: "border rounded-lg p-4", children: [jsxRuntimeExports.jsx("h3", { className: "font-semibold text-lg mb-3", children: "Rooms & Guests" }), jsxRuntimeExports.jsx("div", { className: "space-y-3", children: watchedRooms.map((room, idx) => (jsxRuntimeExports.jsxs("div", { className: "text-base", children: [jsxRuntimeExports.jsxs("div", { className: "font-semibold", children: ["Room ", idx + 1] }), jsxRuntimeExports.jsxs("div", { className: "text-slate-600 font-medium", children: [room.adults, " ", room.adults === 1 ? "Adult" : "Adults", room.children > 0 && `, ${room.children} ${room.children === 1 ? "Child" : "Children"}`] }), room.childAges && room.childAges.length > 0 && (jsxRuntimeExports.jsxs("div", { className: "text-slate-600 text-sm font-medium", children: ["Child ages: ", room.childAges.filter((age) => age > 0).join(", "), " years"] }))] }, room.id))) })] }), ((watchedExtras === null || watchedExtras === void 0 ? void 0 : watchedExtras.visaAssistance) || (watchedExtras === null || watchedExtras === void 0 ? void 0 : watchedExtras.travelInsurance) || (watchedExtras === null || watchedExtras === void 0 ? void 0 : watchedExtras.specialRequests)) && (jsxRuntimeExports.jsxs("div", { className: "border rounded-lg p-4", children: [jsxRuntimeExports.jsx("h3", { className: "font-semibold text-lg mb-3", children: "Extras & Special Requests" }), jsxRuntimeExports.jsxs("div", { className: "space-y-2 text-base", children: [watchedExtras.visaAssistance && (jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-2", children: [jsxRuntimeExports.jsx("svg", { className: "w-4 h-4 text-emerald-600", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor", children: jsxRuntimeExports.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M5 13l4 4L19 7" }) }), jsxRuntimeExports.jsx("span", { className: "font-medium", children: "Visa Assistance" })] })), watchedExtras.travelInsurance && (jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-2", children: [jsxRuntimeExports.jsx("svg", { className: "w-4 h-4 text-emerald-600", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor", children: jsxRuntimeExports.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M5 13l4 4L19 7" }) }), jsxRuntimeExports.jsx("span", { className: "font-medium", children: "Travel Insurance" })] })), watchedExtras.includeFlights && (jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-2", children: [jsxRuntimeExports.jsx("svg", { className: "w-4 h-4 text-emerald-600", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor", children: jsxRuntimeExports.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M5 13l4 4L19 7" }) }), jsxRuntimeExports.jsx("span", { className: "font-medium", children: "Flights Included" })] })), watchedExtras.specialRequests && (jsxRuntimeExports.jsxs("div", { children: [jsxRuntimeExports.jsx("div", { className: "text-slate-600 font-medium mb-1", children: "Special Requests:" }), jsxRuntimeExports.jsx("div", { className: "text-slate-800 font-medium", children: watchedExtras.specialRequests })] }))] })] }))] }), jsxRuntimeExports.jsx("div", { className: "flex-none p-4 border-t bg-white", children: jsxRuntimeExports.jsx("button", { type: "button", onClick: handleGenerateOTP, className: "w-full p-4 text-white rounded-lg text-base font-semibold shadow-md hover:shadow-lg transition-all duration-200 flex items-center justify-center gap-2", style: { background: 'linear-gradient(to right, #6d28d9, #5b21b6)' }, onMouseEnter: (e) => e.currentTarget.style.background = 'linear-gradient(to right, #5b21b6, #4c1d95)', onMouseLeave: (e) => e.currentTarget.style.background = 'linear-gradient(to right, #6d28d9, #5b21b6)', children: "Generate Itinerary" }) })] }));
	}

	// Step7OTP.tsx
	function Step7OTP({ phoneNumber, handleSubmit, onSubmit }) {
	    const { validateOTP, requestOTP, error: authError, isLoading, clearError } = useAuth();
	    const [otp, setOtp] = reactExports.useState(["", "", "", "", "", ""]);
	    const [error, setError] = reactExports.useState("");
	    const [isVerified, setIsVerified] = reactExports.useState(false);
	    const [resendTimer, setResendTimer] = reactExports.useState(30);
	    const [isFadingOut, setIsFadingOut] = reactExports.useState(false);
	    // Format phone number for display
	    const formattedPhone = formatPhoneNumber(phoneNumber);
	    reactExports.useEffect(() => {
	        if (resendTimer > 0) {
	            const timer = setTimeout(() => setResendTimer(resendTimer - 1), 1000);
	            return () => clearTimeout(timer);
	        }
	    }, [resendTimer]);
	    reactExports.useEffect(() => {
	        if (isVerified) {
	            const timer1 = setTimeout(() => setIsFadingOut(true), 5500);
	            const timer2 = setTimeout(() => handleSubmit(onSubmit)(), 6000);
	            return () => {
	                clearTimeout(timer1);
	                clearTimeout(timer2);
	            };
	        }
	    }, [isVerified, handleSubmit, onSubmit]);
	    reactExports.useEffect(() => {
	        if (authError) {
	            setError(authError);
	            clearError();
	        }
	    }, [authError, clearError]);
	    const handleOtpChange = (index, value) => {
	        if (value.length > 1)
	            return;
	        if (value && !/^\d$/.test(value))
	            return;
	        const newOtp = [...otp];
	        newOtp[index] = value;
	        setOtp(newOtp);
	        setError("");
	        // Auto-focus next input
	        if (value && index < 5) {
	            const nextInput = document.getElementById(`otp-${index + 1}`);
	            nextInput === null || nextInput === void 0 ? void 0 : nextInput.focus();
	        }
	    };
	    const handleKeyDown = (index, e) => {
	        if (e.key === "Backspace" && !otp[index] && index > 0) {
	            const prevInput = document.getElementById(`otp-${index - 1}`);
	            prevInput === null || prevInput === void 0 ? void 0 : prevInput.focus();
	        }
	    };
	    const handleVerifyOTP = async () => {
	        var _a;
	        const enteredOTP = otp.join("");
	        if (enteredOTP.length !== 6) {
	            setError("Please enter all 6 digits");
	            return;
	        }
	        const success = await validateOTP(phoneNumber, enteredOTP);
	        if (success) {
	            setIsVerified(true);
	            setError("");
	        }
	        else {
	            setOtp(["", "", "", "", "", ""]);
	            (_a = document.getElementById("otp-0")) === null || _a === void 0 ? void 0 : _a.focus();
	        }
	    };
	    const handleResendOTP = async () => {
	        var _a;
	        // Reset local OTP inputs and error immediately
	        setOtp(["", "", "", "", "", ""]);
	        setError("");
	        // Ensure we have a phone number
	        if (!phoneNumber) {
	            setError("Phone number missing");
	            return;
	        }
	        // Call API to request a new OTP. Only start the resend timer if the
	        // request succeeds. Disable the resend button while request is in-flight
	        // via the `isLoading` state from AuthContext.
	        try {
	            const success = await requestOTP(phoneNumber);
	            if (success) {
	                setResendTimer(30);
	                (_a = document.getElementById("otp-0")) === null || _a === void 0 ? void 0 : _a.focus();
	            }
	            else {
	                // If the auth context provided an error it will be picked up by the
	                // authError effect above; otherwise show a generic message.
	                if (!authError)
	                    setError("Failed to resend OTP. Please try again.");
	            }
	        }
	        catch (err) {
	            if (!authError)
	                setError("Failed to resend OTP. Please try again.");
	        }
	    };
	    return (jsxRuntimeExports.jsx("div", { className: "h-full flex flex-col", children: jsxRuntimeExports.jsxs("div", { className: "flex-1 p-6 space-y-6 overflow-y-auto min-h-0", children: [jsxRuntimeExports.jsxs("div", { className: "text-center space-y-2", children: [jsxRuntimeExports.jsx("div", { className: "w-16 h-16 bg-emerald-100 rounded-full flex items-center justify-center mx-auto mb-4", children: jsxRuntimeExports.jsx("svg", { className: "w-8 h-8 text-emerald-600", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor", children: jsxRuntimeExports.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M12 15v2m-6 4h12a2 2 0 002-2v-6a2 2 0 00-2-2H6a2 2 0 00-2 2v6a2 2 0 002 2zm10-10V7a4 4 0 00-8 0v4h8z" }) }) }), jsxRuntimeExports.jsx("h3", { className: "text-xl font-bold text-gray-900", children: "Verify Your Phone Number" }), jsxRuntimeExports.jsx("p", { className: "text-base text-gray-600", children: "We've sent a 6-digit OTP to" }), jsxRuntimeExports.jsx("p", { className: "text-lg font-semibold text-emerald-600", children: formattedPhone }), jsxRuntimeExports.jsx("p", { className: "text-sm text-gray-500", children: "Enter the 6-digit OTP sent to your phone" })] }), jsxRuntimeExports.jsxs("div", { className: "space-y-4", children: [jsxRuntimeExports.jsx("label", { className: "block text-center text-base font-medium text-gray-700", children: "Enter OTP" }), jsxRuntimeExports.jsx("div", { className: "w-full max-w-[420px] mx-auto grid grid-cols-6 gap-2 md:gap-3 px-1", children: otp.map((digit, index) => (jsxRuntimeExports.jsx("input", { id: `otp-${index}`, type: "text", inputMode: "numeric", maxLength: 1, value: digit, onChange: (e) => handleOtpChange(index, e.target.value), onKeyDown: (e) => handleKeyDown(index, e), className: `w-full h-12 md:h-14 text-center text-2xl font-bold border-2 rounded-lg focus:outline-none focus:ring-2 focus:ring-emerald-500 transition-all ${error ? "border-red-500" : "border-gray-300"}`, autoFocus: index === 0 }, index))) }), error && (jsxRuntimeExports.jsx("div", { className: "text-center text-red-500 font-medium text-base", children: error })), jsxRuntimeExports.jsx("button", { type: "button", onClick: handleVerifyOTP, disabled: otp.join("").length !== 6, className: "w-full p-3 bg-emerald-600 text-white rounded-lg font-semibold text-lg disabled:opacity-50 disabled:cursor-not-allowed hover:bg-emerald-700 transition-colors", children: "Verify OTP" }), jsxRuntimeExports.jsxs("div", { className: "text-center space-y-2", children: [jsxRuntimeExports.jsx("p", { className: "text-sm text-gray-600", children: "Didn't receive the OTP?" }), resendTimer > 0 ? (jsxRuntimeExports.jsxs("p", { className: "text-sm text-gray-500", children: ["Resend OTP in ", jsxRuntimeExports.jsxs("span", { className: "font-semibold text-emerald-600", children: [resendTimer, "s"] })] })) : (jsxRuntimeExports.jsx("button", { type: "button", onClick: handleResendOTP, className: "text-emerald-600 font-medium text-base hover:underline", children: "Resend OTP" }))] })] }), jsxRuntimeExports.jsx("div", { className: "bg-amber-50 border border-amber-200 rounded-lg p-4", children: jsxRuntimeExports.jsxs("div", { className: "flex gap-3", children: [jsxRuntimeExports.jsx("svg", { className: "w-5 h-5 text-amber-600 flex-shrink-0 mt-0.5", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor", children: jsxRuntimeExports.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" }) }), jsxRuntimeExports.jsxs("div", { className: "text-sm text-amber-800", children: [jsxRuntimeExports.jsx("p", { className: "font-medium mb-1", children: "Security Note" }), jsxRuntimeExports.jsx("p", { children: "This OTP is valid for verification only. Never share it with anyone." })] })] }) })] }) }));
	}

	const STEP_1_THRESHOLD = 30000; // 30s
	const STEP_2_THRESHOLD = 60000; // 60s
	const STEP_3_THRESHOLD = 90000; // 90s
	function LoadingItinerarySequence({ open, error, onRetry, onClose, onExit, pdfUrl, fileName, onDownload, embedded = false, }) {
	    const effectivePdfUrl = reactExports.useMemo(() => {
	        const trimmed = pdfUrl === null || pdfUrl === void 0 ? void 0 : pdfUrl.trim();
	        return trimmed && trimmed.length > 0 ? trimmed : undefined;
	    }, [pdfUrl]);
	    const effectiveFileName = reactExports.useMemo(() => {
	        const trimmed = fileName === null || fileName === void 0 ? void 0 : fileName.trim();
	        return trimmed && trimmed.length > 0 ? trimmed : undefined;
	    }, [fileName]);
	    const steps = [
	        "AI is brainstorming the best itinerary for you",
	        "Building itinerary document",
	        "Preparing for download",
	        "Almost there  a few more moments",
	    ];
	    const [index, setIndex] = reactExports.useState(0);
	    const [progress, setProgress] = reactExports.useState(0);
	    const [retrying, setRetrying] = reactExports.useState(false);
	    const [downloading, setDownloading] = reactExports.useState(false);
	    const [downloadError, setDownloadError] = reactExports.useState(null);
	    const [exiting, setExiting] = reactExports.useState(false);
	    const resolvedFileName = reactExports.useMemo(() => effectiveFileName || "itinerary.pdf", [effectiveFileName]);
	    const handleDownload = reactExports.useCallback(async () => {
	        if (!effectivePdfUrl || downloading)
	            return;
	        setDownloading(true);
	        setDownloadError(null);
	        try {
	            await handleFileOpen(effectivePdfUrl, resolvedFileName);
	            onDownload === null || onDownload === void 0 ? void 0 : onDownload(effectivePdfUrl, resolvedFileName);
	        }
	        catch (err) {
	            setDownloadError("Unable to open the PDF. Please try again or contact support.");
	        }
	        finally {
	            setDownloading(false);
	        }
	    }, [downloading, effectivePdfUrl, resolvedFileName, onDownload]);
	    reactExports.useEffect(() => {
	        // reset retry state when error or modal changes
	        setRetrying(false);
	    }, [error, open]);
	    reactExports.useEffect(() => {
	        if (!open || error)
	            return;
	        setIndex(0);
	        setProgress(0);
	        const startedAt = Date.now();
	        let lastStep = -1;
	        const tick = () => {
	            const elapsed = Date.now() - startedAt;
	            const stepIdx = elapsed < STEP_1_THRESHOLD
	                ? 0
	                : elapsed < STEP_2_THRESHOLD
	                    ? 1
	                    : elapsed < STEP_3_THRESHOLD
	                        ? 2
	                        : 3;
	            if (stepIdx !== lastStep) {
	                lastStep = stepIdx;
	                setIndex(stepIdx);
	            }
	            let p = 0;
	            if (elapsed <= STEP_2_THRESHOLD) {
	                p = (elapsed / STEP_2_THRESHOLD) * 90;
	            }
	            else if (elapsed <= STEP_3_THRESHOLD) {
	                const extra = elapsed - STEP_2_THRESHOLD;
	                p = 90 + (extra / (STEP_3_THRESHOLD - STEP_2_THRESHOLD)) * 6;
	            }
	            else {
	                const extra = elapsed - STEP_3_THRESHOLD;
	                p = Math.min(99, 96 + extra / 15000);
	            }
	            setProgress(p);
	        };
	        const interval = setInterval(tick, 300);
	        tick();
	        return () => clearInterval(interval);
	    }, [open, error]);
	    if (!open)
	        return null;
	    // inline SVG icons
	    const OpenSVG = (jsxRuntimeExports.jsxs("svg", { className: "w-4 h-4 mr-2", viewBox: "0 0 24 24", fill: "none", "aria-hidden": true, xmlns: "http://www.w3.org/2000/svg", children: [jsxRuntimeExports.jsx("path", { d: "M14 3h7v7", stroke: "currentColor", strokeWidth: "1.5", strokeLinecap: "round", strokeLinejoin: "round" }), jsxRuntimeExports.jsx("path", { d: "M10 14L21 3", stroke: "currentColor", strokeWidth: "1.5", strokeLinecap: "round", strokeLinejoin: "round" }), jsxRuntimeExports.jsx("path", { d: "M21 14v7H3V3h7", stroke: "currentColor", strokeWidth: "1.5", strokeLinecap: "round", strokeLinejoin: "round" })] }));
	    const CheckSVG = (jsxRuntimeExports.jsxs("svg", { className: "w-12 h-12", viewBox: "0 0 24 24", fill: "none", "aria-hidden": true, xmlns: "http://www.w3.org/2000/svg", children: [jsxRuntimeExports.jsx("circle", { cx: "12", cy: "12", r: "10", stroke: "currentColor", strokeWidth: "1.2" }), jsxRuntimeExports.jsx("path", { d: "M7.5 12.5l2.5 2.5 5-6", stroke: "currentColor", strokeWidth: "1.5", strokeLinecap: "round", strokeLinejoin: "round" })] }));
	    // extract the inner panel so it can be rendered either as a standalone overlay
	    // or embedded inside another container (like TravelModal's right pane)
	    const panel = (jsxRuntimeExports.jsx("div", { className: `relative z-10 w-[92%] max-w-[28rem] bg-white text-slate-900 rounded-2xl shadow-2xl p-6 transform transition-all duration-200 ease-out scale-100`, style: {
	            animation: "fadeInScale .18s ease-out",
	            boxShadow: "0 -4px 6px -1px rgba(0, 0, 0, 0.1), 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 10px 15px -3px rgba(0, 0, 0, 0.1)"
	        }, children: error ? (jsxRuntimeExports.jsxs("div", { className: "space-y-3", children: [jsxRuntimeExports.jsx("h3", { id: "itinerary-loading-title", className: "text-lg font-semibold text-red-600", children: "Oops! Something went wrong" }), jsxRuntimeExports.jsx("p", { id: "itinerary-loading-desc", className: "text-sm text-slate-600 whitespace-pre-wrap break-words leading-relaxed", children: error }), jsxRuntimeExports.jsxs("div", { className: "flex justify-center gap-2", children: [jsxRuntimeExports.jsxs("button", { onClick: () => {
	                                if (retrying)
	                                    return;
	                                setRetrying(true);
	                                try {
	                                    onRetry();
	                                }
	                                catch (e) {
	                                    // swallow - callback may be sync/async
	                                }
	                                // disable for 2.5s
	                                setTimeout(() => setRetrying(false), 2500);
	                            }, disabled: retrying, className: `inline-flex items-center gap-2 px-4 py-2 rounded-lg text-sm font-medium transition ${retrying
                                ? "bg-slate-300 text-slate-700 cursor-not-allowed"
                                : "bg-sky-600 text-white hover:bg-sky-700"}`, "aria-busy": retrying, children: [retrying ? (jsxRuntimeExports.jsxs("svg", { className: "w-4 h-4 animate-spin", viewBox: "0 0 24 24", children: [jsxRuntimeExports.jsx("circle", { className: "opacity-25", cx: "12", cy: "12", r: "10", stroke: "currentColor", strokeWidth: "2", fill: "none" }), jsxRuntimeExports.jsx("path", { className: "opacity-75", d: "M4 12a8 8 0 018-8", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round" })] })) : null, retrying ? "Retrying" : "Try Again"] }), jsxRuntimeExports.jsx("button", { onClick: () => {
	                                if (!exiting) {
	                                    setExiting(true);
	                                    onClose === null || onClose === void 0 ? void 0 : onClose();
	                                }
	                            }, disabled: exiting, className: `px-4 py-2 rounded-lg text-sm font-medium transition ${exiting
                                ? "bg-blue-100 text-blue-400 cursor-not-allowed"
                                : "bg-blue-50 text-blue-700 hover:bg-blue-100 active:bg-blue-200 shadow-sm"}`, children: exiting ? "Closing..." : "Close" })] })] })) : // SUCCESS (pdfUrl present)
	            effectivePdfUrl ? (jsxRuntimeExports.jsxs("div", { className: "space-y-3 text-center", children: [jsxRuntimeExports.jsx("div", { className: "flex items-center justify-center", children: jsxRuntimeExports.jsx("div", { className: "text-green-600", children: CheckSVG }) }), jsxRuntimeExports.jsx("h3", { id: "itinerary-loading-title", className: "text-lg font-semibold", children: "Your Itinerary PDF is ready" }), jsxRuntimeExports.jsx("p", { id: "itinerary-loading-desc", className: "text-sm text-slate-600", children: "The itinerary PDF will open in a new tab. It will be available for a short time." }), downloadError && (jsxRuntimeExports.jsx("div", { className: "p-3 bg-red-50 border border-red-200 rounded-lg", children: jsxRuntimeExports.jsx("p", { className: "text-sm text-red-600", children: downloadError }) })), jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-center gap-2", children: [jsxRuntimeExports.jsxs("button", { onClick: handleDownload, disabled: downloading, className: `inline-flex items-center px-4 py-2 rounded-lg text-sm font-medium transition ${downloading ? "bg-slate-300 text-slate-700 cursor-not-allowed" : "bg-sky-600 text-white hover:bg-sky-700"}`, "aria-busy": downloading, children: [OpenSVG, "Open PDF"] }), onExit ? (jsxRuntimeExports.jsx("button", { onClick: () => {
	                                    if (!exiting && !downloading) {
	                                        setExiting(true);
	                                        onExit();
	                                    }
	                                }, disabled: downloading || exiting, className: `w-[65px] px-4 py-2 text-sm font-medium ${downloading || exiting
                                    ? "bg-blue-100 text-blue-400 cursor-not-allowed"
                                    : "bg-blue-50 text-blue-700 hover:bg-blue-100 active:bg-blue-200 shadow-sm"} rounded-lg`, children: exiting ? "Closing..." : "Close" })) : null] }), downloading ? (jsxRuntimeExports.jsx("div", { className: "mt-3 text-center", children: jsxRuntimeExports.jsx("div", { className: "text-sm text-slate-600", children: "Opening your itinerary..." }) })) : null] })) : (
	            // LOADING STATE
	            jsxRuntimeExports.jsxs("div", { className: "space-y-3", children: [jsxRuntimeExports.jsx("h3", { id: "itinerary-loading-title", className: "text-lg font-semibold", children: steps[index] }), jsxRuntimeExports.jsx("p", { id: "itinerary-loading-desc", className: "text-sm text-slate-600", children: "This usually takes a short while \u2014 stay on this page." }), jsxRuntimeExports.jsxs("div", { className: "mt-1", children: [jsxRuntimeExports.jsx("div", { className: "w-full h-2 rounded-full bg-slate-100 overflow-hidden", "aria-hidden": true, children: jsxRuntimeExports.jsx("div", { className: "h-full rounded-full transition-all duration-300", style: {
	                                        width: `${Math.min(99, Math.round(progress))}%`,
	                                        // gradient similar to original
	                                        background: "linear-gradient(90deg,#43a047 0%,#03a9f4 100%)",
	                                    } }) }), jsxRuntimeExports.jsxs("div", { className: "mt-2 text-xs text-slate-500", children: [Math.min(99, Math.round(progress)), "% complete"] })] }), jsxRuntimeExports.jsx("div", { className: "mt-4 flex justify-center", children: jsxRuntimeExports.jsxs("button", { className: "inline-flex items-center gap-2 px-3 py-2 rounded-lg bg-slate-100 text-sm cursor-not-allowed", disabled: true, "aria-disabled": true, children: [jsxRuntimeExports.jsxs("svg", { className: "w-3 h-3 animate-spin", viewBox: "0 0 24 24", children: [jsxRuntimeExports.jsx("circle", { className: "opacity-25", cx: "12", cy: "12", r: "10", stroke: "currentColor", strokeWidth: "2", fill: "none" }), jsxRuntimeExports.jsx("path", { className: "opacity-75", d: "M4 12a8 8 0 018-8", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round" })] }), "Processing"] }) })] })) }));
	    if (embedded) {
	        // When embedded we don't render backdrop or fixed positioning  just place
	        // the internal panel inside the parent layout. Use a container that will
	        // center the card inside the TravelModal right pane.
	        return (jsxRuntimeExports.jsx("div", { className: "flex h-full items-center justify-center p-6", children: jsxRuntimeExports.jsx("div", { className: "w-full max-w-[28rem]", children: panel }) }));
	    }
	    // Default: full screen overlay with backdrop
	    return (jsxRuntimeExports.jsxs("div", { role: "dialog", "aria-modal": "true", "aria-labelledby": "itinerary-loading-title", "aria-describedby": "itinerary-loading-desc", className: "fixed inset-0 z-50 flex items-center justify-center", children: [jsxRuntimeExports.jsx("div", { className: "absolute inset-0 bg-black/50 backdrop-blur-sm", "aria-hidden": true }), panel, jsxRuntimeExports.jsx("style", { children: `
        @keyframes fadeInScale {
          from {
            opacity: 0;
            transform: scale(0.96);
          }
          to {
            opacity: 1;
            transform: scale(1);
          }
        }
      ` })] }));
	}

	// TravelModal.tsx
	const DEFAULT_ROOM = {
	    id: 1,
	    adults: 2,
	    children: 0,
	    infants: 0,
	    childAges: [],
	};
	const coerceDate = (value) => {
	    if (!value)
	        return null;
	    if (typeof value === "string") {
	        const parsed = new Date(value);
	        return Number.isNaN(parsed.getTime()) ? null : parsed;
	    }
	    return value;
	};
	const normalizeRooms = (rooms) => {
	    if (!rooms || rooms.length === 0) {
	        return [Object.assign({}, DEFAULT_ROOM)];
	    }
	    return rooms.map((room, index) => {
	        var _a, _b, _c, _d, _e;
	        return ({
	            id: (_a = room.id) !== null && _a !== void 0 ? _a : index + 1,
	            adults: (_b = room.adults) !== null && _b !== void 0 ? _b : 2,
	            children: (_c = room.children) !== null && _c !== void 0 ? _c : 0,
	            infants: (_d = room.infants) !== null && _d !== void 0 ? _d : 0,
	            bedPreference: room.bedPreference,
	            childAges: (_e = room.childAges) !== null && _e !== void 0 ? _e : [],
	        });
	    });
	};
	const buildInitialFormData = (prefill) => {
	    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u;
	    return ({
	        destinations: (_a = prefill === null || prefill === void 0 ? void 0 : prefill.destinations) !== null && _a !== void 0 ? _a : [],
	        city: (_b = prefill === null || prefill === void 0 ? void 0 : prefill.city) !== null && _b !== void 0 ? _b : "",
	        dates: {
	            start: coerceDate((_c = prefill === null || prefill === void 0 ? void 0 : prefill.dates) === null || _c === void 0 ? void 0 : _c.start),
	            end: coerceDate((_d = prefill === null || prefill === void 0 ? void 0 : prefill.dates) === null || _d === void 0 ? void 0 : _d.end),
	        },
	        rooms: normalizeRooms(prefill === null || prefill === void 0 ? void 0 : prefill.rooms),
	        preference: (_e = prefill === null || prefill === void 0 ? void 0 : prefill.preference) !== null && _e !== void 0 ? _e : "value",
	        contact: {
	            name: (_g = (_f = prefill === null || prefill === void 0 ? void 0 : prefill.contact) === null || _f === void 0 ? void 0 : _f.name) !== null && _g !== void 0 ? _g : "",
	            phone: (_j = (_h = prefill === null || prefill === void 0 ? void 0 : prefill.contact) === null || _h === void 0 ? void 0 : _h.phone) !== null && _j !== void 0 ? _j : "",
	            email: (_l = (_k = prefill === null || prefill === void 0 ? void 0 : prefill.contact) === null || _k === void 0 ? void 0 : _k.email) !== null && _l !== void 0 ? _l : "",
	        },
	        extras: {
	            visaAssistance: (_o = (_m = prefill === null || prefill === void 0 ? void 0 : prefill.extras) === null || _m === void 0 ? void 0 : _m.visaAssistance) !== null && _o !== void 0 ? _o : false,
	            travelInsurance: (_q = (_p = prefill === null || prefill === void 0 ? void 0 : prefill.extras) === null || _p === void 0 ? void 0 : _p.travelInsurance) !== null && _q !== void 0 ? _q : false,
	            includeFlights: (_s = (_r = prefill === null || prefill === void 0 ? void 0 : prefill.extras) === null || _r === void 0 ? void 0 : _r.includeFlights) !== null && _s !== void 0 ? _s : false,
	            specialRequests: (_u = (_t = prefill === null || prefill === void 0 ? void 0 : prefill.extras) === null || _t === void 0 ? void 0 : _t.specialRequests) !== null && _u !== void 0 ? _u : "",
	        },
	    });
	};
	function TravelModal({ open, onClose, onComplete, prefill }) {
	    const [mounted, setMounted] = reactExports.useState(false);
	    const [step, setStep] = reactExports.useState(0);
	    const [destinationSearch, setDestinationSearch] = reactExports.useState("");
	    const [departureSearch, setDepartureSearch] = reactExports.useState("");
	    const initialFormValues = reactExports.useMemo(() => buildInitialFormData(prefill), [prefill]);
	    const { requestOTP } = useAuth();
	    const { generateItinerary, retryPdfGeneration, isLoading, error, pdfInfo, itineraryJson, clearState, clearError } = useItinerary();
	    const { control, handleSubmit, watch, setValue, formState: { errors }, trigger, getValues, reset, } = useForm({
	        resolver: o(schema),
	        defaultValues: initialFormValues,
	        mode: "onChange",
	    });
	    reactExports.useEffect(() => {
	        if (prefill) {
	            reset(initialFormValues);
	        }
	    }, [prefill, initialFormValues, reset]);
	    const watchedDestinations = watch("destinations");
	    const watchedDepartureCity = watch("city");
	    const watchedDates = watch("dates");
	    const watchedRooms = watch("rooms");
	    const watchedContact = watch("contact");
	    const watchedExtras = watch("extras");
	    // Compose request metadata and the natural-language query expected by the itinerary generator
	    const buildPayloadAndQuery = (formData) => {
	        var _a, _b, _c, _d, _e, _f;
	        const startDate = formData.dates.start;
	        const endDate = formData.dates.end;
	        const totalAdults = formData.rooms.reduce((sum, room) => sum + (room.adults || 0), 0);
	        const totalChildren = formData.rooms.reduce((sum, room) => sum + (room.children || 0), 0);
	        const totalInfants = formData.rooms.reduce((sum, room) => sum + (room.infants || 0), 0);
	        const nightsCount = Math.max(0, Math.ceil((endDate.getTime() - startDate.getTime()) / (1000 * 60 * 60 * 24)));
	        const sanitizedRooms = formData.rooms.map((room) => (Object.assign(Object.assign({}, room), { childAges: room.childAges || [] })));
	        const payload = {
	            destinations: formData.destinations,
	            city: formData.city.trim(),
	            dates: {
	                start: startDate.toISOString(),
	                end: endDate.toISOString(),
	            },
	            rooms: sanitizedRooms,
	            preference: formData.preference,
	            contact: {
	                name: (_a = formData.contact.name) === null || _a === void 0 ? void 0 : _a.trim(),
	                phone: formData.contact.phone,
	                email: (_b = formData.contact.email) === null || _b === void 0 ? void 0 : _b.trim(),
	            },
	            extras: formData.extras,
	        };
	        const daysCount = nightsCount + 1;
	        const nightsLabel = `${nightsCount} Night${nightsCount === 1 ? "" : "s"} and ${daysCount} Day${daysCount === 1 ? "" : "s"}`;
	        const travellersDescription = (() => {
	            if (totalAdults === 2 && totalChildren === 0 && totalInfants === 0) {
	                return "couples";
	            }
	            const segments = [];
	            if (totalAdults > 0) {
	                segments.push(`${totalAdults} ${totalAdults === 1 ? "Adult" : "Adults"}`);
	            }
	            if (totalChildren > 0) {
	                segments.push(`${totalChildren} ${totalChildren === 1 ? "Child" : "Children"}`);
	            }
	            if (totalInfants > 0) {
	                segments.push(`${totalInfants} ${totalInfants === 1 ? "Infant" : "Infants"}`);
	            }
	            return segments.join(" + ") || "travellers";
	        })();
	        const destinationTitle = payload.destinations.length > 0 ? payload.destinations.join(" + ") : "Trip";
	        let query = `${destinationTitle} ${nightsLabel} for ${travellersDescription}`;
	        if (payload.city) {
	            query += ` departing from ${payload.city}`;
	        }
	        query += ` | Adults: ${totalAdults}`;
	        if (totalChildren) {
	            query += `, Children: ${totalChildren}`;
	        }
	        if (totalInfants) {
	            query += `, Infants: ${totalInfants}`;
	        }
	        const childAges = sanitizedRooms
	            .flatMap((room) => room.childAges || [])
	            .filter((age) => typeof age === "number" && age > 0);
	        if (childAges.length) {
	            query += ` (Child ages ${childAges.join(", ")})`;
	        }
	        if (formData.preference === "comfort") {
	            query += ", prefer premium accommodations";
	        }
	        const extrasDetails = [];
	        if ((_c = formData.extras) === null || _c === void 0 ? void 0 : _c.includeFlights)
	            extrasDetails.push("include flights");
	        if ((_d = formData.extras) === null || _d === void 0 ? void 0 : _d.visaAssistance)
	            extrasDetails.push("include visa assistance");
	        if ((_e = formData.extras) === null || _e === void 0 ? void 0 : _e.travelInsurance)
	            extrasDetails.push("include travel insurance");
	        if ((_f = formData.extras) === null || _f === void 0 ? void 0 : _f.specialRequests)
	            extrasDetails.push(formData.extras.specialRequests);
	        if (extrasDetails.length) {
	            query += `, ${extrasDetails.join(", ")}`;
	        }
	        return { payload, query };
	    };
	    reactExports.useEffect(() => {
	        setMounted(true);
	        return () => setMounted(false);
	    }, []);
	    reactExports.useEffect(() => {
	        if (!mounted) {
	            return;
	        }
	        document.body.style.overflow = open ? "hidden" : "unset";
	        return () => {
	            document.body.style.overflow = "unset";
	        };
	    }, [open, mounted]);
	    // Load saved form (except city)
	    reactExports.useEffect(() => {
	        if (mounted && !prefill) {
	            const saved = sessionStorage.getItem("travelForm");
	            if (saved) {
	                const parsed = JSON.parse(saved);
	                setValue("destinations", parsed.destinations || []);
	                setValue("dates", parsed.dates);
	                setValue("rooms", parsed.rooms);
	                setValue("preference", parsed.preference);
	                setValue("contact", parsed.contact);
	                setValue("extras", parsed.extras);
	            }
	        }
	    }, [mounted, setValue, prefill]);
	    // Save progress
	    reactExports.useEffect(() => {
	        if (mounted) {
	            const data = getValues();
	            sessionStorage.setItem("travelForm", JSON.stringify(data));
	        }
	    }, [step, mounted, getValues]);
	    // Navigate to loading step when generation starts
	    reactExports.useEffect(() => {
	        if (isLoading || error || pdfInfo) {
	            setStep(8);
	        }
	    }, [isLoading, error, pdfInfo]);
	    if (!mounted || !open)
	        return null;
	    const handleNext = async () => {
	        let isValid = false;
	        switch (step) {
	            case 0:
	                isValid = await trigger("destinations");
	                break;
	            case 1:
	                isValid = await trigger("city");
	                break;
	            case 2:
	                isValid = await trigger("dates");
	                break;
	            case 3:
	                isValid = await trigger("rooms");
	                break;
	            case 4:
	                isValid = await trigger("extras");
	                break;
	            case 5:
	                isValid = true;
	                break;
	            default:
	                isValid = true;
	        }
	        if (isValid)
	            setStep(step + 1);
	    };
	    const handleBack = () => {
	        if (step > 0 && step !== 8)
	            setStep(step - 1);
	    };
	    const handleSendOTP = async () => {
	        const isValid = await trigger("contact");
	        if (isValid) {
	            const phone = watchedContact === null || watchedContact === void 0 ? void 0 : watchedContact.phone;
	            if (phone) {
	                const success = await requestOTP(phone);
	                if (success) {
	                    setStep(7); // move to OTP screen
	                }
	            }
	        }
	    };
	    const onSubmit = async (data) => {
	        var _a, _b;
	        if (!((_a = data.dates) === null || _a === void 0 ? void 0 : _a.start) || !((_b = data.dates) === null || _b === void 0 ? void 0 : _b.end)) {
	            return;
	        }
	        const { payload, query } = buildPayloadAndQuery(data);
	        const succeeded = await generateItinerary(query, payload);
	        if (!succeeded) {
	            return;
	        }
	        onComplete === null || onComplete === void 0 ? void 0 : onComplete(payload);
	        sessionStorage.removeItem("travelForm");
	        reset();
	        setDestinationSearch("");
	        setDepartureSearch("");
	        setStep(0);
	    };
	    const handleGenerationDismiss = () => {
	        const hasPdf = Boolean(pdfInfo);
	        clearError();
	        if (hasPdf) {
	            // Only reset to step 0 if PDF was successfully generated
	            setStep(0);
	            clearState();
	        }
	    };
	    const handleExitBuilder = () => {
	        handleGenerationDismiss();
	        onClose();
	    };
	    const handleRetry = async () => {
	        var _a, _b;
	        // Retry current generation without changing step
	        const data = getValues();
	        if (!((_a = data.dates) === null || _a === void 0 ? void 0 : _a.start) || !((_b = data.dates) === null || _b === void 0 ? void 0 : _b.end)) {
	            return;
	        }
	        const { payload } = buildPayloadAndQuery(data);
	        // If we have itinerary JSON, retry only PDF generation
	        if (itineraryJson) {
	            await retryPdfGeneration(payload);
	        }
	        else {
	            // Otherwise, regenerate everything
	            const { query } = buildPayloadAndQuery(data);
	            await generateItinerary(query, payload);
	        }
	    };
	    const renderStepContent = () => {
	        var _a, _b, _c;
	        switch (step) {
	            case 0:
	                return (jsxRuntimeExports.jsx(StepDestination, { citySearch: destinationSearch, setCitySearch: setDestinationSearch, setValue: setValue, watch: watch, setStep: setStep, errors: errors }));
	            case 1:
	                return (jsxRuntimeExports.jsx(Step0City, { citySearch: departureSearch, setCitySearch: setDepartureSearch, setValue: setValue, setStep: setStep, errors: errors }));
	            case 2:
	                return (jsxRuntimeExports.jsx(Step1Dates, { setValue: setValue, setStep: setStep, errors: errors, watchedDates: watchedDates }));
	            case 3:
	                return (jsxRuntimeExports.jsx(Step2Rooms, { setValue: setValue, errors: errors, watchedRooms: watchedRooms, handleNext: handleNext }));
	            case 4:
	                return jsxRuntimeExports.jsx(Step5Extras, { control: control, handleNext: handleNext });
	            case 5:
	                return (jsxRuntimeExports.jsx(Step6Review, { watchedDestinations: watchedDestinations, watchedDepartureCity: watchedDepartureCity, watchedDates: watchedDates, watchedRooms: watchedRooms, watchedContact: watchedContact, watchedExtras: watchedExtras, handleGenerateOTP: handleNext }));
	            case 6:
	                return (jsxRuntimeExports.jsx(Step4Contact, { control: control, errors: errors, handleNext: handleNext, onVerifyContact: handleSendOTP }));
	            case 7:
	                return (jsxRuntimeExports.jsx(Step7OTP, { phoneNumber: (watchedContact === null || watchedContact === void 0 ? void 0 : watchedContact.phone) || "", handleSubmit: handleSubmit, onSubmit: onSubmit }));
	            case 8:
	                return (jsxRuntimeExports.jsx(LoadingItinerarySequence, { open: true, embedded: true, error: error, pdfUrl: (_a = pdfInfo === null || pdfInfo === void 0 ? void 0 : pdfInfo.url) !== null && _a !== void 0 ? _a : undefined, fileName: (_c = (_b = pdfInfo === null || pdfInfo === void 0 ? void 0 : pdfInfo.filename) !== null && _b !== void 0 ? _b : pdfInfo === null || pdfInfo === void 0 ? void 0 : pdfInfo.fileName) !== null && _c !== void 0 ? _c : undefined, onRetry: handleRetry, onClose: handleGenerationDismiss, onExit: handleExitBuilder }));
	            default:
	                return null;
	        }
	    };
	    const stepTitles = [
	        "Select Destination",
	        "Choose your departure city",
	        "Choose your departure date",
	        "Choose your pax configuration",
	        "Extras & Special Requests",
	        "Review & Submit",
	        "Contact Information",
	        "Verify OTP",
	        "Generating Itinerary",
	    ];
	    return reactDomExports.createPortal(jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: jsxRuntimeExports.jsxs("div", { className: "fixed inset-0 z-[9999]", children: [jsxRuntimeExports.jsx("div", { className: `absolute inset-0 bg-[#00000026] ${step === 8 ? "pointer-events-none" : "cursor-default"}`, "aria-hidden": true }), jsxRuntimeExports.jsxs("div", { className: "absolute inset-0 sm:inset-auto sm:top-1/2 sm:left-1/2 sm:-translate-x-1/2 sm:-translate-y-1/2 sm:max-w-2xl sm:h-[600px] w-full bg-white sm:rounded-xl shadow-xl flex", children: [jsxRuntimeExports.jsx(ImageCover, {}), jsxRuntimeExports.jsxs("div", { className: "flex-1 flex flex-col h-full min-w-0", children: [jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between p-4 border-b", children: [jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-3", children: [step > 0 && step !== 8 && (jsxRuntimeExports.jsx("button", { onClick: handleBack, className: "p-1 hover:bg-slate-100 rounded-full", children: jsxRuntimeExports.jsx("svg", { className: "w-5 h-5", viewBox: "0 0 20 20", fill: "currentColor", children: jsxRuntimeExports.jsx("path", { fillRule: "evenodd", d: "M12.707 5.293a1 1 0 010 1.414L9.414 10l3.293 3.293a1 1 0 01-1.414 1.414l-4-4a1 1 0 010-1.414l4-4a1 1 0 011.414 0z", clipRule: "evenodd" }) }) })), jsxRuntimeExports.jsx("h2", { className: "text-xl font-semibold", children: stepTitles[step] })] }), jsxRuntimeExports.jsx("button", { onClick: step === 8 ? undefined : onClose, disabled: step === 8, className: `p-2 ${step === 8 ? 'opacity-50 cursor-not-allowed' : ''}`, children: jsxRuntimeExports.jsx("svg", { className: "w-5 h-5", viewBox: "0 0 20 20", fill: "currentColor", children: jsxRuntimeExports.jsx("path", { fillRule: "evenodd", d: "M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z", clipRule: "evenodd" }) }) })] }), jsxRuntimeExports.jsx("div", { className: "px-4 py-2 border-b", children: jsxRuntimeExports.jsx("div", { className: "flex gap-1", children: [0, 1, 2, 3, 4, 5, 6, 7, 8].map((s) => (jsxRuntimeExports.jsx("div", { className: `h-1 flex-1 rounded-full ${s <= step ? "bg-amber-400" : "bg-slate-200"}` }, s))) }) }), jsxRuntimeExports.jsx("div", { className: "flex-1 overflow-hidden", children: jsxRuntimeExports.jsx("div", { className: "h-full overflow-y-auto", children: renderStepContent() }) })] })] })] }) }), document.body);
	}

	function TravelModalShimmer() {
	    return (jsxRuntimeExports.jsx("div", { className: "fixed inset-0 z-[9999]", children: jsxRuntimeExports.jsxs("div", { className: "absolute inset-0 sm:inset-auto sm:top-1/2 sm:left-1/2 sm:-translate-x-1/2 sm:-translate-y-1/2 sm:max-w-2xl sm:h-[600px] w-full bg-white sm:rounded-xl shadow-xl flex flex-col sm:flex-row overflow-hidden", children: [jsxRuntimeExports.jsx("div", { className: "hidden sm:block w-80 bg-gradient-to-b from-slate-100 to-slate-200 relative overflow-hidden before:absolute before:inset-0 before:-translate-x-full before:bg-gradient-to-r before:from-transparent before:via-white/60 before:to-transparent before:animate-[shimmer_1.3s_linear_infinite]" }), jsxRuntimeExports.jsxs("div", { className: "flex-1 flex flex-col h-full min-w-0", children: [jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between p-4 border-b", children: [jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-3", children: [jsxRuntimeExports.jsx("div", { className: "h-5 w-5 bg-slate-100 rounded-full relative overflow-hidden before:absolute before:inset-0 before:-translate-x-full before:bg-gradient-to-r before:from-transparent before:via-white/60 before:to-transparent before:animate-[shimmer_1.3s_linear_infinite]" }), jsxRuntimeExports.jsx("div", { className: "h-6 w-40 bg-slate-100 rounded relative overflow-hidden before:absolute before:inset-0 before:-translate-x-full before:bg-gradient-to-r before:from-transparent before:via-white/60 before:to-transparent before:animate-[shimmer_1.2s_linear_infinite]" })] }), jsxRuntimeExports.jsx("div", { className: "h-5 w-5 bg-slate-100 rounded-full relative overflow-hidden before:absolute before:inset-0 before:-translate-x-full before:bg-gradient-to-r before:from-transparent before:via-white/60 before:to-transparent before:animate-[shimmer_1.2s_linear_infinite]" })] }), jsxRuntimeExports.jsx("div", { className: "px-4 py-2 border-b", children: jsxRuntimeExports.jsx("div", { className: "flex gap-1", children: Array.from({ length: 9 }).map((_, i) => (jsxRuntimeExports.jsx("div", { className: "h-1 flex-1 rounded-full bg-slate-100 relative overflow-hidden before:absolute before:inset-0 before:-translate-x-full before:bg-gradient-to-r before:from-transparent before:via-white/50 before:to-transparent before:animate-[shimmer_1.6s_linear_infinite]" }, i))) }) }), jsxRuntimeExports.jsx("div", { className: "flex-1 overflow-hidden", children: jsxRuntimeExports.jsxs("div", { className: "h-full overflow-y-auto p-4 space-y-4", children: [jsxRuntimeExports.jsx("div", { className: "h-6 w-1/2 bg-slate-100 rounded relative overflow-hidden before:absolute before:inset-0 before:-translate-x-full before:bg-gradient-to-r before:from-transparent before:via-white/60 before:to-transparent before:animate-[shimmer_1.2s_linear_infinite]" }), jsxRuntimeExports.jsx("div", { className: "h-40 bg-slate-50 rounded relative overflow-hidden before:absolute before:inset-0 before:-translate-x-full before:bg-gradient-to-r before:from-transparent before:via-white/60 before:to-transparent before:animate-[shimmer_1.3s_linear_infinite]" }), jsxRuntimeExports.jsx("div", { className: "grid grid-cols-2 gap-3", children: Array.from({ length: 2 }).map((_, i) => (jsxRuntimeExports.jsx("div", { className: "h-12 bg-slate-100 rounded relative overflow-hidden before:absolute before:inset-0 before:-translate-x-full before:bg-gradient-to-r before:from-transparent before:via-white/60 before:to-transparent before:animate-[shimmer_1.2s_linear_infinite]" }, i))) }), jsxRuntimeExports.jsx("div", { className: "h-10 w-1/3 bg-slate-100 rounded relative overflow-hidden before:absolute before:inset-0 before:-translate-x-full before:bg-gradient-to-r before:from-transparent before:via-white/60 before:to-transparent before:animate-[shimmer_1.4s_linear_infinite]" })] }) })] })] }) }));
	}

	const DEFAULT_STYLESHEET = "https://cdn.tailwindcss.com";
	const ROOT_ID = "travel-widget-root";
	const ensureStylesheet = (href) => {
	    if (!href || typeof document === "undefined")
	        return;
	    if (document.getElementById("travel-widget-stylesheet"))
	        return;
	    const script = document.createElement("script");
	    script.id = "travel-widget-stylesheet";
	    script.src = href;
	    script.crossOrigin = "anonymous";
	    document.head.appendChild(script);
	};
	const resolveContainer = (target) => {
	    if (typeof document === "undefined") {
	        return { element: null, created: false };
	    }
	    if (target instanceof HTMLElement) {
	        return { element: target, created: false };
	    }
	    if (typeof target === "string") {
	        const found = document.querySelector(target);
	        if (found) {
	            return { element: found, created: false };
	        }
	    }
	    let host = document.getElementById(ROOT_ID);
	    if (!host) {
	        host = document.createElement("div");
	        host.id = ROOT_ID;
	        document.body.appendChild(host);
	        return { element: host, created: true };
	    }
	    return { element: host, created: false };
	};
	const WidgetApp = React.forwardRef(function WidgetApp({ options }, ref) {
	    var _a;
	    const [open, setOpen] = reactExports.useState((_a = options.autoOpen) !== null && _a !== void 0 ? _a : true);
	    const [prefill, setPrefill] = reactExports.useState(options.prefill);
	    reactExports.useImperativeHandle(ref, () => ({
	        open: () => setOpen(true),
	        close: () => setOpen(false),
	        setPrefill: (next) => setPrefill(next),
	    }), []);
	    reactExports.useEffect(() => {
	        if (options.autoOpen !== undefined) {
	            setOpen(options.autoOpen);
	        }
	    }, [options.autoOpen]);
	    reactExports.useEffect(() => {
	        setPrefill(options.prefill);
	    }, [options.prefill]);
	    const handleClose = () => {
	        var _a;
	        setOpen(false);
	        (_a = options.onClose) === null || _a === void 0 ? void 0 : _a.call(options);
	    };
	    const handleComplete = (data) => {
	        var _a;
	        (_a = options.onComplete) === null || _a === void 0 ? void 0 : _a.call(options, data);
	    };
	    return (jsxRuntimeExports.jsx(AuthProvider, { apiBaseUrl: options.apiBaseUrl, children: jsxRuntimeExports.jsx(ItineraryProvider, { apiBaseUrl: options.apiBaseUrl, children: jsxRuntimeExports.jsx(reactExports.Suspense, { fallback: jsxRuntimeExports.jsx(TravelModalShimmer, {}), children: jsxRuntimeExports.jsx(TravelModal, { open: open, onClose: handleClose, onComplete: handleComplete, prefill: prefill }) }) }) }));
	});
	let root = null;
	let hostElement = null;
	let createdHost = false;
	let widgetRef = null;
	const TravelWidget = {
	    init(options = {}) {
	        var _a, _b;
	        if (typeof document === "undefined") {
	            return;
	        }
	        this.destroy();
	        const resolved = Object.assign(Object.assign({}, options), { stylesheetUrl: (_a = options.stylesheetUrl) !== null && _a !== void 0 ? _a : DEFAULT_STYLESHEET, autoOpen: (_b = options.autoOpen) !== null && _b !== void 0 ? _b : true });
	        ensureStylesheet(resolved.stylesheetUrl);
	        const container = resolveContainer(options.container);
	        if (!container.element) {
	            return;
	        }
	        hostElement = container.element;
	        createdHost = container.created;
	        widgetRef = React.createRef();
	        root = clientExports.createRoot(hostElement);
	        root.render(jsxRuntimeExports.jsx(WidgetApp, { options: resolved, ref: widgetRef }));
	    },
	    open() {
	        var _a;
	        (_a = widgetRef === null || widgetRef === void 0 ? void 0 : widgetRef.current) === null || _a === void 0 ? void 0 : _a.open();
	    },
	    close() {
	        var _a;
	        (_a = widgetRef === null || widgetRef === void 0 ? void 0 : widgetRef.current) === null || _a === void 0 ? void 0 : _a.close();
	    },
	    updatePrefill(prefill) {
	        var _a;
	        (_a = widgetRef === null || widgetRef === void 0 ? void 0 : widgetRef.current) === null || _a === void 0 ? void 0 : _a.setPrefill(prefill);
	    },
	    destroy() {
	        if (root) {
	            root.unmount();
	            root = null;
	        }
	        if (createdHost && (hostElement === null || hostElement === void 0 ? void 0 : hostElement.parentElement)) {
	            hostElement.parentElement.removeChild(hostElement);
	        }
	        hostElement = null;
	        createdHost = false;
	        widgetRef = null;
	    },
	};
	if (typeof window !== "undefined") {
	    window.TravelWidget = TravelWidget;
	}

	return TravelWidget;

}));
//# sourceMappingURL=travel-widget.js.map
